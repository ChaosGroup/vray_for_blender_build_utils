diff --git a/CMakeLists.txt b/CMakeLists.txt
index 7ebc20f..8e417c0 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -275,6 +275,9 @@ set(CYCLES_CUDA_BINARIES_ARCH sm_20 sm_21 sm_30 sm_35 CACHE STRING "CUDA archite
 mark_as_advanced(CYCLES_CUDA_BINARIES_ARCH)
 unset(PLATFORM_DEFAULT)
 
+# V-Ray For Blender
+option(WITH_VRAY_FOR_BLENDER		"Enable V-Ray For Blender extentions" OFF)
+
 # LLVM
 option(WITH_LLVM					"Use LLVM" OFF)
 option(LLVM_STATIC					"Link with LLVM static libraries" ON)
@@ -509,6 +512,12 @@ if(WITH_BOOL_COMPAT)
 	add_definitions(-DWITH_BOOL_COMPAT)
 endif()
 
+if(WITH_VRAY_FOR_BLENDER)
+	# set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wno-switch -std=c++0x")
+	add_definitions(-DWITH_VRAY_FOR_BLENDER)
+endif()
+
+
 #-----------------------------------------------------------------------------
 # Check for valid directories
 # ... a partial checkout may cause this.
@@ -2324,6 +2333,7 @@ if(FIRST_RUN)
 	info_cfg_option(WITH_INPUT_NDOF)
 	info_cfg_option(WITH_CYCLES)
 	info_cfg_option(WITH_FREESTYLE)
+	info_cfg_option(WITH_VRAY_FOR_BLENDER)
 	info_cfg_option(WITH_OPENCOLORIO)
 
 	info_cfg_text("Compiler Options:")
diff --git a/SConstruct b/SConstruct
index b0c7750..c0847c0 100644
--- a/SConstruct
+++ b/SConstruct
@@ -260,6 +260,7 @@ if 'blenderlite' in B.targets:
     target_env_defs['WITH_BF_3DMOUSE'] = False
     target_env_defs['WITH_BF_LIBMV'] = False
     target_env_defs['WITH_BF_FREESTYLE'] = False
+    target_env_defs['WITH_VRAY_FOR_BLENDER'] = False
 
     # Merge blenderlite, let command line to override
     for k,v in target_env_defs.iteritems():
diff --git a/build_files/scons/tools/Blender.py b/build_files/scons/tools/Blender.py
index ac001b5..a8f98b3 100644
--- a/build_files/scons/tools/Blender.py
+++ b/build_files/scons/tools/Blender.py
@@ -391,6 +391,9 @@ def creator(env):
         incs.append('#/source/blender/freestyle')
         defs.append('WITH_FREESTYLE')
 
+    if env['WITH_VRAY_FOR_BLENDER']:
+        defs.append('WITH_VRAY_FOR_BLENDER')
+
     if env['OURPLATFORM'] in ('win32-vc', 'win32-mingw', 'linuxcross', 'win64-vc', 'win64-mingw'):
         incs.append(env['BF_PTHREADS_INC'])
         incs.append('#/intern/utfconv')
diff --git a/build_files/scons/tools/btools.py b/build_files/scons/tools/btools.py
index 744896c..8dd8908 100644
--- a/build_files/scons/tools/btools.py
+++ b/build_files/scons/tools/btools.py
@@ -132,6 +132,8 @@ def validate_arguments(args, bc):
             'WITH_X11_XINPUT',
             'WITH_X11_XF86VMODE',
             'BF_GHOST_DEBUG',
+            'WITH_VRAY_FOR_BLENDER'
+            'USE_QTKIT',
             'BF_FANCY', 'BF_QUIET', 'BF_LINE_OVERWRITE',
             'BF_X264_CONFIG',
             'BF_XVIDCORE_CONFIG',
@@ -562,6 +564,8 @@ def read_opts(env, cfg, args):
         ('BF_CYCLES_CUDA_ENV', 'preset environement nvcc will execute in', ''),
         ('BF_CYCLES_CUDA_BINARIES_ARCH', 'CUDA architectures to compile binaries for', []),
 
+        (BoolVariable('WITH_VRAY_FOR_BLENDER', 'Compile with V-Ray For Blender extentions', True)),
+
         (BoolVariable('WITH_BF_OIIO', 'Build with OpenImageIO', False)),
         (BoolVariable('WITH_BF_STATICOIIO', 'Statically link to OpenImageIO', False)),
         ('BF_OIIO', 'OIIO root path', ''),
diff --git a/release/datafiles/splash.png b/release/datafiles/splash.png
index ad0028e..3e0f53d 100644
Binary files a/release/datafiles/splash.png and b/release/datafiles/splash.png differ
diff --git a/source/blender/CMakeLists.txt b/source/blender/CMakeLists.txt
index 0d30952..eed7953 100644
--- a/source/blender/CMakeLists.txt
+++ b/source/blender/CMakeLists.txt
@@ -149,3 +149,7 @@ if(WITH_FREESTYLE)
 	add_subdirectory(freestyle)
 endif()
 
+if(WITH_VRAY_FOR_BLENDER)
+	add_subdirectory(exporter)
+	add_subdirectory(vray_for_blender)
+endif()
diff --git a/source/blender/SConscript b/source/blender/SConscript
index de052f2..5920602 100644
--- a/source/blender/SConscript
+++ b/source/blender/SConscript
@@ -72,3 +72,7 @@ if env['WITH_BF_COMPOSITOR']:
 
 if env['WITH_BF_FREESTYLE']:
     SConscript (['freestyle/SConscript'])
+
+if env['WITH_VRAY_FOR_BLENDER']:
+    SConscript (['exporter/SConscript'])
+    SConscript (['vray_for_blender/SConscript'])
diff --git a/source/blender/blenkernel/BKE_object.h b/source/blender/blenkernel/BKE_object.h
index 72c4c21..80fcaf7 100644
--- a/source/blender/blenkernel/BKE_object.h
+++ b/source/blender/blenkernel/BKE_object.h
@@ -167,7 +167,7 @@ void BKE_object_tfm_protected_restore(struct Object *ob,
 void BKE_object_handle_update(struct EvaluationContext *eval_ctx, struct Scene *scene, struct Object *ob);
 void BKE_object_handle_update_ex(struct EvaluationContext *eval_ctx,
                                  struct Scene *scene, struct Object *ob,
-                                 struct RigidBodyWorld *rbw);
+								 struct RigidBodyWorld *rbw);
 void BKE_object_sculpt_modifiers_changed(struct Object *ob);
 
 int BKE_object_obdata_texspace_get(struct Object *ob, short **r_texflag, float **r_loc, float **r_size, float **r_rot);
diff --git a/source/blender/blenkernel/intern/object.c b/source/blender/blenkernel/intern/object.c
index 05365a8..5f756cf 100644
--- a/source/blender/blenkernel/intern/object.c
+++ b/source/blender/blenkernel/intern/object.c
@@ -66,6 +66,7 @@
 #include "BLI_utildefines.h"
 #include "BLI_linklist.h"
 #include "BLI_kdtree.h"
+#include "BLI_callbacks.h"
 
 #include "BLF_translation.h"
 
@@ -2844,7 +2845,7 @@ bool BKE_object_parent_loop_check(const Object *par, const Object *ob)
 /* Ideally we shouldn't have to pass the rigid body world, but need bigger restructuring to avoid id */
 void BKE_object_handle_update_ex(EvaluationContext *eval_ctx,
                                  Scene *scene, Object *ob,
-                                 RigidBodyWorld *rbw)
+								 RigidBodyWorld *rbw)
 {
 	if (ob->recalc & OB_RECALC_ALL) {
 		/* speed optimization for animation lookups */
@@ -3022,8 +3023,13 @@ void BKE_object_handle_update_ex(EvaluationContext *eval_ctx,
 						psys_get_modifier(ob, psys)->flag &= ~eParticleSystemFlag_psys_updated;
 				}
 			}
-			
+
 			/* quick cache removed */
+
+			BLI_callback_exec(NULL, &ob->id, BLI_CB_EVT_OBJECT_DATA_UPDATE);
+		}
+		else {
+			BLI_callback_exec(NULL, &ob->id, BLI_CB_EVT_OBJECT_UPDATE);
 		}
 
 		ob->recalc &= ~OB_RECALC_ALL;
diff --git a/source/blender/blenlib/BLI_callbacks.h b/source/blender/blenlib/BLI_callbacks.h
index 8d5ea91..95f41f5 100644
--- a/source/blender/blenlib/BLI_callbacks.h
+++ b/source/blender/blenlib/BLI_callbacks.h
@@ -43,6 +43,8 @@ typedef enum {
 	BLI_CB_EVT_SAVE_POST,
 	BLI_CB_EVT_SCENE_UPDATE_PRE,
 	BLI_CB_EVT_SCENE_UPDATE_POST,
+	BLI_CB_EVT_OBJECT_UPDATE,
+	BLI_CB_EVT_OBJECT_DATA_UPDATE,
 	BLI_CB_EVT_GAME_PRE,
 	BLI_CB_EVT_GAME_POST,
 	BLI_CB_EVT_TOT
diff --git a/source/blender/editors/include/UI_icons.h b/source/blender/editors/include/UI_icons.h
index dcc526b..253c962 100644
--- a/source/blender/editors/include/UI_icons.h
+++ b/source/blender/editors/include/UI_icons.h
@@ -273,15 +273,16 @@ DEF_ICON(GROUP_UVS)
 DEF_ICON(RNA)
 DEF_ICON(RNA_ADD)
 
+DEF_ICON(VRAY_LOGO)
+DEF_ICON(VRAY_LOGO_MONO)
+DEF_ICON(VRAY_WORLD)
+DEF_ICON(VRAY_LIGHT)
+DEF_ICON(VRAY_MATERIAL)
+DEF_ICON(VRAY_OBJECT)
+DEF_ICON(VRAY_RENDER_LAYERS)
+
 	/* available */
 #ifndef DEF_ICON_BLANK_SKIP
-	DEF_ICON(BLANK092)
-	DEF_ICON(BLANK093)
-	DEF_ICON(BLANK094)
-	DEF_ICON(BLANK095)
-	DEF_ICON(BLANK096)
-	DEF_ICON(BLANK097)
-	DEF_ICON(BLANK098)
 	DEF_ICON(BLANK099)
 	DEF_ICON(BLANK100)
 	DEF_ICON(BLANK101)
diff --git a/source/blender/editors/space_api/CMakeLists.txt b/source/blender/editors/space_api/CMakeLists.txt
index bf32573..9713da5 100644
--- a/source/blender/editors/space_api/CMakeLists.txt
+++ b/source/blender/editors/space_api/CMakeLists.txt
@@ -27,6 +27,7 @@ set(INC
 	../../makesrna
 	../../windowmanager
 	../../../../intern/guardedalloc
+	../../exporter
 )
 
 set(INC_SYS
diff --git a/source/blender/editors/space_api/SConscript b/source/blender/editors/space_api/SConscript
index 2ba918f..2427b72 100644
--- a/source/blender/editors/space_api/SConscript
+++ b/source/blender/editors/space_api/SConscript
@@ -39,6 +39,7 @@ incs = [
     '../../makesdna',
     '../../makesrna',
     '../../windowmanager',
+    '../../exporter'
     ]
 incs = ' '.join(incs)
 
diff --git a/source/blender/editors/space_api/spacetypes.c b/source/blender/editors/space_api/spacetypes.c
index e226239..304af1e 100644
--- a/source/blender/editors/space_api/spacetypes.c
+++ b/source/blender/editors/space_api/spacetypes.c
@@ -66,6 +66,8 @@
 #include "ED_mask.h"
 #include "ED_sequencer.h"
 
+#include "ED_exporter.h"
+
 #include "io_ops.h"
 
 /* only call once on startup, storage is global in BKE kernel listbase */
@@ -129,6 +131,8 @@ void ED_spacetypes_init(void)
 			type->operatortypes();
 	}
 
+	ED_operatortypes_exporter();
+
 	/* Macros's must go last since they reference other operators
 	 * maybe we'll need to have them go after python operators too? */
 	ED_operatormacros_armature();
diff --git a/source/blender/exporter/CMakeLists.txt b/source/blender/exporter/CMakeLists.txt
new file mode 100644
index 0000000..395b6d9
--- /dev/null
+++ b/source/blender/exporter/CMakeLists.txt
@@ -0,0 +1,28 @@
+set(INC
+    .
+    ../blenlib
+    ../blenkernel
+    ../blenloader
+    ../makesdna
+    ../makesrna
+    ../windowmanager
+    ../../../intern/guardedalloc
+    ../../../intern/smoke/extern
+)
+
+set(SRC
+    exporter_geometry.c
+    exporter_ops.c
+
+    exporter_includes.h
+    exporter_geometry.h
+
+    ED_exporter.h
+)
+
+set(INC_SYS
+
+)
+
+blender_add_lib(vb_exporter "${SRC}" "${INC}" "${INC_SYS}")
+
diff --git a/source/blender/exporter/ED_exporter.h b/source/blender/exporter/ED_exporter.h
new file mode 100644
index 0000000..a81afad
--- /dev/null
+++ b/source/blender/exporter/ED_exporter.h
@@ -0,0 +1,34 @@
+/*
+
+  V-Ray/Blender
+
+  http://vray.cgdo.ru
+
+  Author: Andrey M. Izrantsev (aka bdancer)
+  E-Mail: izrantsev@cgdo.ru
+
+  This program is free software; you can redistribute it and/or
+  modify it under the terms of the GNU General Public License
+  as published by the Free Software Foundation; either version 2
+  of the License, or (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
+
+*/
+
+#ifndef ED_EXPORTER_H
+#define ED_EXPORTER_H
+
+struct wmOperatorType;
+
+void ED_operatortypes_exporter(void);
+
+#endif // ED_EXPORTER_H
diff --git a/source/blender/exporter/SConscript b/source/blender/exporter/SConscript
new file mode 100644
index 0000000..1e478d9
--- /dev/null
+++ b/source/blender/exporter/SConscript
@@ -0,0 +1,16 @@
+#!/usr/bin/python
+
+Import('env')
+
+sources = env.Glob('*.c')
+
+incs  = '../blenlib ../blenkernel ../blenloader'
+incs += ' ../makesdna ../makesrna'
+incs += ' ../windowmanager'
+incs += ' ../../../intern/guardedalloc'
+incs += ' ../../../intern/smoke/extern'
+
+if env['OURPLATFORM'] in ('win32-vc', 'win32-mingw', 'linuxcross', 'win64-vc'):
+	incs += ' ' + env['BF_PTHREADS_INC']
+
+env.BlenderLib('vb_exporter', sources, Split(incs), [], libtype=['core'], priority=[300])
diff --git a/source/blender/exporter/exporter_geometry.c b/source/blender/exporter/exporter_geometry.c
new file mode 100644
index 0000000..e14baa6
--- /dev/null
+++ b/source/blender/exporter/exporter_geometry.c
@@ -0,0 +1,2017 @@
+/*
+
+  V-Ray/Blender
+
+  http://vray.cgdo.ru
+
+  Author: Andrey M. Izrantsev (aka bdancer)
+  E-Mail: izrantsev@cgdo.ru
+
+  This program is free software; you can redistribute it and/or
+  modify it under the terms of the GNU General Public License
+  as published by the Free Software Foundation; either version 2
+  of the License, or (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
+
+*/
+
+#include "exporter_geometry.h"
+
+#include "../vray_for_blender/CGR_config.h"
+
+#define WRITE_HEX_QUADFACE(f, face) fprintf(gfile, "%08X%08X%08X%08X%08X%08X", HEX(face->v1), HEX(face->v2), HEX(face->v3), HEX(face->v3), HEX(face->v4), HEX(face->v1))
+#define WRITE_HEX_TRIFACE(f, face)  fprintf(gfile, "%08X%08X%08X", HEX(face->v1), HEX(face->v2), HEX(face->v3))
+
+#define MAX_MESH_THREADS    16
+#define USE_STRING_POINTER  1
+
+struct Material;
+struct MTex;
+struct Tex;
+
+typedef struct UVLayer {
+    char *name;
+    int   id;
+} UVLayer;
+
+typedef struct ThreadData {
+    Scene    *sce;
+    Main     *bmain;
+    LinkNode *objects;
+    LinkNode *uvs;
+    char     *filepath;
+    int       id;
+    int       animation;
+    int       instances;
+} ThreadData;
+
+static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;
+
+static ThreadData thread_data[MAX_MESH_THREADS];
+
+static int debug = 0;
+
+static char clean_string[MAX_IDPROP_NAME];
+
+
+// http://rosettacode.org/wiki/Determine_if_a_string_is_numeric
+// Used to check if UV layer name consist of digits
+//
+static int is_numeric(const char *s)
+{
+    int res = 0;
+    char *p;
+    if(s == NULL || *s == '\0' || isspace(*s))
+        return 0;
+    res = strtod(s, &p);
+    return *p == '\0';
+}
+
+
+static int uvlayer_name_to_id(LinkNode *list, char *name)
+{
+    LinkNode *list_iter;
+    UVLayer  *uv_layer;
+
+    if(strcmp(name, "") == 0)
+        return 1;
+
+    list_iter= list;
+    while(list_iter) {
+        uv_layer= (UVLayer*)list_iter->link;
+        if(strcmp(name, uv_layer->name) == 0)
+            return uv_layer->id;
+        list_iter= list_iter->next;
+    }
+
+    return 1;
+}
+
+
+static int uvlayer_in_list(LinkNode *list, char *name)
+{
+    LinkNode *list_iter;
+    UVLayer  *uv_layer;
+
+    list_iter= list;
+    while(list_iter) {
+        uv_layer= (UVLayer*)list_iter->link;
+        if(strcmp(name, uv_layer->name) == 0)
+            return 1;
+        list_iter= list_iter->next;
+    }
+    return 0;
+}
+
+
+static int in_list(LinkNode *list, void *item)
+{
+    LinkNode *list_iter;
+
+    if(!list)
+        return 0;
+
+    list_iter= list;
+    while(list_iter) {
+        if(list_iter->link == item)
+            return 1;
+        list_iter= list_iter->next;
+    }
+    return 0;
+}
+
+
+static void *uvlayer_ptr(char *name, int id)
+{
+    UVLayer *tmp;
+    tmp= (UVLayer*)malloc(sizeof(UVLayer));
+    tmp->name= name;
+    tmp->id= id;
+    return (void*)tmp;
+}
+
+
+static void clear_string(char *str)
+{
+    int i;
+
+    strncpy(clean_string, str, MAX_IDPROP_NAME);
+
+    for(i= 0; i < strlen(str); i++) {
+        if(clean_string[i]) {
+            if(clean_string[i] == '+')
+                clean_string[i]= 'p';
+            else if(clean_string[i] == '-')
+                clean_string[i]= 'm';
+            else if(!((clean_string[i] >= 'A' && clean_string[i] <= 'Z') || (clean_string[i] >= 'a' && clean_string[i] <= 'z') || (clean_string[i] >= '0' && clean_string[i] <= '9')))
+                clean_string[i]= '_';
+        }
+    }
+}
+
+
+static int write_edge_visibility(FILE *gfile, int k, unsigned long int *ev)
+{
+    if(k == 9) {
+        WRITE_HEX_VALUE(gfile, *ev);
+        *ev= 0;
+        return 0;
+    }
+    return k + 1;
+}
+
+
+// Spline Interpolation
+//
+//  Code from: http://www.mech.uq.edu.au/staff/jacobs/nm_lib/doc/spline.html
+//
+
+// c_spline_init()
+//
+//   Evaluate the coefficients b[i], c[i], d[i], i = 0, 1, .. n-1 for
+//   a cubic interpolating spline
+//
+//   S(xx) = Y[i] + b[i] * w + c[i] * w**2 + d[i] * w**3
+//   where w = xx - x[i]
+//   and   x[i] <= xx <= x[i+1]
+//
+//   The n supplied data points are x[i], y[i], i = 0 ... n-1.
+//
+//   Input :
+//   -------
+//   n       : The number of data points or knots (n >= 2)
+//   end1,
+//   end2    : = 1 to specify the slopes at the end points
+//             = 0 to obtain the default conditions
+//   slope1,
+//   slope2  : the slopes at the end points x[0] and x[n-1]
+//             respectively
+//   x[]     : the abscissas of the knots in strictly
+//             increasing order
+//   y[]     : the ordinates of the knots
+//
+//   Output :
+//   --------
+//   b, c, d : arrays of spline coefficients as defined above
+//             (See note 2 for a definition.)
+//   iflag   : status flag
+//            = 0 normal return
+//            = 1 less than two data points; cannot interpolate
+//            = 2 x[] are not in ascending order
+//
+//   This C code written by ...  Peter & Nigel,
+//   ----------------------      Design Software,
+//                               42 Gubberley St,
+//                               Kenmore, 4069,
+//                               Australia.
+//
+//   Version ... 1.1, 30 September 1987
+//   -------     2.0, 6 April 1989    (start with zero subscript)
+//                                     remove ndim from parameter list
+//               2.1, 28 April 1989   (check on x[])
+//               2.2, 10 Oct   1989   change number order of matrix
+//
+//   Notes ...
+//   -----
+//   (1) The accompanying function seval() may be used to evaluate the
+//       spline while deriv will provide the first derivative.
+//   (2) Using p to denote differentiation
+//       y[i] = S(X[i])
+//       b[i] = Sp(X[i])
+//       c[i] = Spp(X[i])/2
+//       d[i] = Sppp(X[i])/6  ( Derivative from the right )
+//   (3) Since the zero elements of the arrays ARE NOW used here,
+//       all arrays to be passed from the main program should be
+//       dimensioned at least [n].  These routines will use elements
+//       [0 .. n-1].
+//   (4) Adapted from the text
+//       Forsythe, G.E., Malcolm, M.A. and Moler, C.B. (1977)
+//       "Computer Methods for Mathematical Computations"
+//       Prentice Hall
+//   (5) Note that although there are only n-1 polynomial segments,
+//       n elements are requird in b, c, d.  The elements b[n-1],
+//       c[n-1] and d[n-1] are set to continue the last segment
+//       past x[n-1].
+//
+static int c_spline_init(const int n, const int end1, const int end2, const float slope1, const float slope2,
+                         const float x[], const float y[],
+                         float b[], float c[], float d[], int *iflag)
+{
+    int     nm1, ib, i;
+    float  t;
+    int     ascend;
+
+    nm1    = n - 1;
+    *iflag = 0;
+
+    /* no possible interpolation */
+    if(n < 2) {
+        *iflag = 1;
+        goto LeaveSpline;
+    }
+
+    ascend = 1;
+    for(i = 1; i < n; ++i)
+        if (x[i] <= x[i-1]) ascend = 0;
+
+    if(!ascend) {
+        *iflag = 2;
+        goto LeaveSpline;
+    }
+
+    if(n >= 3)
+    {
+        /* At least quadratic */
+
+        /* Set up the symmetric tri-diagonal system
+           b = diagonal
+           d = offdiagonal
+           c = right-hand-side  */
+        d[0] = x[1] - x[0];
+        c[1] = (y[1] - y[0]) / d[0];
+        for (i = 1; i < nm1; ++i)
+        {
+            d[i]   = x[i+1] - x[i];
+            b[i]   = 2.0 * (d[i-1] + d[i]);
+            c[i+1] = (y[i+1] - y[i]) / d[i];
+            c[i]   = c[i+1] - c[i];
+        }
+
+        /* Default End conditions
+           Third derivatives at x[0] and x[n-1] obtained
+           from divided differences  */
+        b[0]   = -d[0];
+        b[nm1] = -d[n-2];
+        c[0]   = 0.0;
+        c[nm1] = 0.0;
+        if(n != 3) {
+            c[0]   = c[2] / (x[3] - x[1]) - c[1] / (x[2] - x[0]);
+            c[nm1] = c[n-2] / (x[nm1] - x[n-3]) - c[n-3] / (x[n-2] - x[n-4]);
+            c[0]   = c[0] * d[0] * d[0] / (x[3] - x[0]);
+            c[nm1] = -c[nm1] * d[n-2] * d[n-2] / (x[nm1] - x[n-4]);
+        }
+
+        /* Alternative end conditions -- known slopes */
+        if(end1 == 1) {
+            b[0] = 2.0 * (x[1] - x[0]);
+            c[0] = (y[1] - y[0]) / (x[1] - x[0]) - slope1;
+        }
+        if(end2 == 1) {
+            b[nm1] = 2.0 * (x[nm1] - x[n-2]);
+            c[nm1] = slope2 - (y[nm1] - y[n-2]) / (x[nm1] - x[n-2]);
+        }
+
+        /* Forward elimination */
+        for(i = 1; i < n; ++i) {
+            t    = d[i-1] / b[i-1];
+            b[i] = b[i] - t * d[i-1];
+            c[i] = c[i] - t * c[i-1];
+        }
+
+        /* Back substitution */
+        c[nm1] = c[nm1] / b[nm1];
+        for(ib = 0; ib < nm1; ++ib)
+        {
+            i    = n - ib - 2;
+            c[i] = (c[i] - d[i] * c[i+1]) / b[i];
+        }
+
+        /* c[i] is now the sigma[i] of the text */
+
+        /* Compute the polynomial coefficients */
+        b[nm1] = (y[nm1] - y[n-2]) / d[n-2] + d[n-2] * (c[n-2] + 2.0 * c[nm1]);
+        for(i = 0; i < nm1; ++i)
+        {
+            b[i] = (y[i+1] - y[i]) / d[i] - d[i] * (c[i+1] + 2.0 * c[i]);
+            d[i] = (c[i+1] - c[i]) / d[i];
+            c[i] = 3.0 * c[i];
+        }
+        c[nm1] = 3.0 * c[nm1];
+        d[nm1] = d[n-2];
+
+    }
+    else
+    {
+        /* linear segment only  */
+        b[0] = (y[1] - y[0]) / (x[1] - x[0]);
+        c[0] = 0.0;
+        d[0] = 0.0;
+        b[1] = b[0];
+        c[1] = 0.0;
+        d[1] = 0.0;
+    }
+
+LeaveSpline:
+    return 0;
+}
+
+
+// c_spline_eval()
+//
+//  Evaluate the cubic spline function
+//
+//  S(xx) = y[i] + b[i] * w + c[i] * w**2 + d[i] * w**3
+//  where w = u - x[i]
+//  and   x[i] <= u <= x[i+1]
+//  Note that Horner's rule is used.
+//  If u < x[0]   then i = 0 is used.
+//  If u > x[n-1] then i = n-1 is used.
+//
+//  Input :
+//  -------
+//  n       : The number of data points or knots (n >= 2)
+//  u       : the abscissa at which the spline is to be evaluated
+//  Last    : the segment that was last used to evaluate U
+//  x[]     : the abscissas of the knots in strictly increasing order
+//  y[]     : the ordinates of the knots
+//  b, c, d : arrays of spline coefficients computed by spline().
+//
+//  Output :
+//  --------
+//  seval   : the value of the spline function at u
+//  Last    : the segment in which u lies
+//
+//  Notes ...
+//  -----
+//  (1) If u is not in the same interval as the previous call then a
+//      binary search is performed to determine the proper interval.
+//
+static float c_spline_eval(int n, float u, float x[], float y[],
+                            float b[], float c[], float d[], int *last)
+{
+    int    i, j, k;
+    float w;
+
+    i = *last;
+
+    if(i >= n-1) i = 0;
+    if(i < 0)  i = 0;
+
+    /* perform a binary search */
+    if((x[i] > u) || (x[i+1] < u))
+    {
+        i = 0;
+        j = n;
+        do
+        {
+            k = (i + j) / 2;         /* split the domain to search */
+            if (u < x[k])  j = k;    /* move the upper bound */
+            if (u >= x[k]) i = k;    /* move the lower bound */
+        }                            /* there are no more segments to search */
+        while (j > i+1);
+    }
+    *last = i;
+
+    /* Evaluate the spline */
+    w = u - x[i];
+    w = y[i] + w * (b[i] + w * (c[i] + w * d[i]));
+
+    return w;
+}
+
+
+typedef struct ParticleStrandData {
+    float *uvco;
+    int    totuv;
+} ParticleStrandData;
+
+
+static void get_particle_uvco_mcol(short from, DerivedMesh *dm, float *fuv, int num, ParticleStrandData *sd)
+{
+    int i;
+
+    /* get uvco */
+    if (sd->uvco && ELEM(from, PART_FROM_FACE, PART_FROM_VOLUME)) {
+        for (i=0; i<sd->totuv; i++) {
+            if (num != DMCACHE_NOTFOUND) {
+                MFace  *mface  = dm->getTessFaceData(dm, num, CD_MFACE);
+                MTFace *mtface = (MTFace*)CustomData_get_layer_n(&dm->faceData, CD_MTFACE, i);
+                mtface += num;
+
+                psys_interpolate_uvs(mtface, mface->v4, fuv, sd->uvco + 2 * i);
+            }
+            else {
+                sd->uvco[2*i] = 0.0f;
+                sd->uvco[2*i + 1] = 0.0f;
+            }
+        }
+    }
+}
+
+
+static void write_GeomMayaHair(FILE *gfile, Scene *sce, Main *bmain, Object *ob)
+{
+    int    i, c, p, s;
+    float  f;
+    float  t;
+
+    EvaluationContext eval_ctx = {0};
+
+    ParticleSystem             *psys = NULL;
+    ParticleSettings           *pset = NULL;
+    ParticleSystemModifierData *psmd = NULL;
+
+    ParticleData       *pa   = NULL;
+    HairKey            *hkey = NULL;
+    ParticleStrandData  sd;
+
+	ParticleCacheKey **child_cache = NULL;
+	ParticleCacheKey  *child_key   = NULL;
+	ChildParticle     *cpa         = NULL;
+    int                child_total = 0;
+    int                child_steps = 0;
+    float              child_key_co[3];
+
+    float     hairmat[4][4];
+    float     segment[3];
+    float     color[3] = {0.5f,0.5f,0.5f};
+    float     width = 0.001f;
+    float     cone_width = 0.001f;
+    int       num = -1;
+
+    int       spline_init_flag;
+    int       interp_points_count;
+    float     interp_points_step;
+    int       data_points_count;
+    float     data_points_step;
+    float     data_points_ordinates[3][64];
+    float     data_points_abscissas[64];
+
+    float     s_b[3][16];
+    float     s_c[3][16];
+    float     s_d[3][16];
+
+    int       spline_last[3];
+
+    short     use_cone    = 1;
+    short     use_child   = 0;
+    short     free_edit   = 0;
+    short     need_recalc = 0;
+
+    PointerRNA  rna_pset;
+    PointerRNA  VRayParticleSettings;
+    PointerRNA  VRayFur;
+
+    int  display_percentage;
+    int  display_percentage_child;
+
+    eval_ctx.for_render = true;
+
+    for(psys = ob->particlesystem.first; psys; psys = psys->next)
+    {
+        need_recalc = 0;
+
+        pset = psys->part;
+
+        if(pset->type != PART_HAIR) {
+            continue;
+        }
+
+        if(psys->part->ren_as != PART_DRAW_PATH) {
+            continue;
+        }
+
+        psmd = psys_get_modifier(ob, psys);
+        if(!psmd) {
+            continue;
+        }
+        if(!(psmd->modifier.mode & eModifierMode_Render)) {
+            continue;
+        }
+
+        RNA_id_pointer_create(&pset->id, &rna_pset);
+
+        if(RNA_struct_find_property(&rna_pset, "vray")) {
+            VRayParticleSettings= RNA_pointer_get(&rna_pset, "vray");
+
+            if(RNA_struct_find_property(&VRayParticleSettings, "VRayFur")) {
+                VRayFur = RNA_pointer_get(&VRayParticleSettings, "VRayFur");
+
+                // Get hair width
+                width = RNA_float_get(&VRayFur, "width");
+            }
+        }
+
+        child_cache = psys->childcache;
+        child_total = psys->totchildcache;
+        use_child   = (pset->childtype && child_cache);
+
+        // Store "Display percentage" setting
+        display_percentage       = pset->disp;
+        display_percentage_child = pset->child_nbr;
+
+		// Check if particles are edited
+        free_edit = psys_check_edited(psys);
+
+        // Recalc parent hair only if they are not
+        // manually edited
+        if(!free_edit) {
+            need_recalc = 1;
+            pset->disp = 100;
+            psys->recalc |= PSYS_RECALC;
+        }
+
+        if(use_child) {
+            need_recalc = 1;
+            pset->child_nbr = pset->ren_child_nbr;
+            psys->recalc |= PSYS_RECALC_CHILD;
+        }
+
+        if(psys->flag & PSYS_HAIR_DYNAMICS)
+            need_recalc = 0;
+
+        // Recalc hair with render settings
+        if(need_recalc) {
+            ob->recalc |= OB_RECALC_ALL;
+            BKE_scene_update_tagged(&eval_ctx, bmain, sce);
+        }
+
+        // Get new child data pointers
+        if(use_child) {
+            child_cache = psys->childcache;
+            child_total = psys->totchildcache;
+
+            DEBUG_OUTPUT(debug, "child_total = %i", child_total);
+        }
+
+        // Spline interpolation
+        interp_points_count = (int)pow(2.0, pset->ren_step);
+        interp_points_step = 1.0 / (interp_points_count - 1);
+
+        DEBUG_OUTPUT(debug, "interp_points_count = %i", interp_points_count);
+
+        clear_string(psys->name);
+        fprintf(gfile, "GeomMayaHair HAIR%s", clean_string);
+        clear_string(pset->id.name+2);
+        fprintf(gfile, "%s {", clean_string);
+
+
+        fprintf(gfile, "\n\tnum_hair_vertices=interpolate((%d,ListIntHex(\"", sce->r.cfra);
+        if(use_child) {
+            for(p = 0; p < child_total; ++p) {
+                WRITE_HEX_VALUE(gfile, interp_points_count);
+            }
+        }
+        else {
+            LOOP_PARTICLES {
+                WRITE_HEX_VALUE(gfile, interp_points_count);
+            }
+        }
+        fprintf(gfile,"\")));");
+
+
+        fprintf(gfile, "\n\thair_vertices=interpolate((%d,ListVectorHex(\"", sce->r.cfra);
+        if(use_child) {
+            for(p = 0; p < child_total; ++p) {
+                child_key   = child_cache[p];
+                child_steps = child_key->steps;
+
+                // Spline interpolation
+                data_points_count = child_steps;
+                data_points_step  = 1.0f / (child_steps - 1);
+
+                // Store control points
+                for(s = 0, f = 0.0f; s < child_steps; ++s, ++child_key, f += data_points_step) {
+                    data_points_abscissas[s] = f;
+
+                    // Child particles are stored in world space,
+                    // but we need them in object space
+                    copy_v3_v3(child_key_co, child_key->co);
+
+                    // Remove transform by applying inverse matrix
+                    mul_m4_v3(ob->imat, child_key_co);
+
+                    for(c = 0; c < 3; ++c) {
+                        data_points_ordinates[c][s] = child_key_co[c];
+                    }
+                }
+
+                // Init spline coefficients
+                for(c = 0; c < 3; ++c) {
+                    c_spline_init(data_points_count, 0, 0, 0.0f, 0.0f,
+                                  data_points_abscissas, data_points_ordinates[c],
+                                  s_b[c], s_c[c], s_d[c], &spline_init_flag);
+                }
+
+                // Write interpolated child points
+                for(c = 0; c < 3; ++c)
+                    spline_last[c] = 0;
+
+                for(t = 0.0f; t <= 1.0; t += interp_points_step) {
+                    // Calculate interpolated coordinate
+                    for(c = 0; c < 3; ++c) {
+                        segment[c] = c_spline_eval(data_points_count, t, data_points_abscissas, data_points_ordinates[c],
+                                                   s_b[c], s_c[c], s_d[c], &spline_last[c]);
+                    }
+
+                    WRITE_HEX_VECTOR(gfile, segment);
+                }
+            }
+        }
+        else {
+            LOOP_PARTICLES {
+                DEBUG_OUTPUT(debug, "\033[0;32mV-Ray/Blender:\033[0m Particle system: %s => Hair: %i\n", psys->name, p + 1);
+
+                psys_mat_hair_to_object(NULL, psmd->dm, psmd->psys->part->from, pa, hairmat);
+
+                // Spline interpolation
+                data_points_count = pa->totkey;
+                data_points_step  = 1.0f / (data_points_count - 1);
+
+                DEBUG_OUTPUT(debug, "data_points_count = %i", data_points_count);
+                DEBUG_OUTPUT(debug, "data_points_step = %.3f", data_points_step);
+
+                for(i = 0, f = 0.0f; i < data_points_count; ++i, f += data_points_step) {
+                    data_points_abscissas[i] = f;
+                }
+
+                // Store control points
+                for(s = 0, hkey = pa->hair; s < pa->totkey; ++s, ++hkey) {
+                    copy_v3_v3(segment, hkey->co);
+                    mul_m4_v3(hairmat, segment);
+
+                    for(c = 0; c < 3; ++c) {
+                        data_points_ordinates[c][s] = segment[c];
+                    }
+                }
+
+                // Init spline coefficients
+                for(c = 0; c < 3; ++c) {
+                    c_spline_init(data_points_count, 0, 0, 0.0f, 0.0f,
+                                  data_points_abscissas, data_points_ordinates[c],
+                                  s_b[c], s_c[c], s_d[c], &spline_init_flag);
+                }
+
+                // Write interpolated points
+                for(c = 0; c < 3; ++c)
+                    spline_last[c] = 0;
+                for(t = 0.0f; t <= 1.0; t += interp_points_step) {
+                    // Calculate interpolated coordinates
+                    for(c = 0; c < 3; ++c) {
+                        segment[c] = c_spline_eval(data_points_count, t, data_points_abscissas, data_points_ordinates[c],
+                                                   s_b[c], s_c[c], s_d[c], &spline_last[c]);
+                    }
+                    WRITE_HEX_VECTOR(gfile, segment);
+                }
+            }
+        }
+        fprintf(gfile,"\")));");
+
+        memset(&sd, 0, sizeof(ParticleStrandData));
+
+        // DEBUG_OUTPUT(TRUE, "psmd->dm = 0x%X", psmd->dm);
+
+		if(psmd->dm) {
+			if(use_child) {
+				sd.totuv = CustomData_number_of_layers(&psmd->dm->faceData, CD_MTFACE);
+
+				if(sd.totuv) {
+					sd.uvco = MEM_callocN(sd.totuv * 2 * sizeof(float), "particle_uvs");
+				}
+				else {
+					sd.uvco = NULL;
+				}
+
+				if(sd.uvco) {
+					fprintf(gfile, "\n\tstrand_uvw=interpolate((%d,ListVectorHex(\"", sce->r.cfra);
+
+					for(p = 0; p < child_total; ++p) {
+						cpa = psys->child + p;
+
+						/* get uvco & mcol */
+						if(pset->childtype==PART_CHILD_FACES) {
+							get_particle_uvco_mcol(PART_FROM_FACE, psmd->dm, cpa->fuv, cpa->num, &sd);
+						}
+						else {
+							ParticleData *parent = psys->particles + cpa->parent;
+							num = parent->num_dmcache;
+
+							if (num == DMCACHE_NOTFOUND)
+								if (parent->num < psmd->dm->getNumTessFaces(psmd->dm))
+									num = parent->num;
+
+							get_particle_uvco_mcol(pset->from, psmd->dm, parent->fuv, num, &sd);
+						}
+
+						segment[0] = sd.uvco[0];
+						segment[1] = sd.uvco[1];
+						segment[2] = 0.0f;
+
+						WRITE_HEX_VECTOR(gfile, segment);
+					}
+					fprintf(gfile,"\")));");
+
+					MEM_freeN(sd.uvco);
+				}
+			}
+			else {
+				sd.totuv = CustomData_number_of_layers(&psmd->dm->faceData, CD_MTFACE);
+
+				if(sd.totuv) {
+					sd.uvco = MEM_callocN(sd.totuv * 2 * sizeof(float), "particle_uvs");
+				}
+				else {
+					sd.uvco = NULL;
+				}
+
+				if(sd.uvco) {
+					fprintf(gfile, "\n\tstrand_uvw=interpolate((%d,ListVectorHex(\"", sce->r.cfra);
+					LOOP_PARTICLES {
+						/* get uvco & mcol */
+						num = pa->num_dmcache;
+
+						if(num == DMCACHE_NOTFOUND) {
+							if(pa->num < psmd->dm->getNumTessFaces(psmd->dm)) {
+								num = pa->num;
+							}
+						}
+
+						get_particle_uvco_mcol(pset->from, psmd->dm, pa->fuv, num, &sd);
+
+						// DEBUG_OUTPUT(TRUE, "Pa.uv = %.3f, %.3f", sd.uvco[0], sd.uvco[1]);
+
+						segment[0] = sd.uvco[0];
+						segment[1] = sd.uvco[1];
+						segment[2] = 0.0f;
+
+						WRITE_HEX_VECTOR(gfile, segment);
+					}
+					fprintf(gfile,"\")));");
+
+					MEM_freeN(sd.uvco);
+				}
+			}
+        }
+
+        fprintf(gfile, "\n\twidths=interpolate((%d,ListFloatHex(\"", sce->r.cfra);
+        if(use_child) {
+            for(p = 0; p < child_total; ++p) {
+                cone_width = width;
+                for(s = 0; s < interp_points_count; ++s) {
+                    if(use_cone && s > 0) {
+                        cone_width = width / s;
+                    }
+                    WRITE_HEX_VALUE(gfile, cone_width);
+                }
+            }
+        }
+        else {
+            for(p = 0; p < psys->totpart; ++p) {
+                for(s = 0; s < interp_points_count; ++s) {
+                    cone_width = width;
+                    if(use_cone && s > 0) {
+                        cone_width = width / s;
+                    }
+                    WRITE_HEX_VALUE(gfile, cone_width);
+                }
+            }
+        }
+        fprintf(gfile,"\")));");
+
+
+        fprintf(gfile, "\n\tcolors=interpolate((%d,ListColorHex(\"", sce->r.cfra);
+        if(use_child) {
+            for(p = 0; p < child_total; ++p) {
+                for(s = 0; s < interp_points_count; ++s) {
+                    WRITE_HEX_VECTOR(gfile, color);
+                }
+            }
+        }
+        else {
+            for(p = 0; p < psys->totpart; ++p) {
+                for(s = 0; s < interp_points_count; ++s) {
+                    WRITE_HEX_VECTOR(gfile, color);
+                }
+            }
+        }
+        fprintf(gfile,"\")));");
+
+
+        fprintf(gfile, "\n\topacity=1.0;");
+        if(psys->part->flag & PART_HAIR_BSPLINE) {
+            fprintf(gfile, "\n\tgeom_splines=1;");
+        }
+        fprintf(gfile, "\n}\n\n");
+
+
+        // Restore "Display percentage" setting
+        pset->disp      = display_percentage;
+        pset->child_nbr = display_percentage_child;
+
+        if(!free_edit) {
+            psys->recalc |= PSYS_RECALC;
+        }
+        if(use_child) {
+            psys->recalc |= PSYS_RECALC_CHILD;
+        }
+
+        // Recalc hair back with viewport settings
+        if(need_recalc) {
+            ob->recalc |= OB_RECALC_ALL;
+            BKE_scene_update_tagged(&eval_ctx, bmain, sce);
+        }
+    }
+}
+
+
+// Taken from: source/blender/makesrna/intern/rna_object_api.c
+// with a slight modifications
+//
+static Mesh *get_render_mesh(Scene *sce, Main *bmain, Object *ob)
+{
+    Mesh *tmpmesh;
+    Curve *tmpcu = NULL, *copycu;
+    Object *tmpobj = NULL;
+    Object *basis_ob = NULL;
+    ListBase disp = {NULL, NULL};
+    EvaluationContext eval_ctx = {0};
+
+    /* Make a dummy mesh, saves copying */
+    DerivedMesh *dm;
+
+    CustomDataMask mask = CD_MASK_MESH;
+
+    eval_ctx.for_render = true;
+
+    /* perform the mesh extraction based on type */
+    switch (ob->type) {
+    case OB_FONT:
+    case OB_CURVE:
+    case OB_SURF:
+        /* copies object and modifiers (but not the data) */
+        tmpobj = BKE_object_copy(ob);
+        tmpcu = (Curve *)tmpobj->data;
+        tmpcu->id.us--;
+
+        /* copies the data */
+        copycu = tmpobj->data = BKE_curve_copy( (Curve *) ob->data );
+
+        /* temporarily set edit so we get updates from edit mode, but
+         * also because for text datablocks copying it while in edit
+         * mode gives invalid data structures */
+        copycu->editfont = tmpcu->editfont;
+        copycu->editnurb = tmpcu->editnurb;
+
+        /* get updated display list, and convert to a mesh */
+        BKE_displist_make_curveTypes( sce, tmpobj, 0 );
+
+        copycu->editfont = NULL;
+        copycu->editnurb = NULL;
+
+        BKE_mesh_from_nurbs( tmpobj );
+
+        /* nurbs_to_mesh changes the type to a mesh, check it worked */
+        if (tmpobj->type != OB_MESH) {
+			BKE_libblock_free_us(G.main, tmpobj);
+            return NULL;
+        }
+        tmpmesh = tmpobj->data;
+		BKE_libblock_free_us(G.main, tmpobj);
+
+        break;
+
+    case OB_MBALL:
+        /* metaballs don't have modifiers, so just convert to mesh */
+        basis_ob = BKE_mball_basis_find(sce, ob);
+
+        if (ob != basis_ob)
+            return NULL; /* only do basis metaball */
+
+        tmpmesh = BKE_mesh_add(bmain, "Mesh");
+
+        BKE_displist_make_mball_forRender(&eval_ctx, sce, ob, &disp);
+        BKE_mesh_from_metaball(&disp, tmpmesh);
+        BKE_displist_free(&disp);
+
+        break;
+
+    case OB_MESH:
+        /* Write the render mesh into the dummy mesh */
+        dm = mesh_create_derived_render(sce, ob, mask);
+
+        tmpmesh = BKE_mesh_add(bmain, "Mesh");
+        DM_to_mesh(dm, tmpmesh, ob, mask);
+        dm->release(dm);
+
+        break;
+
+    default:
+        return NULL;
+    }
+
+    /* cycles and exporters rely on this still */
+    BKE_mesh_tessface_ensure(tmpmesh);
+
+    /* we don't assign it to anything */
+    tmpmesh->id.us--;
+
+    return tmpmesh;
+}
+
+
+static void write_GeomStaticMesh(FILE *gfile,
+                                 Scene *sce, Object *ob, Mesh *mesh,
+                                 LinkNode *uv_list, int instances)
+{
+    Mesh   *me = ob->data;
+    MFace  *face;
+    MTFace *mtface;
+    MCol   *mcol;
+    MVert  *vert;
+
+    CustomData *fdata;
+
+    int    verts;
+    int    fve[4];
+    float *ve[4];
+    float  no[3];
+    float  col[3];
+
+    float  fno[3];
+    float  n0[3], n1[3], n2[3], n3[3];
+
+    int    matid       = 0;
+    int    uv_count    = 0;
+    int    uv_layer_id = 1;
+
+    char  *lib_filename = NULL;
+
+    PointerRNA   rna_me;
+    PointerRNA   VRayMesh;
+    PointerRNA   GeomStaticMesh;
+
+    int          dynamic_geometry= 0;
+
+    const int ft[6]= {0,1,2,2,3,0};
+
+    unsigned long int ev= 0;
+
+    int i, j, f, k, l;
+    int u;
+
+    DEBUG_OUTPUT(debug, "Processing object \"%s\": mesh \"%s\"", ob->id.name, me->id.name);
+
+    if(!(mesh->totface)) {
+        DEBUG_OUTPUT(debug, "No faces in mesh \"%s\"", me->id.name);
+        return;
+    }
+
+    // Name format: ME<meshname>LI<libname>
+    //
+    if(instances)
+        clear_string(me->id.name+2);
+    else
+        clear_string(ob->id.name+2);
+    fprintf(gfile,"\nGeomStaticMesh ME%s", clean_string);
+
+    if(me->id.lib) {
+        lib_filename = (char*)malloc(FILE_MAX * sizeof(char));
+
+        BLI_split_file_part(me->id.lib->name+2, lib_filename, FILE_MAX);
+        BLI_replace_extension(lib_filename, FILE_MAX, "");
+
+        clear_string(lib_filename);
+        fprintf(gfile,"LI%s", clean_string);
+        if(debug) {
+            printf("V-Ray/Blender: Object: %s\n", ob->id.name+2);
+            printf("  Mesh: %s\n", me->id.name+2);
+            printf("    Lib filename: %s\n", lib_filename);
+        }
+
+        free(lib_filename);
+    }
+    fprintf(gfile," {\n");
+
+
+	fprintf(gfile,"\tvertices=interpolate((%d,ListVectorHex(\"", sce->r.cfra);
+    vert= mesh->mvert;
+    for(f= 0; f < mesh->totvert; ++vert, ++f) {
+        WRITE_HEX_VECTOR(gfile, vert->co);
+    }
+    fprintf(gfile,"\")));\n");
+
+    // TODO: velocities (?)
+
+	fprintf(gfile,"\tfaces=interpolate((%d,ListIntHex(\"", sce->r.cfra);
+    face= mesh->mface;
+    for(f= 0; f < mesh->totface; ++face, ++f) {
+        if(face->v4)
+            WRITE_HEX_QUADFACE(gfile, face);
+        else
+            WRITE_HEX_TRIFACE(gfile, face);
+
+    }
+    fprintf(gfile,"\")));\n");
+
+
+	fprintf(gfile,"\tnormals=interpolate((%d,ListVectorHex(\"", sce->r.cfra);
+    face = mesh->mface;
+    for(f = 0; f < mesh->totface; ++face, ++f) {
+        if(face->flag & ME_SMOOTH) {
+            normal_short_to_float_v3(n0, mesh->mvert[face->v1].no);
+            normal_short_to_float_v3(n1, mesh->mvert[face->v2].no);
+            normal_short_to_float_v3(n2, mesh->mvert[face->v3].no);
+
+            if(face->v4)
+                normal_short_to_float_v3(n3, mesh->mvert[face->v4].no);
+        }
+        else {
+            if(face->v4)
+                normal_quad_v3(fno, mesh->mvert[face->v1].co, mesh->mvert[face->v2].co, mesh->mvert[face->v3].co, mesh->mvert[face->v4].co);
+            else
+                normal_tri_v3(fno,  mesh->mvert[face->v1].co, mesh->mvert[face->v2].co, mesh->mvert[face->v3].co);
+
+            copy_v3_v3(n0, fno);
+            copy_v3_v3(n1, fno);
+            copy_v3_v3(n2, fno);
+
+            if(face->v4)
+                copy_v3_v3(n3, fno);
+        }
+
+        if(face->v4) {
+            WRITE_HEX_VECTOR(gfile, n0);
+            WRITE_HEX_VECTOR(gfile, n1);
+            WRITE_HEX_VECTOR(gfile, n2);
+            WRITE_HEX_VECTOR(gfile, n2);
+            WRITE_HEX_VECTOR(gfile, n3);
+            WRITE_HEX_VECTOR(gfile, n0);
+        } else {
+            WRITE_HEX_VECTOR(gfile, n0);
+            WRITE_HEX_VECTOR(gfile, n1);
+            WRITE_HEX_VECTOR(gfile, n2);
+        }
+    }
+    fprintf(gfile,"\")));\n");
+
+
+	fprintf(gfile,"\tfaceNormals=interpolate((%d,ListIntHex(\"", sce->r.cfra);
+    face= mesh->mface;
+    k= 0;
+    for(f= 0; f < mesh->totface; ++face, ++f) {
+        if(mesh->mface[f].v4)
+            verts= 6;
+        else
+            verts= 3;
+
+        for(i= 0; i < verts; i++) {
+            fprintf(gfile, "%08X", htonl(*(int*)&k));
+            k++;
+        }
+    }
+    fprintf(gfile,"\")));\n");
+
+
+    fprintf(gfile,"\tface_mtlIDs=ListIntHex(\"");
+    face= mesh->mface;
+    for(f= 0; f < mesh->totface; ++face, ++f) {
+        matid= face->mat_nr + 1;
+        if(face->v4)
+            fprintf(gfile, "%08X%08X", htonl(*(int*)&matid), htonl(*(int*)&matid));
+        else
+            fprintf(gfile, "%08X", htonl(*(int*)&matid));
+    }
+    fprintf(gfile,"\");\n");
+
+
+    fprintf(gfile,"\tedge_visibility=ListIntHex(\"");
+    ev= 0;
+    if(mesh->totface <= 5) {
+        face= mesh->mface;
+        for(f= 0; f < mesh->totface; ++face, ++f) {
+            if(face->v4) {
+                ev= (ev << 6) | 27;
+            } else {
+                ev= (ev << 3) | 8;
+            }
+        }
+        fprintf(gfile, "%08X", htonl(*(int*)&ev));
+    } else {
+        k= 0;
+        face= mesh->mface;
+        for(f= 0; f < mesh->totface; ++face, ++f) {
+            if(face->v4) {
+                ev= (ev << 3) | 3;
+                k= write_edge_visibility(gfile, k, &ev);
+                ev= (ev << 3) | 3;
+                k= write_edge_visibility(gfile, k, &ev);
+            } else {
+                ev= (ev << 3) | 8;
+                k= write_edge_visibility(gfile, k, &ev);
+            }
+        }
+
+        if(k) {
+            fprintf(gfile, "%08X", htonl(*(int*)&ev));
+        }
+    }
+    fprintf(gfile,"\");\n");
+
+
+    fdata = &mesh->fdata;
+
+    uv_count  = CustomData_number_of_layers(fdata, CD_MTFACE);
+    uv_count += CustomData_number_of_layers(fdata, CD_MCOL);
+
+    if(uv_count) {
+        fprintf(gfile,"\tmap_channels_names=List(");
+        for(l = 0; l < fdata->totlayer; ++l) {
+            if(fdata->layers[l].type == CD_MTFACE || fdata->layers[l].type == CD_MCOL) {
+                fprintf(gfile,"\"%s\"", fdata->layers[l].name);
+
+                if(l < uv_count)
+                    fprintf(gfile,",");
+            }
+        }
+        fprintf(gfile,");\n");
+
+        uv_layer_id = 0;
+        fprintf(gfile,"\tmap_channels=interpolate((%d, List(", sce->r.cfra);
+        for(l = 0; l < fdata->totlayer; ++l) {
+            if(fdata->layers[l].type == CD_MTFACE || fdata->layers[l].type == CD_MCOL) {
+                fprintf(gfile,"\n\t\t// Name: %s", fdata->layers[l].name);
+                fprintf(gfile,"\n\t\tList(%i,ListVectorHex(\"", uv_layer_id++);
+
+                if(fdata->layers[l].type == CD_MTFACE) {
+                    face   = mesh->mface;
+                    mtface = (MTFace*)fdata->layers[l].data;
+                    for(f = 0; f < mesh->totface; ++face, ++f) {
+                        if(face->v4)
+                            verts = 4;
+                        else
+                            verts = 3;
+                        for(i = 0; i < verts; i++) {
+                            fprintf(gfile, "%08X%08X00000000",
+                                    htonl(*(int*)&(mtface[f].uv[i][0])),
+                                    htonl(*(int*)&(mtface[f].uv[i][1])));
+                        }
+                    }
+                }
+                else {
+                    face = mesh->mface;
+                    mcol = (MCol*)fdata->layers[l].data;
+                    for(f = 0; f < mesh->totface; ++face, ++f) {
+                        if(face->v4)
+                            verts = 4;
+                        else
+                            verts = 3;
+                        for(i = 0; i < verts; i++) {
+                            col[0] = (float)mcol[f * 4 + i].b / 255.0;
+                            col[1] = (float)mcol[f * 4 + i].g / 255.0;
+                            col[2] = (float)mcol[f * 4 + i].r / 255.0;
+
+                            WRITE_HEX_VECTOR(gfile, col);
+                        }
+                    }
+                }
+
+                fprintf(gfile,"\"),");
+
+                fprintf(gfile,"ListIntHex(\"");
+                u = 0;
+                face = mesh->mface;
+                for(f = 0; f < mesh->totface; ++face, ++f) {
+                    if(face->v4) {
+                        fprintf(gfile, "%08X", htonl(*(int*)&u));
+                        k = u+1;
+                        fprintf(gfile, "%08X", htonl(*(int*)&k));
+                        k = u+2;
+                        fprintf(gfile, "%08X", htonl(*(int*)&k));
+                        fprintf(gfile, "%08X", htonl(*(int*)&k));
+                        k = u+3;
+                        fprintf(gfile, "%08X", htonl(*(int*)&k));
+                        fprintf(gfile, "%08X", htonl(*(int*)&u));
+                        u += 4;
+                    } else {
+                        fprintf(gfile, "%08X", htonl(*(int*)&u));
+                        k = u+1;
+                        fprintf(gfile, "%08X", htonl(*(int*)&k));
+                        k = u+2;
+                        fprintf(gfile, "%08X", htonl(*(int*)&k));
+                        u += 3;
+                    }
+                }
+                fprintf(gfile,"\"))");
+
+                if(l < uv_count)
+                    fprintf(gfile,",");
+            }
+        }
+        fprintf(gfile,")));\n");
+    }
+
+    RNA_id_pointer_create(&me->id, &rna_me);
+    if(RNA_struct_find_property(&rna_me, "vray")) {
+        VRayMesh = RNA_pointer_get(&rna_me, "vray");
+        if(RNA_struct_find_property(&VRayMesh, "GeomStaticMesh")) {
+            GeomStaticMesh = RNA_pointer_get(&VRayMesh, "GeomStaticMesh");
+            if(RNA_struct_find_property(&GeomStaticMesh, "dynamic_geometry")) {
+                dynamic_geometry = RNA_boolean_get(&GeomStaticMesh, "dynamic_geometry");
+            }
+        }
+    }
+
+    // When this flag is true V-Ray will use dynamic geometry for this mesh.
+    // Instead of copying the mesh many times in the BSP tree, only the bounding
+    // box will be present many times and ray intersections will occur
+    // in a separate object space BSP tree.
+	fprintf(gfile,"\tdynamic_geometry=%i;\n", dynamic_geometry);
+
+    fprintf(gfile,"}\n\n");
+}
+
+
+static void write_TexVoxelData(FILE *gfile, const Scene *sce, Object *ob, const SmokeModifierData *smd, short use_smoke_hires)
+{
+    VoxelData *vd   = NULL;
+    Material  *ma   = NULL;
+    MTex      *mtex = NULL;
+    Tex       *tex  = NULL;
+
+    size_t i, m, t;
+    size_t tot_res_high;
+    size_t tot_res_low;
+
+    float *density_data = NULL;
+    float *heat_data    = NULL;
+    float  density;
+    float  heat;
+
+    int    res_high[3];
+    int    res_low[3];
+
+    float  ob_imat[4][4];
+
+    int    interp_type    = 0;
+    float  int_multiplier = 1.0;
+
+    char   uvwgen_name[255];
+    char   tex_name[255];
+
+    if(!(smd->domain && smd->domain->fluid)) {
+        DEBUG_OUTPUT(TRUE, "Smoke modifier not found!");
+        return;
+    }
+
+    // Take VoxelData pointer from texture
+    //
+    if(ob->mat) {
+        for(m = 1; m <= ob->totcol; ++m) {
+            ma = give_current_material(ob, m);
+            if(!(ma))
+                continue;
+
+            for(t = 0; t < MAX_MTEX; ++t) {
+                mtex = ma->mtex[t];
+                if(!(mtex))
+                    continue;
+
+                tex = mtex->tex;
+                if(!(tex))
+                    continue;
+
+                if(tex->type != TEX_VOXELDATA)
+                    continue;
+
+                vd = tex->vd;
+
+                break;
+            }
+
+            if(vd)
+                break;
+        }
+    }
+
+    if(!(vd)) {
+        DEBUG_OUTPUT(TRUE, "VoxelData texture not found!");
+        return;
+    }
+
+    interp_type    = vd->interp_type;
+    int_multiplier = vd->int_multiplier;
+
+    clear_string(tex->id.name+2);
+    sprintf(tex_name, "TE%s", clean_string);
+    sprintf(uvwgen_name, "UVWGenWorldTE%s", clean_string);
+
+    // Store object invert matrix
+    invert_m4_m4(ob_imat, ob->obmat);
+
+    if(use_smoke_hires && (smd->domain->flags & MOD_SMOKE_HIGHRES)) {
+        COPY_VECTOR_3_3(res_low,  smd->domain->res);
+        COPY_VECTOR_3_3(res_high, smd->domain->res_wt);
+
+        density_data = smoke_turbulence_get_density(smd->domain->wt);
+    }
+    else {
+        COPY_VECTOR_3_3(res_low,  smd->domain->res);
+        COPY_VECTOR_3_3(res_high, smd->domain->res);
+
+        density_data = smoke_get_density(smd->domain->fluid);
+    }
+
+    heat_data = smoke_get_heat(smd->domain->fluid);
+
+    tot_res_high = (size_t)res_high[0] * (size_t)res_high[1] * (size_t)res_high[2];
+    tot_res_low  = (size_t)res_low[0]  * (size_t)res_low[1]  * (size_t)res_low[2];
+
+    fprintf(gfile, "\nUVWGenPlanarWorld %s {", uvwgen_name);
+
+    // Blender smoke uses 2.0 x 2.0 x 2.0 mesh domain and then transform to form the final
+    // smoke domain, so we need to transform UVWs
+    fprintf(gfile, "\n\tuvw_transform = interpolate((%d,", sce->r.cfra);
+    WRITE_TRANSFORM(gfile, ob_imat);
+    fprintf(gfile, "));");
+
+    fprintf(gfile, "\n}\n");
+
+    fprintf(gfile, "\nTexVoxelData %s {", tex_name);
+    fprintf(gfile, "\n\tuvwgen = %s;", uvwgen_name);
+    fprintf(gfile, "\n\tdebug = %i;", debug);
+    fprintf(gfile, "\n\tinterpolation = %i;", interp_type);
+    fprintf(gfile, "\n\tresolution = Vector(%i,%i,%i);", res_high[0], res_high[1], res_high[2]);
+    fprintf(gfile, "\n\tresolution_low = Vector(%i,%i,%i);", res_low[0], res_low[1], res_low[2]);
+
+    // Density
+    //
+    fprintf(gfile, "\n\tdensity = interpolate((%d, ListFloatHex(\"", sce->r.cfra);
+    for(i = 0; i < tot_res_high; ++i) {
+        density = density_data[i];
+
+        WRITE_HEX_VALUE(gfile, density);
+    }
+    fprintf(gfile, "\")));");
+
+    // Heat
+    //  Always low res
+    //
+    fprintf(gfile, "\n\theat = interpolate((%d, ListFloatHex(\"", sce->r.cfra);
+    for(i = 0; i < tot_res_low; ++i) {
+        heat  = (heat_data[i]+2.0f)/4.0f;
+        heat *= int_multiplier;
+
+        WRITE_HEX_VALUE(gfile, heat);
+    }
+    fprintf(gfile, "\")));");
+
+    fprintf(gfile, "\n}\n");
+}
+
+
+static int mesh_animated(Object *ob)
+{
+    ModifierData *mod;
+
+    switch(ob->type) {
+    case OB_CURVE:
+    case OB_SURF:
+    case OB_FONT: {
+        Curve *cu= (Curve*)ob->data;
+        if(cu->adt)
+            return 1;
+    }
+    break;
+    case OB_MBALL: {
+        MetaBall *mb= (MetaBall*)ob->data;
+        if(mb->adt)
+            return 1;
+    }
+    break;
+    case OB_MESH: {
+        Mesh *me= (Mesh*)ob->data;
+        if(me->adt)
+            return 1;
+    }
+    break;
+    default:
+        break;
+    }
+
+    mod= (ModifierData*)ob->modifiers.first;
+    while(mod) {
+        switch (mod->type) {
+        case eModifierType_Armature:
+        case eModifierType_Array:
+        case eModifierType_Displace:
+        case eModifierType_Softbody:
+        case eModifierType_Explode:
+        case eModifierType_MeshDeform:
+        case eModifierType_SimpleDeform:
+        case eModifierType_ShapeKey:
+        case eModifierType_Screw:
+        case eModifierType_Warp:
+            return 1;
+        default:
+            mod= mod->next;
+        }
+    }
+
+    return 0;
+}
+
+
+static void *export_meshes_thread(void *ptr)
+{
+    struct ThreadData *td;
+
+    double    time = 0.0;
+    char      time_str[32];
+
+    FILE     *gfile= NULL;
+    char      filepath[FILE_MAX];
+
+    Scene    *sce;
+    Main     *bmain;
+    Object   *ob;
+    Mesh     *mesh;
+
+    LinkNode *tdl;
+
+    short     use_hair  = 1;
+    short     use_smoke = 1;
+    short     use_smoke_hires = 1;
+
+    PointerRNA rna_scene;
+    PointerRNA VRayScene;
+    PointerRNA VRayExporter;
+
+    ModifierData      *md;
+    SmokeModifierData *smd;
+
+    td= (struct ThreadData*)ptr;
+
+    sce=   td->sce;
+    bmain= td->bmain;
+
+    // Get export parameters from RNA
+    RNA_id_pointer_create(&sce->id, &rna_scene);
+    if(RNA_struct_find_property(&rna_scene, "vray")) {
+        VRayScene= RNA_pointer_get(&rna_scene, "vray");
+
+        if(RNA_struct_find_property(&VRayScene, "exporter")) {
+            VRayExporter= RNA_pointer_get(&VRayScene, "exporter");
+
+            use_hair = RNA_boolean_get(&VRayExporter, "use_hair");
+            use_smoke       = RNA_boolean_get(&VRayExporter, "use_smoke");
+            use_smoke_hires = RNA_boolean_get(&VRayExporter, "use_smoke_hires");
+        }
+    }
+
+    if(debug) {
+        time= PIL_check_seconds_timer();
+        PRINT_INFO("Mesh export thread [%d]\n", td->id + 1);
+    }
+    sprintf(filepath, "%s_%.2d.vrscene", td->filepath, td->id);
+    if(td->animation) {
+        gfile = fopen(filepath, "a");
+    } else {
+        gfile = fopen(filepath, "w");
+        fprintf(gfile,"// V-Ray/Blender\n");
+        fprintf(gfile,"// Geometry file\n\n");
+    }
+
+    if(BLI_linklist_length(td->objects)) {
+        tdl = td->objects;
+        while(tdl) {
+            ob = tdl->link;
+
+            if(use_hair) {
+                pthread_mutex_lock(&mtx);
+
+                write_GeomMayaHair(gfile, sce, bmain, ob);
+
+                pthread_mutex_unlock(&mtx);
+            }
+
+            if(use_smoke) {
+                pthread_mutex_lock(&mtx);
+
+                if((md = modifiers_findByType(ob, eModifierType_Smoke))) {
+                    smd = (SmokeModifierData*)md;
+
+                    write_TexVoxelData(gfile, sce, ob, smd, use_smoke_hires);
+                }
+
+                pthread_mutex_unlock(&mtx);
+            }
+
+            // Export mesh
+            pthread_mutex_lock(&mtx);
+
+            mesh = get_render_mesh(sce, bmain, ob);
+
+            pthread_mutex_unlock(&mtx);
+
+            if(mesh) {
+                write_GeomStaticMesh(gfile, sce, ob, mesh, td->uvs, td->instances);
+
+                pthread_mutex_lock(&mtx);
+
+                /* remove the temporary mesh */
+                BKE_mesh_free(mesh, TRUE);
+                BLI_remlink(&bmain->mesh, mesh);
+                MEM_freeN(mesh);
+
+                pthread_mutex_unlock(&mtx);
+            }
+
+            tdl = tdl->next;
+        }
+    }
+
+    fclose(gfile);
+
+    if(debug) {
+        BLI_timestr(PIL_check_seconds_timer() - time, time_str, sizeof(time_str));
+        PRINT_INFO("Mesh export thread [%d] done [%s]\n", td->id + 1, time_str);
+    }
+
+    return NULL;
+}
+
+
+static void append_object(Scene *sce, LinkNode **objects, LinkNode **meshes, Object *ob,
+                          int active_layers, int instances, int check_animated, int animation)
+{
+    GroupObject *gobject;
+    Object      *gob;
+
+    Mesh        *me;
+
+    PointerRNA   rna_me;
+    PointerRNA   VRayMesh;
+
+    if(ob->dup_group) {
+        gobject= (GroupObject*)ob->dup_group->gobject.first;
+        while(gobject) {
+            gob= gobject->ob;
+
+            if(!in_list(*objects, (void*)gob)) {
+                if(debug) {
+                    printf("Group object: %s\n", gob->id.name);
+                }
+                append_object(sce, objects, meshes, gob,
+                              active_layers, instances, check_animated, animation);
+            }
+
+            gobject= gobject->next;
+        }
+    }
+
+    if(!ob->data)
+        return;
+
+    // TODO: geom_doHidden
+    if(ob->restrictflag & OB_RESTRICT_RENDER)
+        return;
+
+    if(ob->type == OB_EMPTY   ||
+       ob->type == OB_LAMP    ||
+       ob->type == OB_CAMERA  ||
+       ob->type == OB_LATTICE ||
+       ob->type == OB_ARMATURE)
+        return;
+
+    if(active_layers)
+        if(!(ob->lay & sce->lay))
+            return;
+
+    if(instances)
+        if(in_list(*meshes, ob->data))
+            return;
+
+    if(ob->type == OB_MESH) {
+        me= (Mesh*)ob->data;
+        RNA_id_pointer_create(&me->id, &rna_me);
+        if(RNA_struct_find_property(&rna_me, "vray")) {
+            VRayMesh= RNA_pointer_get(&rna_me, "vray");
+            if(RNA_struct_find_property(&VRayMesh, "override")) {
+                if(RNA_boolean_get(&VRayMesh, "override"))
+                    return;
+            }
+        }
+    }
+
+    if(animation)
+        if(check_animated)
+            if(!mesh_animated(ob))
+                return;
+
+    if(instances)
+        BLI_linklist_prepend(meshes, ob->data);
+
+    BLI_linklist_prepend(objects, ob);
+}
+
+
+static void export_meshes_threaded(char *filepath, Scene *sce, Main *bmain,
+                                   int active_layers, int instances, int check_animated, int animation)
+{
+    Base     *base;
+    Object   *ob;
+
+    Material *ma;
+    MTex     *mtex;
+    Tex      *tex;
+
+    pthread_t threads[MAX_MESH_THREADS];
+    int       threads_count = 1;
+    int       _threadsCount = 0;
+    int       t;
+
+    UVLayer  *uv_layer;
+    LinkNode *uvs= NULL;
+    int       uv_id= 0;
+
+    LinkNode *list_iter= NULL;
+    int       i;
+
+    LinkNode *objects= NULL;
+    LinkNode *objects_iter;
+    LinkNode *meshes= NULL;
+
+    PointerRNA rna_tex;
+    PointerRNA rna_scene;
+
+    PointerRNA VRayScene;
+    PointerRNA VRayExporter;
+    PointerRNA VRayTexture;
+
+    if(sce->r.mode & R_FIXED_THREADS) {
+        threads_count = sce->r.threads;
+    }
+    else {
+        threads_count = BLI_system_thread_count();
+    }
+
+    // Get mesh exporter threads cout override from RNA
+    RNA_id_pointer_create(&sce->id, &rna_scene);
+    if(RNA_struct_find_property(&rna_scene, "vray")) {
+        VRayScene = RNA_pointer_get(&rna_scene, "vray");
+
+        if(RNA_struct_find_property(&VRayScene, "exporter")) {
+            VRayExporter = RNA_pointer_get(&VRayScene, "exporter");
+
+            _threadsCount = RNA_int_get(&VRayExporter, "meshExportThreads");
+            if(_threadsCount) {
+                threads_count = _threadsCount;
+            }
+        }
+    }
+
+    if(threads_count > MAX_MESH_THREADS)
+        threads_count = MAX_MESH_THREADS;
+
+    /*
+      XXX: Remove this! Preprocess textures to find proper UV channel indexes
+    */
+    for(ma= bmain->mat.first; ma; ma= ma->id.next) {
+        if(debug) {
+            printf("Material: %s\n", ma->id.name);
+        }
+        for(i= 0; i < MAX_MTEX; ++i) {
+            if(ma->mtex) {
+                mtex= ma->mtex[i];
+                if(mtex) {
+                    tex= mtex->tex;
+                    if(tex) {
+                        RNA_id_pointer_create(&tex->id, &rna_tex);
+                        if(RNA_struct_find_property(&rna_tex, "vray")) {
+                            VRayTexture= RNA_pointer_get(&rna_tex, "vray");
+                            if(RNA_enum_get(&VRayTexture, "texture_coords")) { // 0 - object; 1 - UV
+                                if(debug) {
+                                    printf("Texture:    %s [UV layer: %s]\n", mtex->tex->id.name, mtex->uvname);
+                                }
+                                if(!(strcmp(mtex->uvname, "") == 0)) {
+                                    if(!uvs) {
+                                        BLI_linklist_prepend(&uvs, uvlayer_ptr(mtex->uvname, ++uv_id));
+                                    } else {
+                                        if(!(uvlayer_in_list(uvs, mtex->uvname))) {
+                                            BLI_linklist_append(&uvs, uvlayer_ptr(mtex->uvname, ++uv_id));
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    if(debug) {
+        list_iter= uvs;
+        while(list_iter) {
+            uv_layer= list_iter->link;
+            if(uv_layer) {
+                printf("UV.name= %s\n", uv_layer->name);
+                printf("UV.id= %i\n", uv_layer->id);
+            }
+            list_iter= list_iter->next;
+        }
+    }
+
+    /*
+      Init thread data
+    */
+    for(t= 0; t < MAX_MESH_THREADS; ++t) {
+        thread_data[t].sce= sce;
+        thread_data[t].bmain= bmain;
+        thread_data[t].id= t;
+        thread_data[t].objects= NULL;
+        thread_data[t].uvs= uvs;
+        thread_data[t].filepath= filepath;
+        thread_data[t].animation= animation;
+        thread_data[t].instances= instances;
+    }
+
+    /*
+      Collect objects
+    */
+    base= (Base*)sce->base.first;
+    while(base) {
+        ob= base->object;
+
+        append_object(sce, &objects, &meshes, ob, active_layers, instances, check_animated, animation);
+
+        base= base->next;
+    }
+
+    if(debug) {
+        printf("Object list\n");
+        objects_iter= objects;
+        while(objects_iter) {
+            ob= (Object*)objects_iter->link;
+
+            printf("Object: %s\n", ob->id.name);
+
+            objects_iter= objects_iter->next;
+        }
+    }
+
+    /*
+      Split object list to multiple lists
+    */
+    t = 0;
+    objects_iter= objects;
+    while(objects_iter) {
+        ob = (Object*)objects_iter->link;
+
+        BLI_linklist_prepend(&(thread_data[t].objects), ob);
+
+        // TODO [LOW]: improve balancing using list sorting with ob->derivedFinal->numVertData
+        if(t < threads_count - 1)
+            t++;
+        else
+            t = 0;
+
+        objects_iter= objects_iter->next;
+    }
+
+    if(debug) {
+        for(t = 0; t < threads_count; ++t) {
+            if(BLI_linklist_length(thread_data[t].objects)) {
+                printf("Objects [%i]\n", t);
+                list_iter = thread_data[t].objects;
+                while(list_iter) {
+                    ob = list_iter->link;
+                    if(ob) {
+                        printf("  %s\n", ob->id.name);
+                    }
+                    list_iter = list_iter->next;
+                }
+            }
+        }
+    }
+
+    for(t = 0; t < threads_count; ++t) {
+        pthread_create(&threads[t], NULL, export_meshes_thread, (void*) &thread_data[t]);
+    }
+
+    for(t = 0; t < threads_count; ++t) {
+        pthread_join(threads[t], NULL);
+    }
+
+    for(t = 0; t < MAX_MESH_THREADS; ++t) {
+        BLI_linklist_free(thread_data[t].objects, NULL);
+    }
+
+    BLI_linklist_free(uvs,     NULL);
+    BLI_linklist_free(meshes,  NULL);
+    BLI_linklist_free(objects, NULL);
+
+    return;
+}
+
+
+static int export_scene_exec(bContext *C, wmOperator *op)
+{
+    Main   *bmain = CTX_data_main(C);
+
+    EvaluationContext eval_ctx = {0};
+
+    Scene  *sce     = NULL;
+    char   *sce_ptr = NULL;
+
+    int     fra  = 0;
+    int     cfra = 0;
+
+    char   *filepath       = NULL;
+    int     active_layers  = 0;
+    int     animation      = 0;
+    int     check_animated = 0;
+    int     instances      = 0;
+
+    double  time;
+    double  frame_time;
+    char    time_str[32];
+
+    if(RNA_struct_property_is_set(op->ptr, "scene")) {
+#if USE_STRING_POINTER
+        sce_ptr = (char*)malloc(32 * sizeof(char));
+        RNA_string_get(op->ptr, "scene", sce_ptr);
+        sce = atol(sce_ptr);
+        free(sce_ptr);
+#else
+        sce = RNA_int_get(op->ptr, "scene");
+#endif
+    }
+
+    if(!sce) {
+        sce = (Scene*)G.main->scene.first;
+    }
+
+    if(RNA_struct_property_is_set(op->ptr, "filepath")) {
+        filepath = (char*)malloc(FILE_MAX * sizeof(char));
+        RNA_string_get(op->ptr, "filepath", filepath);
+    }
+
+    if(RNA_struct_property_is_set(op->ptr, "use_active_layers")) {
+        active_layers = RNA_boolean_get(op->ptr, "use_active_layers");
+    }
+
+    if(RNA_struct_property_is_set(op->ptr, "use_animation")) {
+        animation = RNA_boolean_get(op->ptr, "use_animation");
+    }
+
+    if(RNA_struct_property_is_set(op->ptr, "use_instances")) {
+        instances = RNA_boolean_get(op->ptr, "use_instances");
+    }
+
+    if(RNA_struct_property_is_set(op->ptr, "check_animated")) {
+        check_animated = RNA_boolean_get(op->ptr, "check_animated");
+    }
+
+    if(RNA_struct_property_is_set(op->ptr, "debug")) {
+        debug = RNA_boolean_get(op->ptr, "debug");
+    }
+
+    eval_ctx.for_render = true;
+
+    time = PIL_check_seconds_timer();
+
+    if(filepath) {
+        PRINT_INFO("Exporting meshes...");
+
+        if(animation) {
+            cfra = sce->r.cfra;
+            fra  = sce->r.sfra;
+
+            PRINT_INFO_LB("Exporting meshes for the first frame %i...%s", fra, debug ? "\n" : "");
+
+            /* Export meshes for the start frame */
+            frame_time = PIL_check_seconds_timer();
+            sce->r.cfra = fra;
+            CLAMP(sce->r.cfra, MINAFRAME, MAXFRAME);
+            BKE_scene_update_for_newframe(&eval_ctx, bmain, sce, (1<<20) - 1);
+            export_meshes_threaded(filepath, sce, bmain, active_layers, instances, 0, 0);
+            fra += sce->r.frame_step;
+            BLI_timestr(PIL_check_seconds_timer()-frame_time, time_str, sizeof(time_str));
+            printf(" done [%s]\n", time_str);
+
+            /* Export meshes for the rest frames */
+            while(fra <= sce->r.efra) {
+                frame_time = PIL_check_seconds_timer();
+
+                PRINT_INFO_LB("Exporting meshes for frame %i...%s", fra, debug ? "\n" : "");
+
+                sce->r.cfra = fra;
+                CLAMP(sce->r.cfra, MINAFRAME, MAXFRAME);
+                BKE_scene_update_for_newframe(&eval_ctx, bmain, sce, (1<<20) - 1);
+                export_meshes_threaded(filepath, sce, bmain, active_layers, instances, check_animated, 1);
+
+                if(!debug) {
+                    BLI_timestr(PIL_check_seconds_timer()-frame_time, time_str, sizeof(time_str));
+                    printf(" done [%s]\n", time_str);
+                }
+
+                fra += sce->r.frame_step;
+            }
+
+            sce->r.cfra = cfra;
+            CLAMP(sce->r.cfra, MINAFRAME, MAXFRAME);
+            BKE_scene_update_for_newframe(&eval_ctx, bmain, sce, (1<<20) - 1);
+        } else {
+            export_meshes_threaded(filepath, sce, bmain, active_layers, instances, check_animated, 0);
+        }
+
+        BLI_timestr(PIL_check_seconds_timer()-time, time_str, sizeof(time_str));
+        PRINT_INFO("Exporting meshes done [%s]%-32s\n", time_str, " ");
+
+        free(filepath);
+
+        return OPERATOR_FINISHED;
+    }
+
+    return OPERATOR_CANCELLED;
+}
+
+
+static int export_scene_invoke(bContext *C, wmOperator *op, wmEvent *event)
+{
+     return OPERATOR_RUNNING_MODAL;
+}
+
+
+static int export_scene_modal(bContext *C, wmOperator *op, wmEvent *event)
+{
+    return OPERATOR_RUNNING_MODAL;
+}
+
+
+void VRAY_OT_export_meshes(wmOperatorType *ot)
+{
+    /* identifiers */
+    ot->name        = "Export Meshes";
+    ot->idname      = "VRAY_OT_export_meshes";
+    ot->description = "Export meshes in .vrscene format";
+
+    /* api callbacks */
+    ot->invoke = export_scene_invoke;
+    ot->modal  = export_scene_modal;
+    ot->exec   = export_scene_exec;
+
+#if USE_STRING_POINTER
+	RNA_def_string(ot->srna, "scene", "Scene", 32, "Scene", "Scene pointer");
+#else
+    RNA_def_int(ot->srna, "scene", 0, INT_MIN, INT_MAX, "Scene", "Scene pointer", INT_MIN, INT_MAX);
+#endif
+
+	RNA_def_string(ot->srna, "filepath", "Filepath", FILE_MAX, "Geometry filepath", "Geometry filepath");
+
+    RNA_def_boolean(ot->srna, "use_active_layers", 0,  "Active layer",      "Export only active layers");
+    RNA_def_boolean(ot->srna, "use_animation",     0,  "Animation",         "Export animation");
+    RNA_def_boolean(ot->srna, "use_instances",     0,  "Instances",         "Use instances");
+    RNA_def_boolean(ot->srna, "debug",             0,  "Debug",             "Debug mode");
+    RNA_def_boolean(ot->srna, "check_animated",    0,  "Check animated",    "Try to detect if mesh is animated");
+}
diff --git a/source/blender/exporter/exporter_geometry.h b/source/blender/exporter/exporter_geometry.h
new file mode 100644
index 0000000..7bfa4bb
--- /dev/null
+++ b/source/blender/exporter/exporter_geometry.h
@@ -0,0 +1,34 @@
+/*
+
+  V-Ray/Blender
+
+  http://vray.cgdo.ru
+
+  Author: Andrey M. Izrantsev (aka bdancer)
+  E-Mail: izrantsev@cgdo.ru
+
+  This program is free software; you can redistribute it and/or
+  modify it under the terms of the GNU General Public License
+  as published by the Free Software Foundation; either version 2
+  of the License, or (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
+
+*/
+
+#ifndef EXPORTER_GEOMETRY_H
+#define EXPORTER_GEOMETRY_H
+
+#include "exporter_includes.h"
+
+void VRAY_OT_export_meshes(wmOperatorType *ot);
+
+#endif // EXPORTER_GEOMETRY_H
diff --git a/source/blender/exporter/exporter_includes.h b/source/blender/exporter/exporter_includes.h
new file mode 100644
index 0000000..b7e1948
--- /dev/null
+++ b/source/blender/exporter/exporter_includes.h
@@ -0,0 +1,182 @@
+/*
+
+  V-Ray/Blender
+
+  http://vray.cgdo.ru
+
+  Author: Andrey M. Izrantsev (aka bdancer)
+  E-Mail: izrantsev@cgdo.ru
+
+  This program is free software; you can redistribute it and/or
+  modify it under the terms of the GNU General Public License
+  as published by the Free Software Foundation; either version 2
+  of the License, or (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
+
+*/
+
+#ifndef EXPORTER_INCLUDES_H
+#define EXPORTER_INCLUDES_H
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include <pthread.h>
+#include <time.h>
+#include <ctype.h>
+
+#include "BLI_linklist.h"
+#include "BLI_listbase.h"
+#include "BLI_math.h"
+#include "BLI_path_util.h"
+#include "BLI_string.h"
+#include "BLI_threads.h"
+#include "BLI_voxel.h"
+#include "BLI_utildefines.h"
+#include "BLI_math_matrix.h"
+#include "BLI_math_vector.h"
+#include "BLI_math_rotation.h"
+#include "BLI_fileops.h"
+
+#include "BKE_main.h"
+#include "BKE_scene.h"
+#include "BKE_context.h"
+#include "BKE_utildefines.h"
+#include "BKE_library.h"
+#include "BKE_DerivedMesh.h"
+#include "BKE_fcurve.h"
+#include "BKE_animsys.h"
+#include "BKE_particle.h"
+#include "BKE_pointcache.h"
+#include "BKE_global.h"
+#include "BKE_report.h"
+#include "BKE_object.h"
+#include "BKE_mesh.h"
+#include "BKE_curve.h"
+#include "BKE_bvhutils.h"
+#include "BKE_customdata.h"
+#include "BKE_anim.h"
+#include "BKE_depsgraph.h"
+#include "BKE_displist.h"
+#include "BKE_font.h"
+#include "BKE_mball.h"
+#include "BKE_modifier.h"
+#include "BKE_material.h"
+
+#include "DNA_scene_types.h"
+#include "DNA_object_types.h"
+#include "DNA_group_types.h"
+#include "DNA_meshdata_types.h"
+#include "DNA_mesh_types.h"
+#include "DNA_meta_types.h"
+#include "DNA_image_types.h"
+#include "DNA_material_types.h"
+#include "DNA_texture_types.h"
+#include "DNA_camera_types.h"
+#include "DNA_lamp_types.h"
+#include "DNA_anim_types.h"
+#include "DNA_action_types.h"
+#include "DNA_curve_types.h"
+#include "DNA_armature_types.h"
+#include "DNA_modifier_types.h"
+#include "DNA_windowmanager_types.h"
+#include "DNA_particle_types.h"
+#include "DNA_smoke_types.h"
+#include "DNA_listBase.h"
+
+#include "PIL_time.h"
+
+#include "RNA_access.h"
+#include "RNA_define.h"
+
+#include "smoke_API.h"
+
+#ifdef WIN32
+#  ifdef htonl
+#    undef htonl
+#    undef htons
+#    undef ntohl
+#    undef ntohs
+#    define correctByteOrder(x) htonl(x)
+#  endif
+#  include <winsock.h>
+#else
+#  include <netinet/in.h>
+#endif
+
+#include "WM_api.h"
+#include "WM_types.h"
+
+#include "MEM_guardedalloc.h"
+
+#define USE_DEBUG  1
+#define QTCREATOR  0
+
+// scons -Q define=QTCREATOR
+#if QTCREATOR
+#   define VRAY_PROMPT "V-Ray/Blender: "
+#else
+#   ifdef __linux__
+#      define VRAY_PROMPT "\033[0;32mV-Ray/Blender\033[0m: "
+#   else
+#      define VRAY_PROMPT "V-Ray/Blender: "
+#   endif
+#endif
+
+#if USE_DEBUG
+#  define DEBUG_OUTPUT(use_debug, ...) \
+    if(use_debug) { \
+        fprintf(stdout, VRAY_PROMPT); \
+        fprintf(stdout, __VA_ARGS__); \
+        fprintf(stdout, "\n"); \
+        fflush(stdout); \
+    }
+#else
+#  define DEBUG_OUTPUT(use_debug, ...)
+#endif
+
+#define COPY_VECTOR_3_3(a, b) \
+    a[0] = b[0];\
+    a[1] = b[1];\
+    a[2] = b[2];
+
+#define HEX(x) htonl(*(int*)&(x))
+#define WRITE_HEX_VALUE(f, v) fprintf(f, "%08X", HEX(v))
+#define WRITE_HEX_VECTOR(f, v) fprintf(f, "%08X%08X%08X", HEX(v[0]), HEX(v[1]), HEX(v[2]))
+
+#define WRITE_TRANSFORM(f, m) fprintf(f, "Transform(Matrix(Vector(%f, %f, %f),Vector(%f, %f, %f),Vector(%f, %f, %f)),Vector(%f, %f, %f))", \
+    m[0][0], m[0][1], m[0][2],\
+    m[1][0], m[1][1], m[1][2],\
+    m[2][0], m[2][1], m[2][2],\
+    m[3][0], m[3][1], m[3][2]);
+
+#define WRITE_TRANSFORM_HEX(f, m) fprintf(f, "TransformHex(\"%08X%08X%08X%08X%08X%08X%08X%08X%08X%08X%08X%08X\")", \
+    HEX(m[0][0]), HEX(m[0][1]), HEX(m[0][2]),\
+    HEX(m[1][0]), HEX(m[1][1]), HEX(m[1][2]),\
+    HEX(m[2][0]), HEX(m[2][1]), HEX(m[2][2]),\
+    HEX(m[3][0]), HEX(m[3][1]), HEX(m[3][2]))
+
+#define PRINT_TRANSFORM(m) printf("Transform(Matrix(Vector(%f, %f, %f),Vector(%f, %f, %f),Vector(%f, %f, %f)),Vector(%f, %f, %f))\n", \
+    m[0][0], m[0][1], m[0][2],\
+    m[1][0], m[1][1], m[1][2],\
+    m[2][0], m[2][1], m[2][2],\
+    m[3][0], m[3][1], m[3][2]);\
+    fflush(stdout)
+
+#define PRINT_TRANSFORM_HEX(f, m) printf("TransformHex(\"%08X%08X%08X%08X%08X%08X%08X%08X%08X%08X%08X%08X\")", \
+    HEX(m[0][0]), HEX(m[0][1]), HEX(m[0][2]),\
+    HEX(m[1][0]), HEX(m[1][1]), HEX(m[1][2]),\
+    HEX(m[2][0]), HEX(m[2][1]), HEX(m[2][2]),\
+    HEX(m[3][0]), HEX(m[3][1]), HEX(m[3][2]))
+
+#endif // EXPORTER_INCLUDES_H
diff --git a/source/blender/exporter/exporter_ops.c b/source/blender/exporter/exporter_ops.c
new file mode 100644
index 0000000..71f2976
--- /dev/null
+++ b/source/blender/exporter/exporter_ops.c
@@ -0,0 +1,34 @@
+/*
+
+  V-Ray/Blender
+
+  http://vray.cgdo.ru
+
+  Author: Andrey M. Izrantsev (aka bdancer)
+  E-Mail: izrantsev@cgdo.ru
+
+  This program is free software; you can redistribute it and/or
+  modify it under the terms of the GNU General Public License
+  as published by the Free Software Foundation; either version 2
+  of the License, or (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+  All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Software.
+
+*/
+
+#include "exporter_geometry.h"
+
+#include "ED_exporter.h"
+
+void ED_operatortypes_exporter(void)
+{
+    WM_operatortype_append(VRAY_OT_export_meshes);
+}
diff --git a/source/blender/makesdna/DNA_texture_types.h b/source/blender/makesdna/DNA_texture_types.h
index a3025a7..867e7bd 100644
--- a/source/blender/makesdna/DNA_texture_types.h
+++ b/source/blender/makesdna/DNA_texture_types.h
@@ -315,6 +315,7 @@ typedef struct ColorMapping {
 #define TEX_POINTDENSITY	14
 #define TEX_VOXELDATA		15
 #define TEX_OCEAN		16
+#define TEX_VRAY		200
 
 /* musgrave stype */
 #define TEX_MFRACTAL		0
diff --git a/source/blender/makesrna/intern/rna_texture.c b/source/blender/makesrna/intern/rna_texture.c
index b0e1ed0..84a11d1 100644
--- a/source/blender/makesrna/intern/rna_texture.c
+++ b/source/blender/makesrna/intern/rna_texture.c
@@ -63,6 +63,7 @@ static EnumPropertyItem texture_filter_items[] = {
 
 EnumPropertyItem texture_type_items[] = {
 	{0, "NONE", 0, "None", ""},
+	{TEX_VRAY, "VRAY", ICON_VRAY_LOGO_MONO, "V-Ray", "V-Ray procedural textures"},
 	{TEX_BLEND, "BLEND", ICON_TEXTURE, "Blend", "Procedural - create a ramp texture"},
 	{TEX_CLOUDS, "CLOUDS", ICON_TEXTURE, "Clouds", "Procedural - create a cloud-like fractal noise texture"},
 	{TEX_DISTNOISE, "DISTORTED_NOISE", ICON_TEXTURE,
diff --git a/source/blender/python/SConscript b/source/blender/python/SConscript
index a5b52a3..12320d8 100644
--- a/source/blender/python/SConscript
+++ b/source/blender/python/SConscript
@@ -117,6 +117,10 @@ if env['WITH_BF_CYCLES']:
 if env['WITH_BF_CYCLES_OSL']:
     defs.append('WITH_CYCLES_OSL')
 
+if env['WITH_VRAY_FOR_BLENDER']:
+    incs += ' ../vray_for_blender'
+    defs.append('WITH_VRAY_FOR_BLENDER')
+
 if env['WITH_BF_FREESTYLE']:
     incs += ' ../freestyle/intern/python'
     defs.append('WITH_FREESTYLE')
diff --git a/source/blender/python/intern/CMakeLists.txt b/source/blender/python/intern/CMakeLists.txt
index 0605f40..cec86db 100644
--- a/source/blender/python/intern/CMakeLists.txt
+++ b/source/blender/python/intern/CMakeLists.txt
@@ -148,6 +148,12 @@ if(WITH_CYCLES_OSL)
 	add_definitions(-DWITH_CYCLES_OSL)
 endif()
 
+if(WITH_VRAY_FOR_BLENDER)
+	list(APPEND INC
+		../../vray_for_blender
+	)
+endif()
+
 if(WITH_FREESTYLE)
 	list(APPEND INC
 		../../freestyle/intern/python
diff --git a/source/blender/python/intern/bpy_app_handlers.c b/source/blender/python/intern/bpy_app_handlers.c
index f8725d6..faf1b27 100644
--- a/source/blender/python/intern/bpy_app_handlers.c
+++ b/source/blender/python/intern/bpy_app_handlers.c
@@ -44,21 +44,23 @@ void bpy_app_generic_callback(struct Main *main, struct ID *id, void *arg);
 static PyTypeObject BlenderAppCbType;
 
 static PyStructSequence_Field app_cb_info_fields[] = {
-	{(char *)"frame_change_pre",  (char *)"Callback list - on frame change for playback and rendering (before)"},
-	{(char *)"frame_change_post", (char *)"Callback list - on frame change for playback and rendering (after)"},
-	{(char *)"render_pre",        (char *)"Callback list - on render (before)"},
-	{(char *)"render_post",       (char *)"Callback list - on render (after)"},
-	{(char *)"render_stats",      (char *)"Callback list - on printing render statistics"},
-	{(char *)"render_complete",   (char *)"Callback list - on completion of render job"},
-	{(char *)"render_cancel",     (char *)"Callback list - on canceling a render job"},
-	{(char *)"load_pre",          (char *)"Callback list - on loading a new blend file (before)"},
-	{(char *)"load_post",         (char *)"Callback list - on loading a new blend file (after)"},
-	{(char *)"save_pre",          (char *)"Callback list - on saving a blend file (before)"},
-	{(char *)"save_post",         (char *)"Callback list - on saving a blend file (after)"},
-	{(char *)"scene_update_pre",  (char *)"Callback list - on updating the scenes data (before)"},
-	{(char *)"scene_update_post", (char *)"Callback list - on updating the scenes data (after)"},
-	{(char *)"game_pre",          (char *)"Callback list - on starting the game engine"},
-	{(char *)"game_post",         (char *)"Callback list - on ending the game engine"},
+	{(char *)"frame_change_pre",   (char *)"Callback list - on frame change for playback and rendering (before)"},
+	{(char *)"frame_change_post",  (char *)"Callback list - on frame change for playback and rendering (after)"},
+	{(char *)"render_pre",         (char *)"Callback list - on render (before)"},
+	{(char *)"render_post",        (char *)"Callback list - on render (after)"},
+	{(char *)"render_stats",       (char *)"Callback list - on printing render statistics"},
+	{(char *)"render_complete",    (char *)"Callback list - on completion of render job"},
+	{(char *)"render_cancel",      (char *)"Callback list - on canceling a render job"},
+	{(char *)"load_pre",           (char *)"Callback list - on loading a new blend file (before)"},
+	{(char *)"load_post",          (char *)"Callback list - on loading a new blend file (after)"},
+	{(char *)"save_pre",           (char *)"Callback list - on saving a blend file (before)"},
+	{(char *)"save_post",          (char *)"Callback list - on saving a blend file (after)"},
+	{(char *)"scene_update_pre",   (char *)"Callback list - on updating the scenes data (before)"},
+	{(char *)"scene_update_post",  (char *)"Callback list - on updating the scenes data (after)"},
+	{(char *)"object_update",      (char *)"Callback list - on updating an object"},
+	{(char *)"object_data_update", (char *)"Callback list - on updating an object's data"},
+	{(char *)"game_pre",           (char *)"Callback list - on starting the game engine"},
+	{(char *)"game_post",          (char *)"Callback list - on ending the game engine"},
 
 	/* sets the permanent tag */
 #   define APP_CB_OTHER_FIELDS 1
diff --git a/source/blender/python/intern/bpy_interface.c b/source/blender/python/intern/bpy_interface.c
index aafb5e3..06983f7 100644
--- a/source/blender/python/intern/bpy_interface.c
+++ b/source/blender/python/intern/bpy_interface.c
@@ -80,6 +80,10 @@
 #include "../bmesh/bmesh_py_api.h"
 #include "../mathutils/mathutils.h"
 
+#ifdef WITH_VRAY_FOR_BLENDER
+#include "CGR_vray_for_blender.h"
+#endif
+
 
 /* for internal use, when starting and ending python scripts */
 
@@ -209,6 +213,13 @@ static PyObject *CCL_initPython(void)
 }
 #endif
 
+#ifdef WITH_VRAY_FOR_BLENDER
+static PyObject *CGR_initPython(void)
+{
+	return (PyObject*)VRayForBlender_initPython();
+}
+#endif
+
 static struct _inittab bpy_internal_modules[] = {
 	{(char *)"mathutils", PyInit_mathutils},
 //	{(char *)"mathutils.geometry", PyInit_mathutils_geometry},
@@ -227,11 +238,15 @@ static struct _inittab bpy_internal_modules[] = {
 #ifdef WITH_CYCLES
 	{(char *)"_cycles", CCL_initPython},
 #endif
+#ifdef WITH_VRAY_FOR_BLENDER
+	{(char *)"_vray_for_blender", CGR_initPython},
+#endif
 	{(char *)"gpu", GPU_initPython},
 	{(char *)"idprop", BPyInit_idprop},
 	{NULL, NULL}
 };
 
+
 /* call BPY_context_set first */
 void BPY_python_start(int argc, const char **argv)
 {
diff --git a/source/blender/python/intern/bpy_rna.c b/source/blender/python/intern/bpy_rna.c
index 23308bf..d0ed193 100644
--- a/source/blender/python/intern/bpy_rna.c
+++ b/source/blender/python/intern/bpy_rna.c
@@ -83,7 +83,7 @@
 #  include "BLF_translation.h"
 #endif
 
-#define USE_PEDANTIC_WRITE
+// #define USE_PEDANTIC_WRITE
 #define USE_MATHUTILS
 #define USE_STRING_COERCE
 
diff --git a/source/blender/vray_for_blender/CGR_config.h b/source/blender/vray_for_blender/CGR_config.h
new file mode 100644
index 0000000..1fefc73
--- /dev/null
+++ b/source/blender/vray_for_blender/CGR_config.h
@@ -0,0 +1,116 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2010 Blender Foundation.
+ * All rights reserved.
+ *
+ * Contributor(s): Andrei Izrantcev <andrei.izrantcev@chaosgroup.com>
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#ifndef CGR_CONFIG
+#define CGR_CONFIG
+
+#define PLUGIN_NAME V-Ray For Blender
+
+#define USE_COLOR        1
+
+#define USE_DEBUG        1
+#define USE_CALL_DEBUG  (1 && USE_DEBUG)
+#define USE_TIME_DEBUG  (1 && USE_DEBUG)
+#define USE_DRAW_DEBUG  (0 && USE_DEBUG)
+
+#define CGR_USE_JOBS     0
+#define CGR_USE_RNA      0
+#define CGR_USE_HEX      1
+
+#if USE_COLOR
+#  define COLOR_RED      "\033[0;31m"
+#  define COLOR_GREEN    "\033[0;32m"
+#  define COLOR_YELLOW   "\033[0;33m"
+#  define COLOR_BLUE     "\033[0;34m"
+#  define COLOR_MAGENTA  "\033[0;35m"
+#  define COLOR_DEFAULT  "\033[0m"
+#else
+#  define COLOR_RED      ""
+#  define COLOR_GREEN    ""
+#  define COLOR_YELLOW   ""
+#  define COLOR_BLUE     ""
+#  define COLOR_MAGENTA  ""
+#  define COLOR_DEFAULT  ""
+#endif
+
+#define NOT(x) !(x)
+
+#define STRINGIZE_NX(A) #A
+#define STRINGIZE(A) STRINGIZE_NX(A)
+
+#ifdef PLUGIN_NAME
+#  define _OUTPUT_PROMPT(P) COLOR_MAGENTA STRINGIZE(P) COLOR_DEFAULT ": "
+#  define OUTPUT_PROMPT _OUTPUT_PROMPT(PLUGIN_NAME)
+#else
+#  define OUTPUT_PROMPT COLOR_MAGENTA "Info" COLOR_DEFAULT ": "
+#endif
+
+#ifdef PLUGIN_NAME
+#  define _OUTPUT_ERROR_PROMPT(P) COLOR_RED STRINGIZE(P) " Error" COLOR_DEFAULT ": "
+#  define OUTPUT_ERROR_PROMPT _OUTPUT_ERROR_PROMPT(PLUGIN_NAME)
+#else
+#  define OUTPUT_ERROR_PROMPT COLOR_RED "Error" COLOR_DEFAULT ": "
+#endif
+
+#if USE_DEBUG == 0
+#  define DEBUG_PRINT(use_debug, ...)
+#else
+#  define DEBUG_PRINT(use_debug, ...) \
+    if(use_debug) { \
+        fprintf(stdout, OUTPUT_PROMPT); \
+        fprintf(stdout, __VA_ARGS__); \
+        fprintf(stdout, "\n"); \
+    }
+#endif
+
+#define PRINT_ERROR(...) \
+    fprintf(stdout, OUTPUT_ERROR_PROMPT); \
+    fprintf(stdout, __VA_ARGS__); \
+    fprintf(stdout, "\n"); \
+	fflush(stdout);
+
+#define PRINT_INFO(...) \
+    fprintf(stdout, OUTPUT_PROMPT); \
+    fprintf(stdout, __VA_ARGS__); \
+    fprintf(stdout, "\n"); \
+	fflush(stdout);
+
+#define PRINT_INFO_LB(...) \
+	fprintf(stdout, OUTPUT_PROMPT); \
+	fprintf(stdout, __VA_ARGS__); \
+	fflush(stdout);
+
+#if USE_DEBUG == 0
+#define PRINT_TM4(label, tm) ()
+#else
+#define PRINT_TM4(label, tm) \
+	PRINT_INFO("%s:", label); \
+	PRINT_INFO("  %.3f %.3f %.3f %.3f", tm[0][0], tm[0][1], tm[0][2], tm[0][3]); \
+	PRINT_INFO("  %.3f %.3f %.3f %.3f", tm[1][0], tm[1][1], tm[1][2], tm[1][3]); \
+	PRINT_INFO("  %.3f %.3f %.3f %.3f", tm[2][0], tm[2][1], tm[2][2], tm[2][3]); \
+	PRINT_INFO("  %.3f %.3f %.3f %.3f", tm[3][0], tm[3][1], tm[3][2], tm[3][3]);
+#endif
+
+#endif // CGR_CONFIG
diff --git a/source/blender/vray_for_blender/CGR_vray_for_blender.h b/source/blender/vray_for_blender/CGR_vray_for_blender.h
new file mode 100644
index 0000000..44d1cd7
--- /dev/null
+++ b/source/blender/vray_for_blender/CGR_vray_for_blender.h
@@ -0,0 +1,39 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2010 Blender Foundation.
+ * All rights reserved.
+ *
+ * Contributor(s): Andrei Izrantcev <andrei.izrantcev@chaosgroup.com>
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#ifndef CGR_VRAY_FOR_BLENDER_H
+#define CGR_VRAY_FOR_BLENDER_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void* VRayForBlender_initPython(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // CGR_VRAY_FOR_BLENDER_H
diff --git a/source/blender/vray_for_blender/CMakeLists.txt b/source/blender/vray_for_blender/CMakeLists.txt
new file mode 100644
index 0000000..14e9d7d
--- /dev/null
+++ b/source/blender/vray_for_blender/CMakeLists.txt
@@ -0,0 +1,52 @@
+include_directories(/home/bdancer/devel/globals/include)
+
+set(INC_SYS
+	${PYTHON_INCLUDE_DIRS}
+)
+
+set(INC
+	.
+	./common
+	../blenlib
+	../blenkernel
+	../blenloader
+	../makesdna
+	../makesrna
+	../imbuf
+	../windowmanager
+	../editors/include
+	../render/extern/include
+	../render/intern/include
+	${CMAKE_BINARY_DIR}/source/blender/makesrna/intern
+	../../../intern/guardedalloc
+	../../../intern/smoke/extern
+	../python
+)
+
+set(SRC
+	CGR_config.h
+
+	# Common stuff
+	common/blender_includes.h
+	utils/CGR_rna.h
+	utils/CGR_rna.cpp
+	utils/CGR_data.h
+	utils/CGR_data.c
+	utils/CGR_string.h
+	utils/CGR_string.c
+
+	# vrscene export
+	vrscene_exporter/vrscene.h
+	vrscene_exporter/vrscene.cpp
+	vrscene_exporter/geom.c
+	vrscene_exporter/hair.c
+	vrscene_exporter/node.cpp
+	vrscene_exporter/smoke.cpp
+
+	python/vray_python_ext.cpp
+
+	# C API
+	CGR_vray_for_blender.h
+)
+
+blender_add_lib(vray_for_blender "${SRC}" "${INC}" "${INC_SYS}")
diff --git a/source/blender/vray_for_blender/SConscript b/source/blender/vray_for_blender/SConscript
new file mode 100644
index 0000000..e9a387b
--- /dev/null
+++ b/source/blender/vray_for_blender/SConscript
@@ -0,0 +1,51 @@
+#!/usr/bin/python
+
+Import('env')
+
+sources = [
+    './python/vray_python_ext.cpp',
+    './utils/CGR_data.c',
+    './utils/CGR_rna.cpp',
+    './utils/CGR_string.c',
+    './vrscene_exporter/geom.c',
+    './vrscene_exporter/hair.c',
+    './vrscene_exporter/node.cpp',
+    './vrscene_exporter/smoke.cpp',
+    './vrscene_exporter/vrscene.cpp',
+]
+
+includes = [
+    '../../../intern/guardedalloc',
+    '../../../intern/smoke/extern',
+    '../../../intern/smoke/extern',
+    '../blenkernel',
+    '../blenlib',
+    '../blenloader',
+    '../makesdna',
+    '../makesrna',
+    '../render/extern/include',
+    '../render/intern/include',
+    '../windowmanager',
+    '../python',
+    '../python/intern',
+    './common',
+    './python',
+    './utils',
+    './vrscene_exporter',
+    './',
+]
+
+includes.extend(env['BF_PYTHON_INC'].split())
+includes.append(env['BF_BOOST_INC'])
+
+if env['OURPLATFORM'] in ('win32-vc', 'win32-mingw', 'linuxcross', 'win64-vc'):
+    includes.append(env['BF_PTHREADS_INC'])
+
+env.BlenderLib(
+    libname  = 'vray_for_blender',
+    sources  = sources,
+    includes = includes,
+    defines  = [],
+    libtype  = ['core'],
+    priority = [600]
+)
diff --git a/source/blender/vray_for_blender/common/blender_includes.h b/source/blender/vray_for_blender/common/blender_includes.h
new file mode 100644
index 0000000..4dab252
--- /dev/null
+++ b/source/blender/vray_for_blender/common/blender_includes.h
@@ -0,0 +1,124 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2010 Blender Foundation.
+ * All rights reserved.
+ *
+ * Contributor(s): Andrei Izrantcev <andrei.izrantcev@chaosgroup.com>
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#ifndef BLENDER_INCLUDES_H
+#define BLENDER_INCLUDES_H
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include <pthread.h>
+#include <time.h>
+#include <ctype.h>
+
+#include "BLI_linklist.h"
+#include "BLI_listbase.h"
+#include "BLI_math.h"
+#include "BLI_path_util.h"
+#include "BLI_string.h"
+#include "BLI_threads.h"
+#include "BLI_voxel.h"
+#include "BLI_utildefines.h"
+#include "BLI_math_matrix.h"
+#include "BLI_math_vector.h"
+#include "BLI_math_rotation.h"
+#include "BLI_fileops.h"
+
+#include "BKE_main.h"
+#include "BKE_scene.h"
+#include "BKE_context.h"
+#include "BKE_utildefines.h"
+#include "BKE_library.h"
+#include "BKE_DerivedMesh.h"
+#include "BKE_fcurve.h"
+#include "BKE_anim.h"
+#include "BKE_animsys.h"
+#include "BKE_particle.h"
+#include "BKE_pointcache.h"
+#include "BKE_global.h"
+#include "BKE_report.h"
+#include "BKE_object.h"
+#include "BKE_mesh.h"
+#include "BKE_curve.h"
+#include "BKE_bvhutils.h"
+#include "BKE_customdata.h"
+#include "BKE_anim.h"
+#include "BKE_depsgraph.h"
+#include "BKE_displist.h"
+#include "BKE_font.h"
+#include "BKE_mball.h"
+#include "BKE_modifier.h"
+#include "BKE_material.h"
+#include "BKE_texture.h"
+
+#include "DNA_scene_types.h"
+#include "DNA_object_types.h"
+#include "DNA_group_types.h"
+#include "DNA_meshdata_types.h"
+#include "DNA_mesh_types.h"
+#include "DNA_meta_types.h"
+#include "DNA_image_types.h"
+#include "DNA_material_types.h"
+#include "DNA_texture_types.h"
+#include "DNA_camera_types.h"
+#include "DNA_lamp_types.h"
+#include "DNA_anim_types.h"
+#include "DNA_action_types.h"
+#include "DNA_curve_types.h"
+#include "DNA_armature_types.h"
+#include "DNA_modifier_types.h"
+#include "DNA_windowmanager_types.h"
+#include "DNA_particle_types.h"
+#include "DNA_smoke_types.h"
+#include "DNA_listBase.h"
+
+#include "render_types.h"
+#include "RE_engine.h"
+
+#include "PIL_time.h"
+
+#include "RNA_access.h"
+#include "RNA_define.h"
+
+#ifdef WIN32
+#  ifdef htonl
+#    undef htonl
+#    undef htons
+#    undef ntohl
+#    undef ntohs
+#    define correctByteOrder(x) htonl(x)
+#  endif
+#  include <winsock.h>
+#else
+#  include <netinet/in.h>
+#endif
+
+#include "WM_api.h"
+#include "WM_types.h"
+
+#include "MEM_guardedalloc.h"
+
+#endif // BLENDER_INCLUDES_H
diff --git a/source/blender/vray_for_blender/python/vray_python_ext.cpp b/source/blender/vray_for_blender/python/vray_python_ext.cpp
new file mode 100644
index 0000000..bf64be1
--- /dev/null
+++ b/source/blender/vray_for_blender/python/vray_python_ext.cpp
@@ -0,0 +1,245 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2010 Blender Foundation.
+ * All rights reserved.
+ *
+ * Contributor(s): Andrei Izrantcev <andrei.izrantcev@chaosgroup.com>
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#include "CGR_config.h"
+
+extern "C" {
+#include "blender_includes.h"
+}
+
+#include "vrscene_exporter/vrscene.h"
+#include "utils/CGR_string.h"
+#include "CGR_vray_for_blender.h"
+extern "C" {
+#  include "mathutils/mathutils.h"
+}
+#include <Python.h>
+
+
+
+
+static PyObject* mExportSmokeDomain(PyObject *self, PyObject *args)
+{
+	int         contextPtr;
+	int         objectPtr;
+	int         smdPtr;
+	const char *pluginName;
+	const char *lights;
+	PyObject   *fileObject;
+
+	if(NOT(PyArg_ParseTuple(args, "iiissO", &contextPtr, &objectPtr, &smdPtr, &pluginName, &lights, &fileObject))) {
+		return NULL;
+	}
+
+	bContext          *C   = (bContext*)(intptr_t)contextPtr;
+	Object            *ob  = (Object*)(intptr_t)objectPtr;
+	SmokeModifierData *smd = (SmokeModifierData*)(intptr_t)smdPtr;
+
+	Scene *sce = CTX_data_scene(C);
+
+	write_SmokeDomain(fileObject, sce, ob, smd, pluginName, lights);
+
+	Py_RETURN_NONE;
+}
+
+
+static PyObject* mExportSmoke(PyObject *self, PyObject *args)
+{
+	int         contextPtr;
+	int         objectPtr;
+	int         smdPtr;
+	const char *pluginName;
+	PyObject   *fileObject;
+
+	int         p_interpolation;
+
+	if(NOT(PyArg_ParseTuple(args, "iiiisO", &contextPtr, &objectPtr, &smdPtr, &p_interpolation, &pluginName, &fileObject))) {
+		return NULL;
+	}
+
+	bContext          *C   = (bContext*)(intptr_t)contextPtr;
+	Object            *ob  = (Object*)(intptr_t)objectPtr;
+	SmokeModifierData *smd = (SmokeModifierData*)(intptr_t)smdPtr;
+
+	Scene *sce = CTX_data_scene(C);
+
+	write_TexVoxelData(fileObject, sce, ob, smd, pluginName, p_interpolation);
+
+	Py_RETURN_NONE;
+}
+
+
+static PyObject* mExportHair(PyObject *self, PyObject *args)
+{
+	int         contextPtr;
+	int         objectPtr;
+	int         psysPtr;
+	const char *pluginName;
+	PyObject   *fileObject;
+
+	if(NOT(PyArg_ParseTuple(args, "iiisO", &contextPtr, &objectPtr, &psysPtr, &pluginName, &fileObject))) {
+		return NULL;
+	}
+
+	bContext       *C    = (bContext*)(intptr_t)contextPtr;
+	Object         *ob   = (Object*)(intptr_t)objectPtr;
+	ParticleSystem *psys = (ParticleSystem*)(intptr_t)psysPtr;
+
+	Scene *sce  = CTX_data_scene(C);
+	Main  *main = CTX_data_main(C);
+
+	if(write_GeomMayaHair(fileObject, sce, main, ob, psys, pluginName)) {
+		return NULL;
+	}
+
+	Py_RETURN_NONE;
+}
+
+
+static PyObject* mExportMesh(PyObject *self, PyObject *args)
+{
+	int         contextPtr;
+	int         objectPtr;
+	const char *pluginName;
+	PyObject   *propGroup;
+	PyObject   *fileObject;
+
+	if(NOT(PyArg_ParseTuple(args, "iisOO", &contextPtr, &objectPtr, &pluginName, &propGroup, &fileObject))) {
+		return NULL;
+	}
+
+	bContext *C = (bContext*)(intptr_t)contextPtr;
+	Object   *ob = (Object*)(intptr_t)objectPtr;
+
+	Scene *sce  = CTX_data_scene(C);
+	Main  *main = CTX_data_main(C);
+
+	write_Mesh(fileObject, sce, ob, main, pluginName, propGroup);
+
+	Py_RETURN_NONE;
+}
+
+
+static PyObject* mExportNode(PyObject *self, PyObject *args)
+{
+	int       contextPtr;
+	int       objectPtr;
+	PyObject *nodeFile;
+	PyObject *geomFile;
+
+	char      pluginName[MAX_PLUGIN_NAME];
+
+	if(NOT(PyArg_ParseTuple(args, "iiOO", &contextPtr, &objectPtr, &nodeFile, &geomFile))) {
+		return NULL;
+	}
+
+	bContext *C = (bContext*)(intptr_t)contextPtr;
+	Object *ob  = (Object*)(intptr_t)objectPtr;
+
+	Scene *sce  = CTX_data_scene(C);
+	Main  *main = CTX_data_main(C);
+
+	sprintf(pluginName, "%s", ob->id.name);
+	StripString(pluginName);
+
+	write_ObjectNode(nodeFile, geomFile, sce, main, ob, ob->obmat, pluginName);
+
+	Py_RETURN_NONE;
+}
+
+
+static PyObject* mExportDupli(PyObject *self, PyObject *args)
+{
+	int       contextPtr;
+	int       objectPtr;
+	PyObject *nodeFile;
+	PyObject *geomFile;
+
+	if(NOT(PyArg_ParseTuple(args, "iiOO", &contextPtr, &objectPtr, &nodeFile, &geomFile))) {
+		return NULL;
+	}
+
+	bContext *C = (bContext*)(intptr_t)contextPtr;
+	Object *ob  = (Object*)(intptr_t)objectPtr;
+
+	Scene *sce  = CTX_data_scene(C);
+	Main  *main = CTX_data_main(C);
+
+	write_Dupli(nodeFile, geomFile, sce, main, ob);
+
+	Py_RETURN_NONE;
+}
+
+
+static PyObject* mGetTransformHex(PyObject *self, PyObject *value)
+{
+	if (MatrixObject_Check(value)) {
+		MatrixObject *transform = (MatrixObject*)value;
+
+		float tm[4][4];
+		char  tmBuf[130] = "";
+		char  buf[150]   = "";
+
+		copy_v3_v3(tm[0], MATRIX_COL_PTR(transform, 0));
+		copy_v3_v3(tm[1], MATRIX_COL_PTR(transform, 1));
+		copy_v3_v3(tm[2], MATRIX_COL_PTR(transform, 2));
+		copy_v3_v3(tm[3], MATRIX_COL_PTR(transform, 3));
+
+		GetTransformHex(tm, tmBuf);
+		sprintf(buf, "TransformHex(\"%s\")", tmBuf);
+
+		return _PyUnicode_FromASCII(buf, strlen(buf));
+	}
+
+	Py_RETURN_NONE;
+}
+
+
+static PyMethodDef methods[] = {
+	{"exportDupli",       mExportDupli,       METH_VARARGS, "Export dupli / particles"},
+	{"exportMesh",        mExportMesh,        METH_VARARGS, "Export mesh"},
+	{"exportSmoke",       mExportSmoke,       METH_VARARGS, "Export voxel data"},
+	{"exportSmokeDomain", mExportSmokeDomain, METH_VARARGS, "Export domain data"},
+	{"exportHair",        mExportHair,        METH_VARARGS, "Export hair"},
+	{"exportNode",        mExportNode,        METH_VARARGS, "Export Node description"},
+	{"getTransformHex",   mGetTransformHex,   METH_O,       "Get transform hex string"},
+	{NULL, NULL, 0, NULL},
+};
+
+
+static struct PyModuleDef module = {
+	PyModuleDef_HEAD_INIT,
+	"_vray_for_blender",
+	"V-Ray For Blender export helper module",
+	-1,
+	methods,
+	NULL, NULL, NULL, NULL
+};
+
+
+void* VRayForBlender_initPython()
+{
+	return (void*)PyModule_Create(&module);
+}
diff --git a/source/blender/vray_for_blender/utils/CGR_data.c b/source/blender/vray_for_blender/utils/CGR_data.c
new file mode 100644
index 0000000..7f405d6
--- /dev/null
+++ b/source/blender/vray_for_blender/utils/CGR_data.c
@@ -0,0 +1,119 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2010 Blender Foundation.
+ * All rights reserved.
+ *
+ * Contributor(s): Andrei Izrantcev <andrei.izrantcev@chaosgroup.com>
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#include "CGR_data.h"
+
+
+Mesh* GetRenderMesh(Scene *sce, Main *bmain, Object *ob)
+{
+    Mesh *tmpmesh;
+    Curve *tmpcu = NULL, *copycu;
+    Object *tmpobj = NULL;
+    Object *basis_ob = NULL;
+    ListBase disp = {NULL, NULL};
+    EvaluationContext eval_ctx = {0};
+
+    /* Make a dummy mesh, saves copying */
+    DerivedMesh *dm;
+
+    CustomDataMask mask = CD_MASK_MESH;
+
+    eval_ctx.for_render = true;
+
+    /* perform the mesh extraction based on type */
+    switch (ob->type) {
+    case OB_FONT:
+    case OB_CURVE:
+    case OB_SURF:
+        /* copies object and modifiers (but not the data) */
+        tmpobj = BKE_object_copy(ob);
+        tmpcu = (Curve*)tmpobj->data;
+        tmpcu->id.us--;
+
+        /* copies the data */
+        tmpobj->data = BKE_curve_copy((Curve*)ob->data);
+        copycu = (Curve*)tmpobj->data;
+
+        /* temporarily set edit so we get updates from edit mode, but
+         * also because for text datablocks copying it while in edit
+         * mode gives invalid data structures */
+        copycu->editfont = tmpcu->editfont;
+        copycu->editnurb = tmpcu->editnurb;
+
+        /* get updated display list, and convert to a mesh */
+        BKE_displist_make_curveTypes( sce, tmpobj, 0 );
+
+        copycu->editfont = NULL;
+        copycu->editnurb = NULL;
+
+        BKE_mesh_from_nurbs( tmpobj );
+
+        /* nurbs_to_mesh changes the type to a mesh, check it worked */
+        if (tmpobj->type != OB_MESH) {
+            BKE_libblock_free_us( &(G.main->object), tmpobj );
+            return NULL;
+        }
+        tmpmesh = (Mesh*)tmpobj->data;
+        BKE_libblock_free_us( &G.main->object, tmpobj );
+
+        break;
+
+    case OB_MBALL:
+        /* metaballs don't have modifiers, so just convert to mesh */
+        basis_ob = BKE_mball_basis_find(sce, ob);
+
+        if (ob != basis_ob)
+            return NULL; /* only do basis metaball */
+
+        tmpmesh = BKE_mesh_add(bmain, "Mesh");
+
+        BKE_displist_make_mball_forRender(&eval_ctx, sce, ob, &disp);
+        BKE_mesh_from_metaball(&disp, tmpmesh);
+        BKE_displist_free(&disp);
+
+        break;
+
+    case OB_MESH:
+        /* Write the render mesh into the dummy mesh */
+        dm = mesh_create_derived_render(sce, ob, mask);
+
+        tmpmesh = BKE_mesh_add(bmain, "Mesh");
+        DM_to_mesh(dm, tmpmesh, ob, mask);
+        dm->release(dm);
+
+        break;
+
+    default:
+        return NULL;
+    }
+
+    /* cycles and exporters rely on this still */
+    BKE_mesh_tessface_ensure(tmpmesh);
+
+    /* we don't assign it to anything */
+    tmpmesh->id.us--;
+
+    return tmpmesh;
+}
diff --git a/source/blender/vray_for_blender/utils/CGR_data.h b/source/blender/vray_for_blender/utils/CGR_data.h
new file mode 100644
index 0000000..57533df
--- /dev/null
+++ b/source/blender/vray_for_blender/utils/CGR_data.h
@@ -0,0 +1,42 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2010 Blender Foundation.
+ * All rights reserved.
+ *
+ * Contributor(s): Andrei Izrantcev <andrei.izrantcev@chaosgroup.com>
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#ifndef CGR_BLENDER_UTILS_H
+#define CGR_BLENDER_UTILS_H
+
+#include "blender_includes.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+Mesh* GetRenderMesh(Scene *sce, Main *bmain, Object *ob);
+bool  IsGeometryType(Object *ob);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif // CGR_BLENDER_UTILS_H
diff --git a/source/blender/vray_for_blender/utils/CGR_rna.cpp b/source/blender/vray_for_blender/utils/CGR_rna.cpp
new file mode 100644
index 0000000..4b4a88c
--- /dev/null
+++ b/source/blender/vray_for_blender/utils/CGR_rna.cpp
@@ -0,0 +1,158 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2010 Blender Foundation.
+ * All rights reserved.
+ *
+ * Contributor(s): Andrei Izrantcev <andrei.izrantcev@chaosgroup.com>
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#include "CGR_config.h"
+#include "CGR_rna.h"
+
+#include <stdio.h>
+
+#include <string>
+#include <vector>
+
+#include <boost/algorithm/string.hpp>
+#include <boost/algorithm/string/classification.hpp>
+
+
+using namespace RnaAccess;
+
+
+typedef std::vector<std::string> PathRNA;
+
+
+RnaValue::RnaValue(ID *id, const char *rnaPointerPath)
+{
+    m_path = rnaPointerPath;
+
+    PathRNA rnaPath;
+    boost::split(rnaPath, m_path, boost::is_any_of("."));
+
+    DEBUG_PRINT(0, "Initing RnaValue for path = %s", rnaPointerPath);
+
+    RNA_id_pointer_create(id, &m_pointer);
+
+    size_t nTokens = rnaPath.size();
+    for(size_t t = 0; t < nTokens; ++t) {
+        if(NOT(RNA_struct_find_property(&m_pointer, rnaPath[t].c_str()))) {
+            m_pointer = PointerRNA_NULL;
+            break;
+        }
+        m_pointer = RNA_pointer_get(&m_pointer, rnaPath[t].c_str());
+    }
+}
+
+
+int RnaValue::CheckProperty(const char *propName)
+{
+    if(m_pointer.data == NULL) {
+        PRINT_ERROR("Property pointer not found!");
+        return 1;
+    }
+
+    if(NOT(RNA_struct_find_property(&m_pointer, propName))) {
+        PRINT_ERROR("Property "COLOR_YELLOW"%s"COLOR_DEFAULT" not found!", propName);
+        return 2;
+    }
+
+    return 0;
+}
+
+
+int RnaValue::GetValue(const char *propName, int &value)
+{
+    if(CheckProperty(propName)) {
+        return 1;
+    }
+
+    value = RNA_int_get(&m_pointer, propName);
+
+    DEBUG_PRINT(0,
+                COLOR_BLUE"%s"COLOR_DEFAULT"."COLOR_GREEN"%s"COLOR_DEFAULT" = "COLOR_YELLOW"%i"COLOR_DEFAULT,
+                m_path.c_str(), propName, value);
+
+    return 0;
+}
+
+
+int RnaValue::GetValue(const char *propName, bool &value)
+{
+    if(CheckProperty(propName)) {
+        return 1;
+    }
+
+    value = RNA_boolean_get(&m_pointer, propName);
+
+    DEBUG_PRINT(0,
+                COLOR_BLUE"%s"COLOR_DEFAULT"."COLOR_GREEN"%s"COLOR_DEFAULT" = "COLOR_YELLOW"%s"COLOR_DEFAULT,
+                m_path.c_str(), propName, value ? "True" : "False");
+
+    return 0;
+}
+
+
+int RnaValue::GetValue(const char *propName, float &value)
+{
+    if(CheckProperty(propName)) {
+        return 1;
+    }
+
+    value = RNA_float_get(&m_pointer, propName);
+
+    DEBUG_PRINT(0,
+                COLOR_BLUE"%s"COLOR_DEFAULT"."COLOR_GREEN"%s"COLOR_DEFAULT" = "COLOR_YELLOW"%.3f"COLOR_DEFAULT,
+                m_path.c_str(), propName, value);
+
+    return 0;
+}
+
+
+// Usage:
+//   char value[MAX_ID_NAME - 2];
+//
+int RnaValue::GetValue(const char *propName, char *value)
+{
+    if(CheckProperty(propName)) {
+        return 1;
+    }
+
+    RNA_string_get(&m_pointer, propName, value);
+
+    DEBUG_PRINT(0,
+                COLOR_BLUE"%s"COLOR_DEFAULT"."COLOR_GREEN"%s"COLOR_DEFAULT" = "COLOR_YELLOW"%s"COLOR_DEFAULT,
+                m_path.c_str(), propName, value);
+
+    return 0;
+}
+
+
+int RnaValue::GetValue(const char *propName, float value[])
+{
+    if(CheckProperty(propName)) {
+        return 1;
+    }
+
+    RNA_float_get_array(&m_pointer, propName, value);
+
+    return 0;
+}
diff --git a/source/blender/vray_for_blender/utils/CGR_rna.h b/source/blender/vray_for_blender/utils/CGR_rna.h
new file mode 100644
index 0000000..39bffca
--- /dev/null
+++ b/source/blender/vray_for_blender/utils/CGR_rna.h
@@ -0,0 +1,58 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2010 Blender Foundation.
+ * All rights reserved.
+ *
+ * Contributor(s): Andrei Izrantcev <andrei.izrantcev@chaosgroup.com>
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#ifndef CGR_UTILS_RNA_H
+#define CGR_UTILS_RNA_H
+
+extern "C" {
+#include "RNA_access.h"
+}
+
+#include <string>
+
+
+namespace RnaAccess {
+
+class RnaValue {
+public:
+    RnaValue(ID *id, const char *rnaPointerPath);
+
+    int          GetValue(const char *propName, int   &value);
+    int          GetValue(const char *propName, bool  &value);
+    int          GetValue(const char *propName, float &value);
+    int          GetValue(const char *propName, char  *value);
+    int          GetValue(const char *propName, float  value[3]);
+
+private:
+    int          CheckProperty(const char *propName);
+
+    std::string  m_path;
+    PointerRNA   m_pointer;
+
+};
+
+}
+
+#endif // CGR_UTILS_RNA_H
diff --git a/source/blender/vray_for_blender/utils/CGR_string.c b/source/blender/vray_for_blender/utils/CGR_string.c
new file mode 100644
index 0000000..d1bb803
--- /dev/null
+++ b/source/blender/vray_for_blender/utils/CGR_string.c
@@ -0,0 +1,45 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2010 Blender Foundation.
+ * All rights reserved.
+ *
+ * Contributor(s): Andrei Izrantcev <andrei.izrantcev@chaosgroup.com>
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#include "CGR_string.h"
+#include <string.h>
+
+
+void StripString(char *str)
+{
+	int nChars = strlen(str);
+	int i      = 0;
+
+	for(i = 0; i < nChars; i++) {
+		if(str[i]) {
+			if(str[i] == '+')
+				str[i] = 'p';
+			else if(str[i] == '-')
+				str[i] = 'm';
+			else if(!((str[i] >= 'A' && str[i] <= 'Z') || (str[i] >= 'a' && str[i] <= 'z') || (str[i] >= '0' && str[i] <= '9')))
+				str[i] = '_';
+		}
+	}
+}
diff --git a/source/blender/vray_for_blender/utils/CGR_string.h b/source/blender/vray_for_blender/utils/CGR_string.h
new file mode 100644
index 0000000..1e528cb
--- /dev/null
+++ b/source/blender/vray_for_blender/utils/CGR_string.h
@@ -0,0 +1,39 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2010 Blender Foundation.
+ * All rights reserved.
+ *
+ * Contributor(s): Andrei Izrantcev <andrei.izrantcev@chaosgroup.com>
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#ifndef CGR_STRING_H
+#define CGR_STRING_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void StripString(char *str);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif // CGR_STRING_H
diff --git a/source/blender/vray_for_blender/vrscene_exporter/geom.c b/source/blender/vray_for_blender/vrscene_exporter/geom.c
new file mode 100644
index 0000000..b74f270
--- /dev/null
+++ b/source/blender/vray_for_blender/vrscene_exporter/geom.c
@@ -0,0 +1,357 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2010 Blender Foundation.
+ * All rights reserved.
+ *
+ * Contributor(s): Andrei Izrantcev <andrei.izrantcev@chaosgroup.com>
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#include "utils/CGR_data.h"
+
+#include "vrscene.h"
+
+
+static void WritePythonAttribute(PyObject *outputFile, PyObject *propGroup, const char *attrName)
+{
+	static char buf[MAX_PLUGIN_NAME];
+
+	PyObject *attr      = NULL;
+	PyObject *attrValue = NULL;
+
+	if(propGroup == Py_None)
+		return;
+
+	attr      = PyObject_GetAttrString(propGroup, attrName);
+	attrValue = PyNumber_Long(attr);
+
+	if(attrValue) {
+		WRITE_PYOBJECT(outputFile, "\n\t%s=%li;", attrName, PyLong_AsLong(attrValue));
+	}
+}
+
+
+static int write_edge_visibility(PyObject *outputFile, int k, unsigned long int *ev)
+{
+	static char buf[MAX_PLUGIN_NAME];
+
+	if(k == 9) {
+		WRITE_PYOBJECT_HEX_VALUE(outputFile, *ev);
+		*ev= 0;
+		return 0;
+	}
+
+	return k + 1;
+}
+
+
+void write_GeomStaticMesh(PyObject *outputFile, Scene *sce, Object *ob, Mesh *mesh, const char *pluginName, PyObject *propGroup)
+{
+	static char buf[MAX_PLUGIN_NAME];
+
+	Mesh   *data = ob->data;
+	MFace  *face;
+	MTFace *mtface;
+	MCol   *mcol;
+	MVert  *vert;
+	MEdge  *edge;
+
+	CustomData *fdata;
+
+	int    verts;
+	int    fve[4];
+	float *ve[4];
+	float  no[3];
+	float  col[3];
+
+	float  fno[3];
+	float  n0[3], n1[3], n2[3], n3[3];
+
+	int    matid       = 0;
+	int    uv_count    = 0;
+	int    uv_layer_id = 1;
+
+	PointerRNA   rna_me;
+	PointerRNA   VRayMesh;
+	PointerRNA   GeomStaticMesh;
+
+	int          dynamic_geometry= 0;
+
+	const int ft[6]= {0,1,2,2,3,0};
+
+	unsigned long int ev= 0;
+
+	int i, j, f, k, l;
+	int u;
+
+	if(!(mesh->totface)) {
+		PRINT_ERROR( "No faces in mesh \"%s\"", data->id.name);
+		return;
+	}
+
+	WRITE_PYOBJECT(outputFile, "\nGeomStaticMesh %s {", pluginName);
+
+	WRITE_PYOBJECT(outputFile, "\n\tvertices=interpolate((%d,ListVectorHex(\"", sce->r.cfra);
+	vert = mesh->mvert;
+	for(f = 0; f < mesh->totvert; ++vert, ++f) {
+		WRITE_PYOBJECT_HEX_VECTOR(outputFile, vert->co);
+	}
+	WRITE_PYOBJECT(outputFile, "\")));");
+
+	// TODO: velocities (?)
+
+	WRITE_PYOBJECT(outputFile, "\n\tfaces=interpolate((%d,ListIntHex(\"", sce->r.cfra);
+	face = mesh->mface;
+	for(f = 0; f < mesh->totface; ++face, ++f) {
+		if(face->v4) {
+			WRITE_PYOBJECT_HEX_QUADFACE(outputFile, face);
+		}
+		else {
+			WRITE_PYOBJECT_HEX_TRIFACE(outputFile, face);
+		}
+	}
+	WRITE_PYOBJECT(outputFile, "\")));");
+
+	WRITE_PYOBJECT(outputFile, "\n\tnormals=interpolate((%d,ListVectorHex(\"", sce->r.cfra);
+	face = mesh->mface;
+	for(f = 0; f < mesh->totface; ++face, ++f) {
+		if(face->flag & ME_SMOOTH) {
+			normal_short_to_float_v3(n0, mesh->mvert[face->v1].no);
+			normal_short_to_float_v3(n1, mesh->mvert[face->v2].no);
+			normal_short_to_float_v3(n2, mesh->mvert[face->v3].no);
+
+			if(face->v4)
+				normal_short_to_float_v3(n3, mesh->mvert[face->v4].no);
+		}
+		else {
+			if(face->v4)
+				normal_quad_v3(fno, mesh->mvert[face->v1].co, mesh->mvert[face->v2].co, mesh->mvert[face->v3].co, mesh->mvert[face->v4].co);
+			else
+				normal_tri_v3(fno,  mesh->mvert[face->v1].co, mesh->mvert[face->v2].co, mesh->mvert[face->v3].co);
+
+			copy_v3_v3(n0, fno);
+			copy_v3_v3(n1, fno);
+			copy_v3_v3(n2, fno);
+
+			if(face->v4)
+				copy_v3_v3(n3, fno);
+		}
+
+		if(face->v4) {
+			WRITE_PYOBJECT_HEX_VECTOR(outputFile, n0);
+			WRITE_PYOBJECT_HEX_VECTOR(outputFile, n1);
+			WRITE_PYOBJECT_HEX_VECTOR(outputFile, n2);
+			WRITE_PYOBJECT_HEX_VECTOR(outputFile, n2);
+			WRITE_PYOBJECT_HEX_VECTOR(outputFile, n3);
+			WRITE_PYOBJECT_HEX_VECTOR(outputFile, n0);
+		} else {
+			WRITE_PYOBJECT_HEX_VECTOR(outputFile, n0);
+			WRITE_PYOBJECT_HEX_VECTOR(outputFile, n1);
+			WRITE_PYOBJECT_HEX_VECTOR(outputFile, n2);
+		}
+	}
+	WRITE_PYOBJECT(outputFile, "\")));");
+
+
+	WRITE_PYOBJECT(outputFile, "\n\tfaceNormals=interpolate((%d,ListIntHex(\"", sce->r.cfra);
+	face= mesh->mface;
+	k= 0;
+	for(f= 0; f < mesh->totface; ++face, ++f) {
+		if(mesh->mface[f].v4)
+			verts= 6;
+		else
+			verts= 3;
+
+		for(i= 0; i < verts; i++) {
+			WRITE_PYOBJECT(outputFile, "%08X", HEX(k));
+			k++;
+		}
+	}
+	WRITE_PYOBJECT(outputFile, "\")));");
+
+
+	WRITE_PYOBJECT(outputFile, "\n\tface_mtlIDs=ListIntHex(\"");
+	face= mesh->mface;
+	for(f= 0; f < mesh->totface; ++face, ++f) {
+		matid= face->mat_nr + 1;
+		if(face->v4) {
+			WRITE_PYOBJECT(outputFile, "%08X%08X", HEX(matid), HEX(matid));
+		}
+		else {
+			WRITE_PYOBJECT(outputFile, "%08X", HEX(matid));
+		}
+	}
+	WRITE_PYOBJECT(outputFile, "\");");
+
+//	WRITE_PYOBJECT(outputFile, "\n\tedge_creases_vertices=ListIntHex(\"");
+//	WRITE_PYOBJECT(outputFile, "\");");
+
+//	WRITE_PYOBJECT(outputFile, "\n\tedge_creases_sharpness=ListFloatHex(\"");
+//	WRITE_PYOBJECT(outputFile, "\");");
+
+	WRITE_PYOBJECT(outputFile, "\n\tedge_visibility=ListIntHex(\"");
+	ev= 0;
+	if(mesh->totface <= 5) {
+		face= mesh->mface;
+		for(f= 0; f < mesh->totface; ++face, ++f) {
+			if(face->v4) {
+				ev= (ev << 6) | 27;
+			} else {
+				ev= (ev << 3) | 8;
+			}
+		}
+		WRITE_PYOBJECT(outputFile, "%08X", HEX(ev));
+	} else {
+		k= 0;
+		face= mesh->mface;
+		for(f= 0; f < mesh->totface; ++face, ++f) {
+			if(face->v4) {
+				ev= (ev << 3) | 3;
+				k= write_edge_visibility(outputFile, k, &ev);
+				ev= (ev << 3) | 3;
+				k= write_edge_visibility(outputFile, k, &ev);
+			} else {
+				ev= (ev << 3) | 8;
+				k= write_edge_visibility(outputFile, k, &ev);
+			}
+		}
+
+		if(k) {
+			WRITE_PYOBJECT(outputFile, "%08X", HEX(ev));
+		}
+	}
+	WRITE_PYOBJECT(outputFile, "\");");
+
+
+	fdata = &mesh->fdata;
+
+	uv_count  = CustomData_number_of_layers(fdata, CD_MTFACE);
+	uv_count += CustomData_number_of_layers(fdata, CD_MCOL);
+
+	if(uv_count) {
+		WRITE_PYOBJECT(outputFile, "\n\tmap_channels_names=List(");
+		for(l = 0; l < fdata->totlayer; ++l) {
+			if(fdata->layers[l].type == CD_MTFACE || fdata->layers[l].type == CD_MCOL) {
+				WRITE_PYOBJECT(outputFile, "\"%s\"", fdata->layers[l].name);
+
+				if(l < uv_count) {
+					WRITE_PYOBJECT(outputFile, ",");
+				}
+			}
+		}
+		WRITE_PYOBJECT(outputFile, ");");
+
+		WRITE_PYOBJECT(outputFile, "\n\tmap_channels=interpolate((%d, List(", sce->r.cfra);
+		uv_layer_id = 0;
+		for(l = 0; l < fdata->totlayer; ++l) {
+			if(fdata->layers[l].type == CD_MTFACE || fdata->layers[l].type == CD_MCOL) {
+				WRITE_PYOBJECT(outputFile, "\n\t\t// Name: %s", fdata->layers[l].name);
+				WRITE_PYOBJECT(outputFile, "\n\t\tList(%i,ListVectorHex(\"", uv_layer_id++);
+
+				if(fdata->layers[l].type == CD_MTFACE) {
+					face   = mesh->mface;
+					mtface = (MTFace*)fdata->layers[l].data;
+					for(f = 0; f < mesh->totface; ++face, ++f) {
+						if(face->v4)
+							verts = 4;
+						else
+							verts = 3;
+						for(i = 0; i < verts; i++) {
+							WRITE_PYOBJECT(outputFile, "%08X%08X00000000", HEX(mtface[f].uv[i][0]), HEX(mtface[f].uv[i][1]));
+						}
+					}
+				}
+				else {
+					face = mesh->mface;
+					mcol = (MCol*)fdata->layers[l].data;
+					for(f = 0; f < mesh->totface; ++face, ++f) {
+						if(face->v4)
+							verts = 4;
+						else
+							verts = 3;
+						for(i = 0; i < verts; i++) {
+							col[0] = (float)mcol[f * 4 + i].b / 255.0;
+							col[1] = (float)mcol[f * 4 + i].g / 255.0;
+							col[2] = (float)mcol[f * 4 + i].r / 255.0;
+
+							WRITE_PYOBJECT_HEX_VECTOR(outputFile, col);
+						}
+					}
+				}
+
+				WRITE_PYOBJECT(outputFile, "\"),");
+
+				WRITE_PYOBJECT(outputFile, "ListIntHex(\"");
+				u = 0;
+				face = mesh->mface;
+				for(f = 0; f < mesh->totface; ++face, ++f) {
+					if(face->v4) {
+						WRITE_PYOBJECT(outputFile, "%08X", HEX(u));
+						k = u+1;
+						WRITE_PYOBJECT(outputFile, "%08X", HEX(k));
+						k = u+2;
+						WRITE_PYOBJECT(outputFile, "%08X", HEX(k));
+						WRITE_PYOBJECT(outputFile, "%08X", HEX(k));
+						k = u+3;
+						WRITE_PYOBJECT(outputFile, "%08X", HEX(k));
+						WRITE_PYOBJECT(outputFile, "%08X", HEX(u));
+						u += 4;
+					} else {
+						WRITE_PYOBJECT(outputFile, "%08X", HEX(u));
+						k = u+1;
+						WRITE_PYOBJECT(outputFile, "%08X", HEX(k));
+						k = u+2;
+						WRITE_PYOBJECT(outputFile, "%08X", HEX(k));
+						u += 3;
+					}
+				}
+				WRITE_PYOBJECT(outputFile, "\"))");
+
+				if(l < uv_count) {
+					WRITE_PYOBJECT(outputFile, ",");
+				}
+			}
+		}
+		WRITE_PYOBJECT(outputFile, "\n\t)));");
+	}
+
+	if(propGroup) {
+		WritePythonAttribute(outputFile, propGroup, "dynamic_geometry");
+		WritePythonAttribute(outputFile, propGroup, "osd_subdiv_level");
+	}
+
+	WRITE_PYOBJECT(outputFile, "\n}\n");
+}
+
+
+void  write_Mesh(PyObject *outputFile, Scene *sce, Object *ob, Main *main, const char *pluginName, PyObject *propGroup)
+{
+	Mesh *mesh = GetRenderMesh(sce, main, ob);
+	if(NOT(mesh)) {
+		PRINT_ERROR("Can't get render mesh!");
+		return;
+	}
+
+	write_GeomStaticMesh(outputFile, sce, ob, mesh, pluginName, propGroup);
+
+	/* remove the temporary mesh */
+	BKE_mesh_free(mesh, TRUE);
+	BLI_remlink(&main->mesh, mesh);
+	MEM_freeN(mesh);
+}
diff --git a/source/blender/vray_for_blender/vrscene_exporter/hair.c b/source/blender/vray_for_blender/vrscene_exporter/hair.c
new file mode 100644
index 0000000..fb8b298
--- /dev/null
+++ b/source/blender/vray_for_blender/vrscene_exporter/hair.c
@@ -0,0 +1,718 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2010 Blender Foundation.
+ * All rights reserved.
+ *
+ * Contributor(s): Andrei Izrantcev <andrei.izrantcev@chaosgroup.com>
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#include "vrscene.h"
+
+
+typedef struct ParticleStrandData {
+	float *uvco;
+	int    totuv;
+} ParticleStrandData;
+
+
+// TODO: Remove! V-Ray could do it itself!
+//
+// Spline Interpolation
+//
+//  Code from: http://www.mech.uq.edu.au/staff/jacobs/nm_lib/doc/spline.html
+//
+
+// c_spline_init()
+//
+//   Evaluate the coefficients b[i], c[i], d[i], i = 0, 1, .. n-1 for
+//   a cubic interpolating spline
+//
+//   S(xx) = Y[i] + b[i] * w + c[i] * w**2 + d[i] * w**3
+//   where w = xx - x[i]
+//   and   x[i] <= xx <= x[i+1]
+//
+//   The n supplied data points are x[i], y[i], i = 0 ... n-1.
+//
+//   Input :
+//   -------
+//   n       : The number of data points or knots (n >= 2)
+//   end1,
+//   end2    : = 1 to specify the slopes at the end points
+//             = 0 to obtain the default conditions
+//   slope1,
+//   slope2  : the slopes at the end points x[0] and x[n-1]
+//             respectively
+//   x[]     : the abscissas of the knots in strictly
+//             increasing order
+//   y[]     : the ordinates of the knots
+//
+//   Output :
+//   --------
+//   b, c, d : arrays of spline coefficients as defined above
+//             (See note 2 for a definition.)
+//   iflag   : status flag
+//            = 0 normal return
+//            = 1 less than two data points; cannot interpolate
+//            = 2 x[] are not in ascending order
+//
+//   This C code written by ...  Peter & Nigel,
+//   ----------------------      Design Software,
+//                               42 Gubberley St,
+//                               Kenmore, 4069,
+//                               Australia.
+//
+//   Version ... 1.1, 30 September 1987
+//   -------     2.0, 6 April 1989    (start with zero subscript)
+//                                     remove ndim from parameter list
+//               2.1, 28 April 1989   (check on x[])
+//               2.2, 10 Oct   1989   change number order of matrix
+//
+//   Notes ...
+//   -----
+//   (1) The accompanying function seval() may be used to evaluate the
+//       spline while deriv will provide the first derivative.
+//   (2) Using p to denote differentiation
+//       y[i] = S(X[i])
+//       b[i] = Sp(X[i])
+//       c[i] = Spp(X[i])/2
+//       d[i] = Sppp(X[i])/6  ( Derivative from the right )
+//   (3) Since the zero elements of the arrays ARE NOW used here,
+//       all arrays to be passed from the main program should be
+//       dimensioned at least [n].  These routines will use elements
+//       [0 .. n-1].
+//   (4) Adapted from the text
+//       Forsythe, G.E., Malcolm, M.A. and Moler, C.B. (1977)
+//       "Computer Methods for Mathematical Computations"
+//       Prentice Hall
+//   (5) Note that although there are only n-1 polynomial segments,
+//       n elements are requird in b, c, d.  The elements b[n-1],
+//       c[n-1] and d[n-1] are set to continue the last segment
+//       past x[n-1].
+//
+static int c_spline_init(const int n, const int end1, const int end2, const float slope1, const float slope2,
+						 const float x[], const float y[],
+						 float b[], float c[], float d[], int *iflag)
+{
+	int     nm1, ib, i;
+	float  t;
+	int     ascend;
+
+	nm1    = n - 1;
+	*iflag = 0;
+
+	/* no possible interpolation */
+	if(n < 2) {
+		*iflag = 1;
+		goto LeaveSpline;
+	}
+
+	ascend = 1;
+	for(i = 1; i < n; ++i)
+		if (x[i] <= x[i-1]) ascend = 0;
+
+	if(!ascend) {
+		*iflag = 2;
+		goto LeaveSpline;
+	}
+
+	if(n >= 3)
+	{
+		/* At least quadratic */
+
+		/* Set up the symmetric tri-diagonal system
+		   b = diagonal
+		   d = offdiagonal
+		   c = right-hand-side  */
+		d[0] = x[1] - x[0];
+		c[1] = (y[1] - y[0]) / d[0];
+		for (i = 1; i < nm1; ++i)
+		{
+			d[i]   = x[i+1] - x[i];
+			b[i]   = 2.0 * (d[i-1] + d[i]);
+			c[i+1] = (y[i+1] - y[i]) / d[i];
+			c[i]   = c[i+1] - c[i];
+		}
+
+		/* Default End conditions
+		   Third derivatives at x[0] and x[n-1] obtained
+		   from divided differences  */
+		b[0]   = -d[0];
+		b[nm1] = -d[n-2];
+		c[0]   = 0.0;
+		c[nm1] = 0.0;
+		if(n != 3) {
+			c[0]   = c[2] / (x[3] - x[1]) - c[1] / (x[2] - x[0]);
+			c[nm1] = c[n-2] / (x[nm1] - x[n-3]) - c[n-3] / (x[n-2] - x[n-4]);
+			c[0]   = c[0] * d[0] * d[0] / (x[3] - x[0]);
+			c[nm1] = -c[nm1] * d[n-2] * d[n-2] / (x[nm1] - x[n-4]);
+		}
+
+		/* Alternative end conditions -- known slopes */
+		if(end1 == 1) {
+			b[0] = 2.0 * (x[1] - x[0]);
+			c[0] = (y[1] - y[0]) / (x[1] - x[0]) - slope1;
+		}
+		if(end2 == 1) {
+			b[nm1] = 2.0 * (x[nm1] - x[n-2]);
+			c[nm1] = slope2 - (y[nm1] - y[n-2]) / (x[nm1] - x[n-2]);
+		}
+
+		/* Forward elimination */
+		for(i = 1; i < n; ++i) {
+			t    = d[i-1] / b[i-1];
+			b[i] = b[i] - t * d[i-1];
+			c[i] = c[i] - t * c[i-1];
+		}
+
+		/* Back substitution */
+		c[nm1] = c[nm1] / b[nm1];
+		for(ib = 0; ib < nm1; ++ib)
+		{
+			i    = n - ib - 2;
+			c[i] = (c[i] - d[i] * c[i+1]) / b[i];
+		}
+
+		/* c[i] is now the sigma[i] of the text */
+
+		/* Compute the polynomial coefficients */
+		b[nm1] = (y[nm1] - y[n-2]) / d[n-2] + d[n-2] * (c[n-2] + 2.0 * c[nm1]);
+		for(i = 0; i < nm1; ++i)
+		{
+			b[i] = (y[i+1] - y[i]) / d[i] - d[i] * (c[i+1] + 2.0 * c[i]);
+			d[i] = (c[i+1] - c[i]) / d[i];
+			c[i] = 3.0 * c[i];
+		}
+		c[nm1] = 3.0 * c[nm1];
+		d[nm1] = d[n-2];
+
+	}
+	else
+	{
+		/* linear segment only  */
+		b[0] = (y[1] - y[0]) / (x[1] - x[0]);
+		c[0] = 0.0;
+		d[0] = 0.0;
+		b[1] = b[0];
+		c[1] = 0.0;
+		d[1] = 0.0;
+	}
+
+LeaveSpline:
+	return 0;
+}
+
+
+// c_spline_eval()
+//
+//  Evaluate the cubic spline function
+//
+//  S(xx) = y[i] + b[i] * w + c[i] * w**2 + d[i] * w**3
+//  where w = u - x[i]
+//  and   x[i] <= u <= x[i+1]
+//  Note that Horner's rule is used.
+//  If u < x[0]   then i = 0 is used.
+//  If u > x[n-1] then i = n-1 is used.
+//
+//  Input :
+//  -------
+//  n       : The number of data points or knots (n >= 2)
+//  u       : the abscissa at which the spline is to be evaluated
+//  Last    : the segment that was last used to evaluate U
+//  x[]     : the abscissas of the knots in strictly increasing order
+//  y[]     : the ordinates of the knots
+//  b, c, d : arrays of spline coefficients computed by spline().
+//
+//  Output :
+//  --------
+//  seval   : the value of the spline function at u
+//  Last    : the segment in which u lies
+//
+//  Notes ...
+//  -----
+//  (1) If u is not in the same interval as the previous call then a
+//      binary search is performed to determine the proper interval.
+//
+static float c_spline_eval(int n, float u, float x[], float y[],
+						   float b[], float c[], float d[], int *last)
+{
+	int    i, j, k;
+	float w;
+
+	i = *last;
+
+	if(i >= n-1) i = 0;
+	if(i < 0)  i = 0;
+
+	/* perform a binary search */
+	if((x[i] > u) || (x[i+1] < u))
+	{
+		i = 0;
+		j = n;
+		do
+		{
+			k = (i + j) / 2;         /* split the domain to search */
+			if (u < x[k])  j = k;    /* move the upper bound */
+			if (u >= x[k]) i = k;    /* move the lower bound */
+		}                            /* there are no more segments to search */
+		while (j > i+1);
+	}
+	*last = i;
+
+	/* Evaluate the spline */
+	w = u - x[i];
+	w = y[i] + w * (b[i] + w * (c[i] + w * d[i]));
+
+	return w;
+}
+
+
+// Taken from "source/blender/render/intern/source/convertblender.c"
+// and slightly modified
+//
+static void get_particle_uvco_mcol(short from, DerivedMesh *dm, float *fuv, int num, ParticleStrandData *sd)
+{
+	int i;
+
+	/* get uvco */
+	if (sd->uvco && ELEM(from, PART_FROM_FACE, PART_FROM_VOLUME)) {
+		for (i=0; i<sd->totuv; i++) {
+			if (num != DMCACHE_NOTFOUND) {
+				MFace  *mface  = dm->getTessFaceData(dm, num, CD_MFACE);
+				MTFace *mtface = (MTFace*)CustomData_get_layer_n(&dm->faceData, CD_MTFACE, i);
+				mtface += num;
+
+				psys_interpolate_uvs(mtface, mface->v4, fuv, sd->uvco + 2 * i);
+			}
+			else {
+				sd->uvco[2*i] = 0.0f;
+				sd->uvco[2*i + 1] = 0.0f;
+			}
+		}
+	}
+}
+
+
+int write_GeomMayaHair(PyObject *outputFile, Scene *sce, Main *bmain, Object *ob, ParticleSystem *psys, const char *pluginName)
+{
+	static char buf[MAX_PLUGIN_NAME];
+
+	int    i, c, p, s;
+	float  f;
+	float  t;
+
+	EvaluationContext eval_ctx = {0};
+
+	ParticleSettings           *pset = NULL;
+	ParticleSystemModifierData *psmd = NULL;
+
+	ParticleData       *pa   = NULL;
+	HairKey            *hkey = NULL;
+	ParticleStrandData  sd;
+
+	ParticleCacheKey **child_cache = NULL;
+	ParticleCacheKey  *child_key   = NULL;
+	ChildParticle     *cpa         = NULL;
+	int                child_total = 0;
+	int                child_steps = 0;
+	float              child_key_co[3];
+
+	float     hairmat[4][4];
+	float     segment[3];
+	float     color[3] = {0.5f,0.5f,0.5f};
+	float     width = 0.001f;
+	float     cone_width = 0.001f;
+	int       num = -1;
+
+	int       spline_init_flag;
+	int       interp_points_count;
+	float     interp_points_step;
+	int       data_points_count;
+	float     data_points_step;
+	float     data_points_ordinates[3][64];
+	float     data_points_abscissas[64];
+
+	float     s_b[3][16];
+	float     s_c[3][16];
+	float     s_d[3][16];
+
+	int       spline_last[3];
+
+	short     use_cone    = false;
+	short     use_child   = 0;
+	short     free_edit   = 0;
+	short     need_recalc = 0;
+
+	PointerRNA  rna_pset;
+	PointerRNA  VRayParticleSettings;
+	PointerRNA  VRayFur;
+
+	int  display_percentage;
+	int  display_percentage_child;
+
+	int  debug = false;
+
+	eval_ctx.for_render = true;
+
+	need_recalc = 0;
+
+	pset = psys->part;
+
+	if(pset->type != PART_HAIR) {
+		return 1;
+	}
+
+	if(psys->part->ren_as != PART_DRAW_PATH) {
+		return 1;
+	}
+
+	psmd = psys_get_modifier(ob, psys);
+	if(!psmd) {
+		return 1;
+	}
+	if(!(psmd->modifier.mode & eModifierMode_Render)) {
+		return 1;
+	}
+
+	RNA_id_pointer_create(&pset->id, &rna_pset);
+
+	if(RNA_struct_find_property(&rna_pset, "vray")) {
+		VRayParticleSettings= RNA_pointer_get(&rna_pset, "vray");
+
+		if(RNA_struct_find_property(&VRayParticleSettings, "VRayFur")) {
+			VRayFur = RNA_pointer_get(&VRayParticleSettings, "VRayFur");
+
+			// Get hair width
+			width = RNA_float_get(&VRayFur, "width");
+		}
+	}
+
+	child_cache = psys->childcache;
+	child_total = psys->totchildcache;
+	use_child   = (pset->childtype && child_cache);
+
+	// Store "Display percentage" setting
+	display_percentage       = pset->disp;
+	display_percentage_child = pset->child_nbr;
+
+	// Check if particles are edited
+	free_edit = psys_check_edited(psys);
+
+	// Recalc parent hair only if they are not
+	// manually edited
+	if(!free_edit) {
+		need_recalc = 1;
+		pset->disp = 100;
+		psys->recalc |= PSYS_RECALC;
+	}
+
+	if(use_child) {
+		need_recalc = 1;
+		pset->child_nbr = pset->ren_child_nbr;
+		psys->recalc |= PSYS_RECALC_CHILD;
+	}
+
+	if(psys->flag & PSYS_HAIR_DYNAMICS)
+		need_recalc = 0;
+
+	// Recalc hair with render settings
+	if(need_recalc) {
+		ob->recalc |= OB_RECALC_ALL;
+		BKE_scene_update_tagged(&eval_ctx, bmain, sce);
+	}
+
+	// Get new child data pointers
+	if(use_child) {
+		child_cache = psys->childcache;
+		child_total = psys->totchildcache;
+
+		DEBUG_PRINT(debug, "child_total = %i", child_total);
+	}
+
+	// Spline interpolation
+	interp_points_count = (int)pow(2.0, pset->ren_step);
+	interp_points_step = 1.0 / (interp_points_count - 1);
+
+	DEBUG_PRINT(debug, "interp_points_count = %i", interp_points_count);
+
+	WRITE_PYOBJECT(outputFile, "GeomMayaHair %s {", pluginName);
+	WRITE_PYOBJECT(outputFile, "\n\tnum_hair_vertices=interpolate((%d,ListIntHex(\"", sce->r.cfra);
+	if(use_child) {
+		for(p = 0; p < child_total; ++p) {
+			WRITE_PYOBJECT_HEX_VALUE(outputFile, interp_points_count);
+		}
+	}
+	else {
+		LOOP_PARTICLES {
+			WRITE_PYOBJECT_HEX_VALUE(outputFile, interp_points_count);
+		}
+	}
+	WRITE_PYOBJECT(outputFile, "\")));");
+
+	WRITE_PYOBJECT(outputFile, "\n\thair_vertices=interpolate((%d,ListVectorHex(\"", sce->r.cfra);
+	if(use_child) {
+		for(p = 0; p < child_total; ++p) {
+			child_key   = child_cache[p];
+			child_steps = child_key->steps;
+
+			// Spline interpolation
+			data_points_count = child_steps;
+			data_points_step  = 1.0f / (child_steps - 1);
+
+			// Store control points
+			for(s = 0, f = 0.0f; s < child_steps; ++s, ++child_key, f += data_points_step) {
+				data_points_abscissas[s] = f;
+
+				// Child particles are stored in world space,
+				// but we need them in object space
+				copy_v3_v3(child_key_co, child_key->co);
+
+				// Remove transform by applying inverse matrix
+				mul_m4_v3(ob->imat, child_key_co);
+
+				for(c = 0; c < 3; ++c) {
+					data_points_ordinates[c][s] = child_key_co[c];
+				}
+			}
+
+			// Init spline coefficients
+			for(c = 0; c < 3; ++c) {
+				c_spline_init(data_points_count, 0, 0, 0.0f, 0.0f,
+							  data_points_abscissas, data_points_ordinates[c],
+							  s_b[c], s_c[c], s_d[c], &spline_init_flag);
+			}
+
+			// Write interpolated child points
+			for(c = 0; c < 3; ++c)
+				spline_last[c] = 0;
+
+			for(t = 0.0f; t <= 1.0; t += interp_points_step) {
+				// Calculate interpolated coordinate
+				for(c = 0; c < 3; ++c) {
+					segment[c] = c_spline_eval(data_points_count, t, data_points_abscissas, data_points_ordinates[c],
+											   s_b[c], s_c[c], s_d[c], &spline_last[c]);
+				}
+
+				WRITE_PYOBJECT_HEX_VECTOR(outputFile, segment);
+			}
+		}
+	}
+	else {
+		LOOP_PARTICLES {
+			DEBUG_PRINT(debug, "\033[0;32mV-Ray/Blender:\033[0m Particle system: %s => Hair: %i\n", psys->name, p + 1);
+
+			psys_mat_hair_to_object(NULL, psmd->dm, psmd->psys->part->from, pa, hairmat);
+
+			// Spline interpolation
+			data_points_count = pa->totkey;
+			data_points_step  = 1.0f / (data_points_count - 1);
+
+			DEBUG_PRINT(debug, "data_points_count = %i", data_points_count);
+			DEBUG_PRINT(debug, "data_points_step = %.3f", data_points_step);
+
+			for(i = 0, f = 0.0f; i < data_points_count; ++i, f += data_points_step) {
+				data_points_abscissas[i] = f;
+			}
+
+			// Store control points
+			for(s = 0, hkey = pa->hair; s < pa->totkey; ++s, ++hkey) {
+				copy_v3_v3(segment, hkey->co);
+				mul_m4_v3(hairmat, segment);
+
+				for(c = 0; c < 3; ++c) {
+					data_points_ordinates[c][s] = segment[c];
+				}
+			}
+
+			// Init spline coefficients
+			for(c = 0; c < 3; ++c) {
+				c_spline_init(data_points_count, 0, 0, 0.0f, 0.0f,
+							  data_points_abscissas, data_points_ordinates[c],
+							  s_b[c], s_c[c], s_d[c], &spline_init_flag);
+			}
+
+			// Write interpolated points
+			for(c = 0; c < 3; ++c)
+				spline_last[c] = 0;
+			for(t = 0.0f; t <= 1.0; t += interp_points_step) {
+				// Calculate interpolated coordinates
+				for(c = 0; c < 3; ++c) {
+					segment[c] = c_spline_eval(data_points_count, t, data_points_abscissas, data_points_ordinates[c],
+											   s_b[c], s_c[c], s_d[c], &spline_last[c]);
+				}
+				WRITE_PYOBJECT_HEX_VECTOR(outputFile, segment);
+			}
+		}
+	}
+	WRITE_PYOBJECT(outputFile, "\")));");
+
+	memset(&sd, 0, sizeof(ParticleStrandData));
+
+	// DEBUG_PRINT(TRUE, "psmd->dm = 0x%X", psmd->dm);
+
+	if(psmd->dm) {
+		if(use_child) {
+			sd.totuv = CustomData_number_of_layers(&psmd->dm->faceData, CD_MTFACE);
+
+			if(sd.totuv) {
+				sd.uvco = MEM_callocN(sd.totuv * 2 * sizeof(float), "particle_uvs");
+			}
+			else {
+				sd.uvco = NULL;
+			}
+
+			if(sd.uvco) {
+				WRITE_PYOBJECT(outputFile, "\n\tstrand_uvw=interpolate((%d,ListVectorHex(\"", sce->r.cfra);
+
+				for(p = 0; p < child_total; ++p) {
+					cpa = psys->child + p;
+
+					/* get uvco & mcol */
+					if(pset->childtype==PART_CHILD_FACES) {
+						get_particle_uvco_mcol(PART_FROM_FACE, psmd->dm, cpa->fuv, cpa->num, &sd);
+					}
+					else {
+						ParticleData *parent = psys->particles + cpa->parent;
+						num = parent->num_dmcache;
+
+						if (num == DMCACHE_NOTFOUND)
+							if (parent->num < psmd->dm->getNumTessFaces(psmd->dm))
+								num = parent->num;
+
+						get_particle_uvco_mcol(pset->from, psmd->dm, parent->fuv, num, &sd);
+					}
+
+					segment[0] = sd.uvco[0];
+					segment[1] = sd.uvco[1];
+					segment[2] = 0.0f;
+
+					WRITE_PYOBJECT_HEX_VECTOR(outputFile, segment);
+				}
+				WRITE_PYOBJECT(outputFile, "\")));");
+
+				MEM_freeN(sd.uvco);
+			}
+		}
+		else {
+			sd.totuv = CustomData_number_of_layers(&psmd->dm->faceData, CD_MTFACE);
+
+			if(sd.totuv) {
+				sd.uvco = MEM_callocN(sd.totuv * 2 * sizeof(float), "particle_uvs");
+			}
+			else {
+				sd.uvco = NULL;
+			}
+
+			if(sd.uvco) {
+				WRITE_PYOBJECT(outputFile, "\n\tstrand_uvw=interpolate((%d,ListVectorHex(\"", sce->r.cfra);
+				LOOP_PARTICLES {
+					/* get uvco & mcol */
+					num = pa->num_dmcache;
+
+					if(num == DMCACHE_NOTFOUND) {
+						if(pa->num < psmd->dm->getNumTessFaces(psmd->dm)) {
+							num = pa->num;
+						}
+					}
+
+					get_particle_uvco_mcol(pset->from, psmd->dm, pa->fuv, num, &sd);
+
+					// DEBUG_PRINT(TRUE, "Pa.uv = %.3f, %.3f", sd.uvco[0], sd.uvco[1]);
+
+					segment[0] = sd.uvco[0];
+					segment[1] = sd.uvco[1];
+					segment[2] = 0.0f;
+
+					WRITE_PYOBJECT_HEX_VECTOR(outputFile, segment);
+				}
+				WRITE_PYOBJECT(outputFile, "\")));");
+
+				MEM_freeN(sd.uvco);
+			}
+		}
+	}
+
+	WRITE_PYOBJECT(outputFile, "\n\twidths=interpolate((%d,ListFloatHex(\"", sce->r.cfra);
+	if(use_child) {
+		for(p = 0; p < child_total; ++p) {
+			cone_width = width;
+			for(s = 0; s < interp_points_count; ++s) {
+				if(use_cone && s > 0) {
+					cone_width = width / s;
+				}
+				WRITE_PYOBJECT_HEX_VALUE(outputFile, cone_width);
+			}
+		}
+	}
+	else {
+		for(p = 0; p < psys->totpart; ++p) {
+			for(s = 0; s < interp_points_count; ++s) {
+				cone_width = width;
+				if(use_cone && s > 0) {
+					cone_width = width / s;
+				}
+				WRITE_PYOBJECT_HEX_VALUE(outputFile, cone_width);
+			}
+		}
+	}
+	WRITE_PYOBJECT(outputFile, "\")));");
+
+	WRITE_PYOBJECT(outputFile, "\n\tcolors=interpolate((%d,ListColorHex(\"", sce->r.cfra);
+	if(use_child) {
+		for(p = 0; p < child_total; ++p) {
+			for(s = 0; s < interp_points_count; ++s) {
+				WRITE_PYOBJECT_HEX_VECTOR(outputFile, color);
+			}
+		}
+	}
+	else {
+		for(p = 0; p < psys->totpart; ++p) {
+			for(s = 0; s < interp_points_count; ++s) {
+				WRITE_PYOBJECT_HEX_VECTOR(outputFile, color);
+			}
+		}
+	}
+	WRITE_PYOBJECT(outputFile, "\")));");
+
+	WRITE_PYOBJECT(outputFile, "\n\topacity=1.0;");
+	if(psys->part->flag & PART_HAIR_BSPLINE) {
+		WRITE_PYOBJECT(outputFile, "\n\tgeom_splines=1;");
+		WRITE_PYOBJECT(outputFile, "\n\tgeom_tesselation_mult=1.0;");
+	}
+	WRITE_PYOBJECT(outputFile, "\n}\n\n");
+
+	// Restore "Display percentage" setting
+	pset->disp      = display_percentage;
+	pset->child_nbr = display_percentage_child;
+
+	if(!free_edit) {
+		psys->recalc |= PSYS_RECALC;
+	}
+	if(use_child) {
+		psys->recalc |= PSYS_RECALC_CHILD;
+	}
+
+	// Recalc hair back with viewport settings
+	if(need_recalc) {
+		ob->recalc |= OB_RECALC_ALL;
+		BKE_scene_update_tagged(&eval_ctx, bmain, sce);
+	}
+
+	return 0;
+}
diff --git a/source/blender/vray_for_blender/vrscene_exporter/node.cpp b/source/blender/vray_for_blender/vrscene_exporter/node.cpp
new file mode 100644
index 0000000..e427b22
--- /dev/null
+++ b/source/blender/vray_for_blender/vrscene_exporter/node.cpp
@@ -0,0 +1,130 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2010 Blender Foundation.
+ * All rights reserved.
+ *
+ * Contributor(s): Andrei Izrantcev <andrei.izrantcev@chaosgroup.com>
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#include "utils/CGR_string.h"
+#include "vrscene.h"
+#include <set>
+#include <string>
+
+
+static std::set<std::string> exportedMeshes;
+
+
+void  write_ObjectNode(PyObject   *nodeFile,
+					   PyObject   *geomFile,
+					   Scene      *sce,
+					   Main       *main,
+					   Object     *ob,
+					   float       tm[4][4],
+					   const char *pluginName)
+{
+	static char buf[MAX_PLUGIN_NAME];
+
+	char material[MAX_PLUGIN_NAME];
+	char geometry[MAX_PLUGIN_NAME];
+
+	// TODO:
+	//   [ ] Add type checking and sync with Python naming
+	//
+	sprintf(material, "RS%s", ob->id.name);
+	sprintf(geometry, "ME%s", ob->id.name+2);
+
+	StripString(material);
+	StripString(geometry);
+
+	if(exportedMeshes.find(geometry) == exportedMeshes.end()) {
+		exportedMeshes.insert(geometry);
+
+		write_Mesh(geomFile, sce, ob, main, geometry, NULL);
+	}
+
+	WRITE_PYOBJECT(nodeFile, "\nNode %s {", pluginName);
+	WRITE_PYOBJECT(nodeFile, "\n\tobjectID=%i;", ob->index);
+	WRITE_PYOBJECT(nodeFile, "\n\tmaterial=%s;", material);
+	WRITE_PYOBJECT(nodeFile, "\n\tgeometry=%s;", geometry);
+	WRITE_PYOBJECT(nodeFile, "\n\ttransform=interpolate((%d,", sce->r.cfra);
+	WRITE_PYOBJECT_TRANSFORM(nodeFile, tm);
+	WRITE_PYOBJECT(nodeFile, "));");
+	WRITE_PYOBJECT(nodeFile, "\n}\n");
+}
+
+
+void  write_Node(PyObject   *outputFile,
+				 Scene      *sce,
+				 Object     *ob,
+				 const char *pluginName,
+				 const char *transform,
+				 const char *geometry,
+				 const char *material,
+				 const char *volume,
+				 const int   nsamples,
+				 const char *lights,
+				 const char *user_attributes,
+				 const int   visible,
+				 const int   objectID,
+				 const int   primary_visibility)
+{
+}
+
+
+static void free_duplilist(Object *ob)
+{
+	if(ob->duplilist) {
+		free_object_duplilist(ob->duplilist);
+		ob->duplilist = NULL;
+	}
+}
+
+
+void write_Dupli(PyObject   *nodeFile,
+				 PyObject   *geomFile,
+				 Scene      *sce,
+				 Main       *main,
+				 Object     *ob)
+{
+	EvaluationContext eval_ctx = {0};
+
+	DupliObject *dob;
+	char         pluginName[MAX_PLUGIN_NAME];
+
+	eval_ctx.for_render = true;
+
+	exportedMeshes.clear();
+
+	// Free duplilist if a user forgets to
+	free_duplilist(ob);
+
+	ob->duplilist = object_duplilist(&eval_ctx, sce, ob);
+
+	for(dob = (DupliObject*)ob->duplilist->first; dob; dob = dob->next) {
+		sprintf(pluginName, "%s_%.5i", dob->ob->id.name, dob->persistent_id[0]);
+		StripString(pluginName);
+
+		write_ObjectNode(nodeFile, geomFile, sce, main, dob->ob, dob->mat, pluginName);
+	}
+
+	// Free our duplilist
+	free_duplilist(ob);
+}
diff --git a/source/blender/vray_for_blender/vrscene_exporter/smoke.cpp b/source/blender/vray_for_blender/vrscene_exporter/smoke.cpp
new file mode 100644
index 0000000..a329410
--- /dev/null
+++ b/source/blender/vray_for_blender/vrscene_exporter/smoke.cpp
@@ -0,0 +1,306 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2010 Blender Foundation.
+ * All rights reserved.
+ *
+ * Contributor(s): Andrei Izrantcev <andrei.izrantcev@chaosgroup.com>
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#include "vrscene.h"
+
+#include "smoke_API.h"
+
+#define USE_HEAT           0
+#define USE_LOCAL_DOMAIN   1
+
+#define DEBUG_GIZMO_SHAPE  0
+
+
+static void GetDomainBounds(SmokeDomainSettings *sds, float p0[3], float p1[3])
+{
+	if(sds->flags & MOD_SMOKE_ADAPTIVE_DOMAIN) {
+		p0[0] = sds->p0[0] + sds->cell_size[0] * sds->res_min[0];
+		p0[1] = sds->p0[1] + sds->cell_size[1] * sds->res_min[1];
+		p0[2] = sds->p0[2] + sds->cell_size[2] * sds->res_min[2];
+		p1[0] = sds->p0[0] + sds->cell_size[0] * sds->res_max[0];
+		p1[1] = sds->p0[1] + sds->cell_size[1] * sds->res_max[1];
+		p1[2] = sds->p0[2] + sds->cell_size[2] * sds->res_max[2];
+	}
+	else {
+		p0[0] = -1.0f;
+		p0[1] = -1.0f;
+		p0[2] = -1.0f;
+		p1[0] =  1.0f;
+		p1[1] =  1.0f;
+		p1[2] =  1.0f;
+	}
+
+	// PRINT_INFO("sds->res_min = %i %i %i", sds->res_min[0], sds->res_min[1], sds->res_min[2]);
+	// PRINT_INFO("sds->res_max = %i %i %i", sds->res_max[0], sds->res_max[1], sds->res_max[2]);
+	// PRINT_INFO("sds->cell_size = %.3f %.3f %.3f", sds->cell_size[0], sds->cell_size[1], sds->cell_size[2]);
+	// PRINT_INFO("sds->p0 = %.3f %.3f %.3f", sds->p0[0], sds->p0[1], sds->p0[2]);
+	// PRINT_INFO("sds->p1 = %.3f %.3f %.3f", sds->p1[0], sds->p1[1], sds->p1[2]);
+	// PRINT_INFO("p0 = %.3f %.3f %.3f", p0[0], p0[1], p0[2]);
+	// PRINT_INFO("p1 = %.3f %.3f %.3f", p1[0], p1[1], p1[2]);
+}
+
+
+// Represents transformation of base domain to adaptive domain
+//
+static void GetBaseToAdaptiveTransform(SmokeDomainSettings *sds, float tm[4][4])
+{
+	float p0[3];
+	float p1[3];
+
+	GetDomainBounds(sds, p0, p1);
+
+	unit_m4(tm);
+
+	tm[0][0] = fabs(p1[0] - p0[0]) / 2.0f;
+	tm[1][1] = fabs(p1[1] - p0[1]) / 2.0f;
+	tm[2][2] = fabs(p1[2] - p0[2]) / 2.0f;
+
+	tm[3][0] = (p0[0] + p1[0]) / 2.0f;
+	tm[3][1] = (p0[1] + p1[1]) / 2.0f;
+	tm[3][2] = (p0[2] + p1[2]) / 2.0f;
+
+	// PRINT_TM4("adaptive", tm);
+}
+
+
+static void GetDomainTransform(Object *ob, SmokeDomainSettings *sds, float tm[4][4])
+{
+	unit_m4(tm);
+
+	float domainToAdaptiveTM[4][4];
+	GetBaseToAdaptiveTransform(sds, domainToAdaptiveTM);
+
+	mul_m4_m4m4(tm, ob->obmat, domainToAdaptiveTM);
+
+	// PRINT_TM4("object", ob->obmat);
+	// PRINT_TM4("domain", tm);
+}
+
+
+static void write_SmokeGizmo(PyObject          *outputFile,
+							 Scene             *sce,
+							 Object            *ob,
+							 SmokeModifierData *smd,
+							 const char        *pluginName,
+							 const char        *geometryName,
+							 const char        *lights)
+{
+	static char buf[MAX_PLUGIN_NAME];
+
+	SmokeDomainSettings *sds = smd->domain;
+
+	float domainTM[4][4];
+	GetDomainTransform(ob, sds, domainTM);
+
+	WRITE_PYOBJECT(outputFile, "\nEnvFogMeshGizmo %s {", pluginName);
+	WRITE_PYOBJECT(outputFile, "\n\tgeometry=%s;", geometryName);
+	if(strlen(lights)) {
+		WRITE_PYOBJECT(outputFile, "\n\tlights=%s;", lights);
+	}
+	WRITE_PYOBJECT(outputFile, "\n\ttransform=interpolate((%d,", sce->r.cfra);
+	WRITE_PYOBJECT_TRANSFORM(outputFile, domainTM);
+	WRITE_PYOBJECT(outputFile, "));");
+	WRITE_PYOBJECT(outputFile, "\n}\n");
+
+#if DEBUG_GIZMO_SHAPE
+	WRITE_PYOBJECT(outputFile, "\nNode Node%s {", geometryName);
+	WRITE_PYOBJECT(outputFile, "\n\tgeometry=%s;", geometryName);
+	WRITE_PYOBJECT(outputFile, "\n\tmaterial=MANOMATERIALISSET;");
+	WRITE_PYOBJECT(outputFile, "\n\ttransform=interpolate((%d,", sce->r.cfra);
+	WRITE_PYOBJECT_TRANSFORM(outputFile, domainTM);
+	WRITE_PYOBJECT(outputFile, "));");
+	WRITE_PYOBJECT(outputFile, "\n}\n");
+#endif
+}
+
+
+void write_SmokeDomain(PyObject          *outputFile,
+					   Scene             *sce,
+					   Object            *ob,
+					   SmokeModifierData *smd,
+					   const char        *pluginName,
+					   const char        *lights)
+{
+	static char buf[MAX_PLUGIN_NAME];
+
+	char geomteryPluginName[MAX_PLUGIN_NAME];
+	sprintf(geomteryPluginName, "Geom%s", pluginName);
+
+	// Topology is always the same:
+	//   2.0 x 2.0 x 2.0 box
+	//
+	WRITE_PYOBJECT(outputFile, "\nGeomStaticMesh %s {", geomteryPluginName);
+	WRITE_PYOBJECT(outputFile,
+				   "\n\tvertices=ListVectorHex(\""
+				   "000080BF000080BF000080BF000080BF000080BF0000803F000080BF0000803F0000803F000080BF0000803F000080BF"
+				   "0000803F000080BF000080BF0000803F000080BF0000803F0000803F0000803F0000803F0000803F0000803F000080BF\");");
+	WRITE_PYOBJECT(outputFile,
+				   "\n\tfaces=ListIntHex(\""
+				   "000000000100000002000000020000000300000000000000020000000100000005000000050000000600000002000000"
+				   "070000000600000005000000050000000400000007000000000000000300000007000000070000000400000000000000"
+				   "030000000200000006000000060000000700000003000000010000000000000004000000040000000500000001000000\");");
+	WRITE_PYOBJECT(outputFile, "\n}\n");
+
+	write_SmokeGizmo(outputFile, sce, ob, smd, pluginName, geomteryPluginName, lights);
+}
+
+
+// Blender smoke uses 2.0 x 2.0 x 2.0 mesh domain and then uses object transform to form the final
+// smoke domain, there also could be an adaptive domain, so we need to transform UVWs
+//
+static void write_SmokeUVWGen(PyObject          *outputFile,
+							  Scene             *sce,
+							  Object            *ob,
+							  SmokeModifierData *smd,
+							  const char        *pluginName)
+{
+	static char buf[MAX_PLUGIN_NAME];
+
+	SmokeDomainSettings *sds = smd->domain;
+
+	float domainTm[4][4];
+	GetDomainTransform(ob, sds, domainTm);
+	invert_m4(domainTm);
+
+	// Remaps [-1.0, 1.0] to [0.0, 1.0]
+	float uvwTm[4][4];
+	scale_m4_fl(uvwTm, 0.5f);
+	copy_v3_fl(uvwTm[3], 0.5f);
+
+	float uvw_transform[4][4];
+	mul_m4_m4m4(uvw_transform, uvwTm, domainTm);
+
+	WRITE_PYOBJECT(outputFile, "\nUVWGenPlanarWorld %s {", pluginName);
+	WRITE_PYOBJECT(outputFile, "\n\tuvw_transform=interpolate((%d,", sce->r.cfra);
+	WRITE_PYOBJECT_TRANSFORM(outputFile, uvw_transform);
+	WRITE_PYOBJECT(outputFile, "));");
+	WRITE_PYOBJECT(outputFile, "\n}\n");
+}
+
+
+void write_TexVoxelData(PyObject          *outputFile,
+						Scene             *sce,
+						Object            *ob,
+						SmokeModifierData *smd,
+						const char        *pluginName,
+						short              interpolation)
+{
+	static char buf[MAX_PLUGIN_NAME];
+
+	SmokeDomainSettings *sds = smd->domain;
+
+	char uvwPluginName[MAX_PLUGIN_NAME];
+	sprintf(uvwPluginName, "UVW%s", pluginName);
+
+	size_t i;
+	size_t tot_res_high;
+	size_t tot_res_low;
+
+	int    res_high[3];
+	int    res_low[3];
+
+	float  ob_imat[4][4];
+
+	if(NOT(sds && sds->fluid)) {
+		PRINT_ERROR("Domain and / or fluid data not found!");
+		return;
+	}
+
+	// Store object invert matrix
+	invert_m4_m4(ob_imat, ob->obmat);
+
+	// flame: Use flame temperature as texture data
+	// dens: Use smoke density and color as texture data
+	// heat: Use smoke heat as texture data. Values from -2.0 to 2.0 are used
+	float dt, dx, *dens, *react, *fuel, *flame, *heat, *heatold, *vx, *vy, *vz, *r, *g, *b;
+	float _d, _fu, _fl;
+	unsigned char *obstacles;
+	float *tcu, *tcv, *tcw;
+
+	if(sds->flags & MOD_SMOKE_HIGHRES) {
+		COPY_VECTOR_3_3(res_high, sds->res_wt);
+		COPY_VECTOR_3_3(res_low,  sds->res);
+
+		smoke_turbulence_export(sds->wt, &dens, &react, &flame, &fuel, &r, &g, &b, &tcu, &tcv, &tcw);
+	}
+	else {
+		COPY_VECTOR_3_3(res_high, sds->res);
+		COPY_VECTOR_3_3(res_low,  sds->res);
+
+		smoke_export(sds->fluid, &dt, &dx, &dens, &react, &flame, &fuel, &heat, &heatold, &vx, &vy, &vz, &r, &g, &b, &obstacles);
+	}
+
+	// PRINT_INFO("sds->res      = %i %i %i", sds->res[0],    sds->res[1],    sds->res[2]);
+	// PRINT_INFO("sds->res_wt   = %i %i %i", sds->res_wt[0], sds->res_wt[1], sds->res_wt[2]);
+	// PRINT_INFO("sds->base_res = %i %i %i", sds->base_res[0], sds->base_res[1], sds->base_res[2]);
+
+	tot_res_high = (size_t)res_high[0] * (size_t)res_high[1] * (size_t)res_high[2];
+	tot_res_low  = (size_t)res_low[0]  * (size_t)res_low[1]  * (size_t)res_low[2];
+
+	write_SmokeUVWGen(outputFile, sce, ob, smd, uvwPluginName);
+
+	WRITE_PYOBJECT(outputFile, "\nTexVoxelData %s {", pluginName);
+	WRITE_PYOBJECT(outputFile, "\n\tuvwgen=%s;", uvwPluginName);
+	WRITE_PYOBJECT(outputFile, "\n\tinterpolation=%i;", interpolation);
+	WRITE_PYOBJECT(outputFile, "\n\tresolution=Vector(%i,%i,%i);", res_high[0], res_high[1], res_high[2]);
+#if USE_HEAT
+	WRITE_PYOBJECT(outputFile, "\n\tresolution_low=Vector(%i,%i,%i);", res_low[0], res_low[1], res_low[2]);
+#endif
+
+	WRITE_PYOBJECT(outputFile, "\n\tdensity=interpolate((%d, ListFloatHex(\"", sce->r.cfra);
+	for(i = 0; i < tot_res_high; ++i) {
+		_d = dens ? dens[i] : 0.0f;
+		WRITE_PYOBJECT_HEX_VALUE(outputFile, _d);
+	}
+	WRITE_PYOBJECT(outputFile, "\")));");
+
+	WRITE_PYOBJECT(outputFile, "\n\tflame=interpolate((%d, ListFloatHex(\"", sce->r.cfra);
+	for(i = 0; i < tot_res_high; ++i) {
+		_fl = flame ? flame[i] : 0.0f;
+		WRITE_PYOBJECT_HEX_VALUE(outputFile, _fl);
+	}
+	WRITE_PYOBJECT(outputFile, "\")));");
+
+	WRITE_PYOBJECT(outputFile, "\n\tfuel=interpolate((%d, ListFloatHex(\"", sce->r.cfra);
+	for(i = 0; i < tot_res_high; ++i) {
+		_fu = fuel ? fuel[i] : 0.0f;
+		WRITE_PYOBJECT_HEX_VALUE(outputFile, _fu);
+	}
+	WRITE_PYOBJECT(outputFile, "\")));");
+
+#if USE_HEAT
+	if(NOT(sds->flags & MOD_SMOKE_HIGHRES)) {
+		WRITE_PYOBJECT(outputFile, "\n\theat=interpolate((%d, ListFloatHex(\"", sce->r.cfra);
+		// Heat is somehow always low res
+		for(i = 0; i < tot_res_low; ++i) {
+			_h = heat ? heat[i] : 0.0f;
+			WRITE_PYOBJECT_HEX_VALUE(outputFile, _h);
+		}
+		WRITE_PYOBJECT(outputFile, "\")));");
+	}
+#endif
+
+	WRITE_PYOBJECT(outputFile, "\n}\n");
+}
diff --git a/source/blender/vray_for_blender/vrscene_exporter/vrscene.cpp b/source/blender/vray_for_blender/vrscene_exporter/vrscene.cpp
new file mode 100644
index 0000000..db378c9
--- /dev/null
+++ b/source/blender/vray_for_blender/vrscene_exporter/vrscene.cpp
@@ -0,0 +1,84 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2010 Blender Foundation.
+ * All rights reserved.
+ *
+ * Contributor(s): Andrei Izrantcev <andrei.izrantcev@chaosgroup.com>
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#include "vrscene.h"
+
+#ifdef _WIN32
+typedef unsigned char u_int8_t;
+#endif
+
+
+static char sbuf[MAX_PLUGIN_NAME];
+
+
+struct TraceTransform {
+	float  m[3][3];
+	double v[3];
+};
+
+
+static char int2hexValue(char d)
+{
+	return d<=9 ? '0'+d : (d-10+'A');
+}
+
+
+static void getStringHex(const u_int8_t *buf, unsigned nBytes, char *pstr)
+{
+	for(unsigned i = 0; i < nBytes; ++i) {
+		char val0 = int2hexValue((buf[i]>>4)&0xF);
+		char val1 = int2hexValue(buf[i]&0xF);
+		pstr[i*2+0] = val0;
+		pstr[i*2+1] = val1;
+	}
+	pstr[nBytes*2] = 0;
+}
+
+
+void GetDoubleHex(float f, char *str)
+{
+	double d = double(f);
+	const u_int8_t *buf = (const u_int8_t*)&d;
+	getStringHex(buf, sizeof(d), str);
+}
+
+
+void GetFloatHex(float f, char *str)
+{
+	float d = f;
+	const u_int8_t *buf = (const u_int8_t*)&d;
+	getStringHex(buf, sizeof(d), str);
+}
+
+
+void GetTransformHex(float m[4][4], char *buf)
+{
+	TraceTransform tm;
+	copy_m3_m4(tm.m, m);
+	copy_v3db_v3fl(tm.v, m[3]);
+
+	const u_int8_t *tm8 = (const u_int8_t*)&tm;
+	getStringHex(tm8, sizeof(tm), buf);
+}
diff --git a/source/blender/vray_for_blender/vrscene_exporter/vrscene.h b/source/blender/vray_for_blender/vrscene_exporter/vrscene.h
new file mode 100644
index 0000000..89ee127
--- /dev/null
+++ b/source/blender/vray_for_blender/vrscene_exporter/vrscene.h
@@ -0,0 +1,151 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2010 Blender Foundation.
+ * All rights reserved.
+ *
+ * Contributor(s): Andrei Izrantcev <andrei.izrantcev@chaosgroup.com>
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#ifndef VRSCENE_H
+#define VRSCENE_H
+
+#include "CGR_config.h"
+
+#include <math.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "blender_includes.h"
+
+#ifdef __cplusplus
+}
+#endif
+
+#include <Python.h>
+
+#define MAX_PLUGIN_NAME  1024
+
+#define COPY_VECTOR_3_3(a, b) \
+	a[0] = b[0];\
+	a[1] = b[1];\
+	a[2] = b[2];
+
+#define HEX(x) htonl(*(int*)&(x))
+#define WRITE_HEX_VALUE(f, v) fprintf(f, "%08X", HEX(v));
+#define WRITE_HEX_VECTOR(f, v) fprintf(f, "%08X%08X%08X", HEX(v[0]), HEX(v[1]), HEX(v[2]))
+
+#if CGR_USE_HEX
+#define WRITE_TRANSFORM(f, m) fprintf(f, "TransformHex(\"%s\")", GetTransformHex(m));
+#else
+#define WRITE_TRANSFORM(f, m) fprintf(f, "Transform(Matrix(Vector(%f, %f, %f),Vector(%f, %f, %f),Vector(%f, %f, %f)),Vector(%f, %f, %f))", \
+	m[0][0], m[0][1], m[0][2],\
+	m[1][0], m[1][1], m[1][2],\
+	m[2][0], m[2][1], m[2][2],\
+	m[3][0], m[3][1], m[3][2]);
+#endif
+
+#define WRITE_HEX_QUADFACE(f, face) fprintf(gfile, "%08X%08X%08X%08X%08X%08X", HEX(face->v1), HEX(face->v2), HEX(face->v3), HEX(face->v3), HEX(face->v4), HEX(face->v1))
+#define WRITE_HEX_TRIFACE(f, face)  fprintf(gfile, "%08X%08X%08X", HEX(face->v1), HEX(face->v2), HEX(face->v3))
+
+#define WRITE_PYOBJECT_BUF(pyObject) \
+	PyObject_CallMethod(pyObject, (char*)"write", (char*)"s", buf);
+
+#define WRITE_PYOBJECT(pyObject, ...) \
+	sprintf(buf, __VA_ARGS__); \
+	WRITE_PYOBJECT_BUF(pyObject);
+
+#define WRITE_PYOBJECT_HEX_VALUE(pyObject, v) \
+	sprintf(buf, "%08X", HEX(v)); \
+	WRITE_PYOBJECT_BUF(pyObject);
+
+#define WRITE_PYOBJECT_HEX_VECTOR(pyObject, v) \
+	sprintf(buf, "%08X%08X%08X", HEX(v[0]), HEX(v[1]), HEX(v[2])); \
+	WRITE_PYOBJECT_BUF(pyObject);
+
+#define WRITE_PYOBJECT_HEX_QUADFACE(pyObject, face) \
+	sprintf(buf, "%08X%08X%08X%08X%08X%08X", HEX(face->v1), HEX(face->v2), HEX(face->v3), HEX(face->v3), HEX(face->v4), HEX(face->v1));\
+	WRITE_PYOBJECT_BUF(pyObject);
+
+#define WRITE_PYOBJECT_HEX_TRIFACE(pyObject, face) \
+	sprintf(buf, "%08X%08X%08X", HEX(face->v1), HEX(face->v2), HEX(face->v3)); \
+	WRITE_PYOBJECT_BUF(pyObject);
+
+#if CGR_USE_HEX
+#define WRITE_PYOBJECT_TRANSFORM(pyObject, m) \
+	{\
+		char tmBuf[130];\
+		GetTransformHex(m, tmBuf);\
+		sprintf(buf, "TransformHex(\"%s\")", tmBuf);\
+		WRITE_PYOBJECT_BUF(pyObject);\
+	}
+#else
+#define WRITE_PYOBJECT_TRANSFORM(pyObject, m) \
+	sprintf(buf, "Transform(Matrix(Vector(%f, %f, %f),Vector(%f, %f, %f),Vector(%f, %f, %f)),Vector(%f, %f, %f))", \
+		m[0][0], m[0][1], m[0][2],\
+		m[1][0], m[1][1], m[1][2],\
+		m[2][0], m[2][1], m[2][2],\
+		m[3][0], m[3][1], m[3][2]); \
+	WRITE_PYOBJECT_BUF(pyObject);
+#endif
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void  GetDoubleHex(float f, char *str);
+void  GetFloatHex(float f, char *buf);
+void  GetTransformHex(float m[4][4], char *buf);
+
+int   write_GeomMayaHair(PyObject *outputFile, Scene *sce, Main *main, Object *ob, ParticleSystem *psys, const char *pluginName);
+
+void  write_Mesh(PyObject *outputFile, Scene *sce, Object *ob, Main *main, const char *pluginName, PyObject *propGroup);
+void  write_GeomStaticMesh(PyObject *outputFile, Scene *sce, Object *ob, Mesh *mesh, const char *pluginName, PyObject *propGroup);
+
+void  write_SmokeDomain(PyObject *outputFile, Scene *sce, Object *ob, SmokeModifierData *smd, const char *pluginName, const char *lights);
+void  write_TexVoxelData(PyObject *outputFile, Scene *sce, Object *ob, SmokeModifierData *smd, const char *pluginName, short interp_type);
+
+void  write_Dupli(PyObject *nodeFile, PyObject *geomFile, Scene *sce, Main *main, Object *ob);
+void  write_ObjectNode(PyObject   *nodeFile,
+					   PyObject   *geomFile,
+					   Scene      *sce,
+					   Main       *main,
+					   Object     *ob,
+					   float       tm[4][4],
+					   const char *pluginName);
+void  write_Node(PyObject *outputFile, Scene *sce, Object *ob, const char *pluginName,
+				 const char *transform,
+				 const char *geometry,
+				 const char *material,
+				 const char *volume,
+				 const int   nsamples,
+				 const char *lights,
+				 const char *user_attributes,
+				 const int   visible,
+				 const int   objectID,
+				 const int   primary_visibility);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // VRSCENE_H
diff --git a/source/blender/windowmanager/intern/wm_window.c b/source/blender/windowmanager/intern/wm_window.c
index 6432421..bef479f 100644
--- a/source/blender/windowmanager/intern/wm_window.c
+++ b/source/blender/windowmanager/intern/wm_window.c
@@ -324,12 +324,12 @@ void wm_window_title(wmWindowManager *wm, wmWindow *win)
 		/* this is set to 1 if you don't have startup.blend open */
 		if (G.save_over && G.main->name[0]) {
 			char str[sizeof(G.main->name) + 24];
-			BLI_snprintf(str, sizeof(str), "Blender%s [%s%s]", wm->file_saved ? "" : "*", G.main->name,
-			             G.main->recovered ? " (Recovered)" : "");
+			BLI_snprintf(str, sizeof(str), "Blender For V-Ray%s [%s%s]",
+						 wm->file_saved ? "" : " *", G.main->name, G.main->recovered ? " (Recovered)" : "");
 			GHOST_SetTitle(win->ghostwin, str);
 		}
 		else
-			GHOST_SetTitle(win->ghostwin, "Blender");
+			GHOST_SetTitle(win->ghostwin, "Blender For V-Ray");
 
 		/* Informs GHOST of unsaved changes, to set window modified visual indicator (MAC OS X)
 		 * and to give hint of unsaved changes for a user warning mechanism
diff --git a/source/creator/CMakeLists.txt b/source/creator/CMakeLists.txt
index 2a355bd..e1562fa 100644
--- a/source/creator/CMakeLists.txt
+++ b/source/creator/CMakeLists.txt
@@ -1072,6 +1072,11 @@ endif()
 		list_insert_after(BLENDER_SORTED_LIBS "ge_logic_ngnetwork" "extern_bullet")
 	endif()
 
+	if(WITH_VRAY_FOR_BLENDER)
+		list_insert_after(BLENDER_SORTED_LIBS "bf_python_bmesh" "vb_exporter")
+		list_insert_after(BLENDER_SORTED_LIBS "vb_exporter" "vray_for_blender")
+	endif()
+
 	foreach(SORTLIB ${BLENDER_SORTED_LIBS})
 		set(REMLIB ${SORTLIB})
 		foreach(SEARCHLIB ${BLENDER_LINK_LIBS})
