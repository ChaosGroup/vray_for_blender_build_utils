diff --git a/blender/CMakeLists.txt b/blender/CMakeLists.txt
index f9ba78e..b4cc816 100644
--- a/blender/CMakeLists.txt
+++ b/blender/CMakeLists.txt
@@ -270,6 +270,9 @@ set(CYCLES_CUDA_BINARIES_ARCH sm_20 sm_21 sm_30 sm_35 CACHE STRING "CUDA archite
 mark_as_advanced(CYCLES_CUDA_BINARIES_ARCH)
 unset(PLATFORM_DEFAULT)
 
+# V-Ray For Blender
+option(WITH_VRAY_FOR_BLENDER		"Enable V-Ray For Blender extentions" OFF)
+
 # LLVM
 option(WITH_LLVM					"Use LLVM" OFF)
 option(LLVM_STATIC					"Link with LLVM static libraries" ON)
@@ -497,6 +500,12 @@ if(WITH_BOOL_COMPAT)
 	add_definitions(-DWITH_BOOL_COMPAT)
 endif()
 
+if(WITH_VRAY_FOR_BLENDER)
+	# set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wno-switch -std=c++0x")
+	add_definitions(-DWITH_VRAY_FOR_BLENDER)
+endif()
+
+
 #-----------------------------------------------------------------------------
 # Check for valid directories
 # ... svn extern paths can be missing because of svn-git.
@@ -2237,6 +2246,7 @@ if(FIRST_RUN)
 	info_cfg_option(WITH_INPUT_NDOF)
 	info_cfg_option(WITH_CYCLES)
 	info_cfg_option(WITH_FREESTYLE)
+	info_cfg_option(WITH_VRAY_FOR_BLENDER)
 	info_cfg_option(WITH_OPENCOLORIO)
 
 	info_cfg_text("Compiler Options:")
diff --git a/blender/SConstruct b/blender/SConstruct
index f516560..e6f61d1 100644
--- a/blender/SConstruct
+++ b/blender/SConstruct
@@ -274,6 +274,7 @@ if 'blenderlite' in B.targets:
     target_env_defs['WITH_BF_3DMOUSE'] = False
     target_env_defs['WITH_BF_LIBMV'] = False
     target_env_defs['WITH_BF_FREESTYLE'] = False
+    target_env_defs['WITH_VRAY_FOR_BLENDER'] = False
 
     # Merge blenderlite, let command line to override
     for k,v in target_env_defs.iteritems():
diff --git a/blender/build_files/scons/tools/Blender.py b/blender/build_files/scons/tools/Blender.py
index 06cc6b7..fa33f7f 100644
--- a/blender/build_files/scons/tools/Blender.py
+++ b/blender/build_files/scons/tools/Blender.py
@@ -393,6 +393,9 @@ def creator(env):
         incs.append('#/source/blender/freestyle')
         defs.append('WITH_FREESTYLE')
 
+    if env['WITH_VRAY_FOR_BLENDER']:
+        defs.append('WITH_VRAY_FOR_BLENDER')
+
     if env['OURPLATFORM'] in ('win32-vc', 'win32-mingw', 'linuxcross', 'win64-vc', 'win64-mingw'):
         incs.append(env['BF_PTHREADS_INC'])
         incs.append('#/intern/utfconv')
diff --git a/blender/build_files/scons/tools/btools.py b/blender/build_files/scons/tools/btools.py
index c542435..4b2ba0b 100644
--- a/blender/build_files/scons/tools/btools.py
+++ b/blender/build_files/scons/tools/btools.py
@@ -143,6 +143,8 @@ def validate_arguments(args, bc):
             'WITH_X11_XINPUT',
             'WITH_X11_XF86VMODE',
             'BF_GHOST_DEBUG',
+            'WITH_VRAY_FOR_BLENDER'
+            'USE_QTKIT',
             'BF_FANCY', 'BF_QUIET', 'BF_LINE_OVERWRITE',
             'BF_X264_CONFIG',
             'BF_XVIDCORE_CONFIG',
@@ -572,6 +574,8 @@ def read_opts(env, cfg, args):
         ('BF_CYCLES_CUDA_NVCC', 'CUDA nvcc compiler path', ''),
         ('BF_CYCLES_CUDA_BINARIES_ARCH', 'CUDA architectures to compile binaries for', []),
 
+        (BoolVariable('WITH_VRAY_FOR_BLENDER', 'Compile with V-Ray For Blender extentions', True)),
+
         (BoolVariable('WITH_BF_OIIO', 'Build with OpenImageIO', False)),
         (BoolVariable('WITH_BF_STATICOIIO', 'Statically link to OpenImageIO', False)),
         ('BF_OIIO', 'OIIO root path', ''),
diff --git a/blender/release/datafiles/blender_icons16.png b/blender/release/datafiles/blender_icons16.png
index 2f2f8de..43df1bc 100644
Binary files a/blender/release/datafiles/blender_icons16.png and b/blender/release/datafiles/blender_icons16.png differ
diff --git a/blender/release/datafiles/blender_icons32.png b/blender/release/datafiles/blender_icons32.png
index 8b46923..551b7d1 100644
Binary files a/blender/release/datafiles/blender_icons32.png and b/blender/release/datafiles/blender_icons32.png differ
diff --git a/blender/source/blender/CMakeLists.txt b/blender/source/blender/CMakeLists.txt
index 0d30952..5fac625 100644
--- a/blender/source/blender/CMakeLists.txt
+++ b/blender/source/blender/CMakeLists.txt
@@ -149,3 +149,6 @@ if(WITH_FREESTYLE)
 	add_subdirectory(freestyle)
 endif()
 
+if(WITH_VRAY_FOR_BLENDER)
+	add_subdirectory(vray_for_blender)
+endif()
diff --git a/blender/source/blender/SConscript b/blender/source/blender/SConscript
index de052f2..e7256d9 100644
--- a/blender/source/blender/SConscript
+++ b/blender/source/blender/SConscript
@@ -72,3 +72,6 @@ if env['WITH_BF_COMPOSITOR']:
 
 if env['WITH_BF_FREESTYLE']:
     SConscript (['freestyle/SConscript'])
+
+if env['WITH_VRAY_FOR_BLENDER']:
+    SConscript (['vray_for_blender/SConscript'])
diff --git a/blender/source/blender/blenkernel/BKE_object.h b/blender/source/blender/blenkernel/BKE_object.h
index 4341756..10153ac 100644
--- a/blender/source/blender/blenkernel/BKE_object.h
+++ b/blender/source/blender/blenkernel/BKE_object.h
@@ -155,7 +155,7 @@ void BKE_object_tfm_protected_restore(struct Object *ob,
 
 void BKE_object_handle_update(struct Scene *scene, struct Object *ob);
 void BKE_object_handle_update_ex(struct Scene *scene, struct Object *ob,
-                                 struct RigidBodyWorld *rbw);
+                                 struct RigidBodyWorld *rbw, struct Main *bmain);
 void BKE_object_sculpt_modifiers_changed(struct Object *ob);
 
 int BKE_object_obdata_texspace_get(struct Object *ob, short **r_texflag, float **r_loc, float **r_size, float **r_rot);
diff --git a/blender/source/blender/blenkernel/intern/object.c b/blender/source/blender/blenkernel/intern/object.c
index 45d9d14..43d098a 100644
--- a/blender/source/blender/blenkernel/intern/object.c
+++ b/blender/source/blender/blenkernel/intern/object.c
@@ -65,6 +65,7 @@
 #include "BLI_utildefines.h"
 #include "BLI_linklist.h"
 #include "BLI_kdtree.h"
+#include "BLI_callbacks.h"
 
 #include "BLF_translation.h"
 
@@ -2689,7 +2690,7 @@ bool BKE_object_parent_loop_check(const Object *par, const Object *ob)
 /* requires flags to be set! */
 /* Ideally we shouldn't have to pass the rigid body world, but need bigger restructuring to avoid id */
 void BKE_object_handle_update_ex(Scene *scene, Object *ob,
-                                 RigidBodyWorld *rbw)
+                                 RigidBodyWorld *rbw, Main *bmain)
 {
 	if (ob->recalc & OB_RECALC_ALL) {
 		/* speed optimization for animation lookups */
@@ -2868,9 +2869,16 @@ void BKE_object_handle_update_ex(Scene *scene, Object *ob,
 						psys_get_modifier(ob, psys)->flag &= ~eParticleSystemFlag_psys_updated;
 				}
 			}
-			
+
 			/* quick cache removed */
+
+            if(bmain)
+                BLI_callback_exec(bmain, &ob->id, BLI_CB_EVT_OBJECT_DATA_UPDATE);
 		}
+        else {
+            if(bmain)
+                BLI_callback_exec(bmain, &ob->id, BLI_CB_EVT_OBJECT_UPDATE);
+        }
 
 		ob->recalc &= ~OB_RECALC_ALL;
 	}
@@ -2895,7 +2903,7 @@ void BKE_object_handle_update_ex(Scene *scene, Object *ob,
  */
 void BKE_object_handle_update(Scene *scene, Object *ob)
 {
-	BKE_object_handle_update_ex(scene, ob, NULL);
+	BKE_object_handle_update_ex(scene, ob, NULL, NULL);
 }
 
 void BKE_object_sculpt_modifiers_changed(Object *ob)
diff --git a/blender/source/blender/blenkernel/intern/scene.c b/blender/source/blender/blenkernel/intern/scene.c
index 05e1ec8..d22dd62 100644
--- a/blender/source/blender/blenkernel/intern/scene.c
+++ b/blender/source/blender/blenkernel/intern/scene.c
@@ -1199,7 +1199,7 @@ static void scene_update_tagged_recursive(Main *bmain, Scene *scene, Scene *scen
 	for (base = scene->base.first; base; base = base->next) {
 		Object *ob = base->object;
 		
-		BKE_object_handle_update_ex(scene_parent, ob, scene->rigidbody_world);
+		BKE_object_handle_update_ex(scene_parent, ob, scene->rigidbody_world, bmain);
 		
 		if (ob->dup_group && (ob->transflag & OB_DUPLIGROUP))
 			BKE_group_handle_recalc_and_update(scene_parent, ob, ob->dup_group);
diff --git a/blender/source/blender/blenlib/BLI_callbacks.h b/blender/source/blender/blenlib/BLI_callbacks.h
index 8d5ea91..95f41f5 100644
--- a/blender/source/blender/blenlib/BLI_callbacks.h
+++ b/blender/source/blender/blenlib/BLI_callbacks.h
@@ -43,6 +43,8 @@ typedef enum {
 	BLI_CB_EVT_SAVE_POST,
 	BLI_CB_EVT_SCENE_UPDATE_PRE,
 	BLI_CB_EVT_SCENE_UPDATE_POST,
+	BLI_CB_EVT_OBJECT_UPDATE,
+	BLI_CB_EVT_OBJECT_DATA_UPDATE,
 	BLI_CB_EVT_GAME_PRE,
 	BLI_CB_EVT_GAME_POST,
 	BLI_CB_EVT_TOT
diff --git a/blender/source/blender/editors/include/UI_icons.h b/blender/source/blender/editors/include/UI_icons.h
index f8e1bbb..679250c 100644
--- a/blender/source/blender/editors/include/UI_icons.h
+++ b/blender/source/blender/editors/include/UI_icons.h
@@ -275,15 +275,16 @@ DEF_ICON(GROUP_UVS)
 DEF_ICON(RNA)
 DEF_ICON(RNA_ADD)
 
+DEF_ICON(VRAY_LOGO)
+DEF_ICON(VRAY_LOGO_MONO)
+DEF_ICON(VRAY_WORLD)
+DEF_ICON(VRAY_LIGHT)
+DEF_ICON(VRAY_MATERIAL)
+DEF_ICON(VRAY_OBJECT)
+DEF_ICON(VRAY_RENDER_LAYERS)
+
 	/* available */
 #ifndef DEF_ICON_BLANK_SKIP
-	DEF_ICON(BLANK092)
-	DEF_ICON(BLANK093)
-	DEF_ICON(BLANK094)
-	DEF_ICON(BLANK095)
-	DEF_ICON(BLANK096)
-	DEF_ICON(BLANK097)
-	DEF_ICON(BLANK098)
 	DEF_ICON(BLANK099)
 	DEF_ICON(BLANK100)
 	DEF_ICON(BLANK101)
diff --git a/blender/source/blender/python/SConscript b/blender/source/blender/python/SConscript
index 0ac0285..1fa8608 100644
--- a/blender/source/blender/python/SConscript
+++ b/blender/source/blender/python/SConscript
@@ -117,6 +117,10 @@ if env['WITH_BF_CYCLES']:
 if env['WITH_BF_CYCLES_OSL']:
     defs.append('WITH_CYCLES_OSL')
 
+if env['WITH_VRAY_FOR_BLENDER']:
+    incs += ' ../vray_for_blender'
+    defs.append('WITH_VRAY_FOR_BLENDER')
+
 if env['WITH_BF_FREESTYLE']:
     incs += ' ../freestyle/intern/python'
     defs.append('WITH_FREESTYLE')
diff --git a/blender/source/blender/python/intern/CMakeLists.txt b/blender/source/blender/python/intern/CMakeLists.txt
index ef5d26d..a054a12 100644
--- a/blender/source/blender/python/intern/CMakeLists.txt
+++ b/blender/source/blender/python/intern/CMakeLists.txt
@@ -143,6 +143,12 @@ if(WITH_CYCLES_OSL)
 	add_definitions(-DWITH_CYCLES_OSL)
 endif()
 
+if(WITH_VRAY_FOR_BLENDER)
+	list(APPEND INC
+		../../vray_for_blender
+	)
+endif()
+
 if(WITH_FREESTYLE)
 	list(APPEND INC
 		../../freestyle/intern/python
diff --git a/blender/source/blender/python/intern/bpy_app_handlers.c b/blender/source/blender/python/intern/bpy_app_handlers.c
index f8725d6..faf1b27 100644
--- a/blender/source/blender/python/intern/bpy_app_handlers.c
+++ b/blender/source/blender/python/intern/bpy_app_handlers.c
@@ -44,21 +44,23 @@ void bpy_app_generic_callback(struct Main *main, struct ID *id, void *arg);
 static PyTypeObject BlenderAppCbType;
 
 static PyStructSequence_Field app_cb_info_fields[] = {
-	{(char *)"frame_change_pre",  (char *)"Callback list - on frame change for playback and rendering (before)"},
-	{(char *)"frame_change_post", (char *)"Callback list - on frame change for playback and rendering (after)"},
-	{(char *)"render_pre",        (char *)"Callback list - on render (before)"},
-	{(char *)"render_post",       (char *)"Callback list - on render (after)"},
-	{(char *)"render_stats",      (char *)"Callback list - on printing render statistics"},
-	{(char *)"render_complete",   (char *)"Callback list - on completion of render job"},
-	{(char *)"render_cancel",     (char *)"Callback list - on canceling a render job"},
-	{(char *)"load_pre",          (char *)"Callback list - on loading a new blend file (before)"},
-	{(char *)"load_post",         (char *)"Callback list - on loading a new blend file (after)"},
-	{(char *)"save_pre",          (char *)"Callback list - on saving a blend file (before)"},
-	{(char *)"save_post",         (char *)"Callback list - on saving a blend file (after)"},
-	{(char *)"scene_update_pre",  (char *)"Callback list - on updating the scenes data (before)"},
-	{(char *)"scene_update_post", (char *)"Callback list - on updating the scenes data (after)"},
-	{(char *)"game_pre",          (char *)"Callback list - on starting the game engine"},
-	{(char *)"game_post",         (char *)"Callback list - on ending the game engine"},
+	{(char *)"frame_change_pre",   (char *)"Callback list - on frame change for playback and rendering (before)"},
+	{(char *)"frame_change_post",  (char *)"Callback list - on frame change for playback and rendering (after)"},
+	{(char *)"render_pre",         (char *)"Callback list - on render (before)"},
+	{(char *)"render_post",        (char *)"Callback list - on render (after)"},
+	{(char *)"render_stats",       (char *)"Callback list - on printing render statistics"},
+	{(char *)"render_complete",    (char *)"Callback list - on completion of render job"},
+	{(char *)"render_cancel",      (char *)"Callback list - on canceling a render job"},
+	{(char *)"load_pre",           (char *)"Callback list - on loading a new blend file (before)"},
+	{(char *)"load_post",          (char *)"Callback list - on loading a new blend file (after)"},
+	{(char *)"save_pre",           (char *)"Callback list - on saving a blend file (before)"},
+	{(char *)"save_post",          (char *)"Callback list - on saving a blend file (after)"},
+	{(char *)"scene_update_pre",   (char *)"Callback list - on updating the scenes data (before)"},
+	{(char *)"scene_update_post",  (char *)"Callback list - on updating the scenes data (after)"},
+	{(char *)"object_update",      (char *)"Callback list - on updating an object"},
+	{(char *)"object_data_update", (char *)"Callback list - on updating an object's data"},
+	{(char *)"game_pre",           (char *)"Callback list - on starting the game engine"},
+	{(char *)"game_post",          (char *)"Callback list - on ending the game engine"},
 
 	/* sets the permanent tag */
 #   define APP_CB_OTHER_FIELDS 1
diff --git a/blender/source/blender/python/intern/bpy_interface.c b/blender/source/blender/python/intern/bpy_interface.c
index cc1dd36..0ebb548 100644
--- a/blender/source/blender/python/intern/bpy_interface.c
+++ b/blender/source/blender/python/intern/bpy_interface.c
@@ -80,6 +80,10 @@
 #include "../bmesh/bmesh_py_api.h"
 #include "../mathutils/mathutils.h"
 
+#ifdef WITH_VRAY_FOR_BLENDER
+#include "CGR_vray_for_blender.h"
+#endif
+
 
 /* for internal use, when starting and ending python scripts */
 
@@ -209,6 +213,13 @@ static PyObject *CCL_initPython(void)
 }
 #endif
 
+#ifdef WITH_VRAY_FOR_BLENDER
+static PyObject *CGR_initPython(void)
+{
+	return (PyObject*)VRayForBlender_initPython();
+}
+#endif
+
 static struct _inittab bpy_internal_modules[] = {
 	{(char *)"mathutils", PyInit_mathutils},
 //	{(char *)"mathutils.geometry", PyInit_mathutils_geometry},
@@ -225,11 +236,15 @@ static struct _inittab bpy_internal_modules[] = {
 #ifdef WITH_CYCLES
 	{(char *)"_cycles", CCL_initPython},
 #endif
+#ifdef WITH_VRAY_FOR_BLENDER
+	{(char *)"_vray_for_blender", CGR_initPython},
+#endif
 	{(char *)"gpu", GPU_initPython},
 	{(char *)"idprop", BPyInit_idprop},
 	{NULL, NULL}
 };
 
+
 /* call BPY_context_set first */
 void BPY_python_start(int argc, const char **argv)
 {
diff --git a/blender/source/blender/python/intern/bpy_rna.c b/blender/source/blender/python/intern/bpy_rna.c
index 4d4d487..84a895c 100644
--- a/blender/source/blender/python/intern/bpy_rna.c
+++ b/blender/source/blender/python/intern/bpy_rna.c
@@ -83,7 +83,7 @@
 #  include "BLF_translation.h"
 #endif
 
-#define USE_PEDANTIC_WRITE
+// #define USE_PEDANTIC_WRITE
 #define USE_MATHUTILS
 #define USE_STRING_COERCE
 
diff --git a/blender/source/blender/vray_for_blender/CGR_config.h b/blender/source/blender/vray_for_blender/CGR_config.h
new file mode 100644
index 0000000..c9b9c7b
--- /dev/null
+++ b/blender/source/blender/vray_for_blender/CGR_config.h
@@ -0,0 +1,110 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2010 Blender Foundation.
+ * All rights reserved.
+ *
+ * Contributor(s): Andrei Izrantcev <andrei.izrantcev@chaosgroup.com>
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#ifndef CGR_CONFIG
+#define CGR_CONFIG
+
+#define PLUGIN_NAME V-Ray For Blender
+
+#define USE_COLOR        1 // For Qt Creator
+
+#define USE_DEBUG        1
+#define USE_CALL_DEBUG  (1 && USE_DEBUG)
+#define USE_TIME_DEBUG  (1 && USE_DEBUG)
+#define USE_DRAW_DEBUG  (0 && USE_DEBUG)
+
+#define CGR_USE_JOBS     0
+#define CGR_USE_RNA      0
+
+#if USE_COLOR
+#  define COLOR_RED      "\033[0;31m"
+#  define COLOR_GREEN    "\033[0;32m"
+#  define COLOR_YELLOW   "\033[0;33m"
+#  define COLOR_BLUE     "\033[0;34m"
+#  define COLOR_MAGENTA  "\033[0;35m"
+#  define COLOR_DEFAULT  "\033[0m"
+#else
+#  define COLOR_RED      ""
+#  define COLOR_GREEN    ""
+#  define COLOR_YELLOW   ""
+#  define COLOR_BLUE     ""
+#  define COLOR_MAGENTA  ""
+#  define COLOR_DEFAULT  ""
+#endif
+
+#define NOT(x) !(x)
+
+#define STRINGIZE_NX(A) #A
+#define STRINGIZE(A) STRINGIZE_NX(A)
+
+#ifdef PLUGIN_NAME
+#  define _OUTPUT_PROMPT(P) COLOR_MAGENTA STRINGIZE(P) COLOR_DEFAULT ": "
+#  define OUTPUT_PROMPT _OUTPUT_PROMPT(PLUGIN_NAME)
+#else
+#  define OUTPUT_PROMPT COLOR_MAGENTA "Info" COLOR_DEFAULT ": "
+#endif
+
+#ifdef PLUGIN_NAME
+#  define _OUTPUT_ERROR_PROMPT(P) COLOR_RED STRINGIZE(P) " Error" COLOR_DEFAULT ": "
+#  define OUTPUT_ERROR_PROMPT _OUTPUT_ERROR_PROMPT(PLUGIN_NAME)
+#else
+#  define OUTPUT_ERROR_PROMPT COLOR_RED "Error" COLOR_DEFAULT ": "
+#endif
+
+#if USE_DEBUG == 0
+#  define DEBUG_PRINT(use_debug, ...)
+#else
+#  define DEBUG_PRINT(use_debug, ...) \
+    if(use_debug) { \
+        fprintf(stdout, OUTPUT_PROMPT); \
+        fprintf(stdout, __VA_ARGS__); \
+        fprintf(stdout, "\n"); \
+    }
+#endif
+
+#define PRINT_ERROR(...) \
+    fprintf(stdout, OUTPUT_ERROR_PROMPT); \
+    fprintf(stdout, __VA_ARGS__); \
+    fprintf(stdout, "\n"); \
+	fflush(stdout);
+
+#define PRINT_INFO(...) \
+    fprintf(stdout, OUTPUT_PROMPT); \
+    fprintf(stdout, __VA_ARGS__); \
+    fprintf(stdout, "\n"); \
+	fflush(stdout);
+
+#if USE_DEBUG == 0
+#define PRINT_TM4(label, tm) ()
+#else
+#define PRINT_TM4(label, tm) \
+	PRINT_INFO("%s:", label); \
+	PRINT_INFO("  %.3f %.3f %.3f %.3f", tm[0][0], tm[0][1], tm[0][2], tm[0][3]); \
+	PRINT_INFO("  %.3f %.3f %.3f %.3f", tm[1][0], tm[1][1], tm[1][2], tm[1][3]); \
+	PRINT_INFO("  %.3f %.3f %.3f %.3f", tm[2][0], tm[2][1], tm[2][2], tm[2][3]); \
+	PRINT_INFO("  %.3f %.3f %.3f %.3f", tm[3][0], tm[3][1], tm[3][2], tm[3][3]);
+#endif
+
+#endif // CGR_CONFIG
diff --git a/blender/source/blender/vray_for_blender/CGR_vray_for_blender.h b/blender/source/blender/vray_for_blender/CGR_vray_for_blender.h
new file mode 100644
index 0000000..44d1cd7
--- /dev/null
+++ b/blender/source/blender/vray_for_blender/CGR_vray_for_blender.h
@@ -0,0 +1,39 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2010 Blender Foundation.
+ * All rights reserved.
+ *
+ * Contributor(s): Andrei Izrantcev <andrei.izrantcev@chaosgroup.com>
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#ifndef CGR_VRAY_FOR_BLENDER_H
+#define CGR_VRAY_FOR_BLENDER_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void* VRayForBlender_initPython(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // CGR_VRAY_FOR_BLENDER_H
diff --git a/blender/source/blender/vray_for_blender/CMakeLists.txt b/blender/source/blender/vray_for_blender/CMakeLists.txt
new file mode 100644
index 0000000..bf2b557
--- /dev/null
+++ b/blender/source/blender/vray_for_blender/CMakeLists.txt
@@ -0,0 +1,50 @@
+include_directories(/home/bdancer/devel/globals/include)
+
+set(INC_SYS
+	${PYTHON_INCLUDE_DIRS}
+)
+
+set(INC
+	.
+	./common
+	../blenlib
+	../blenkernel
+	../blenloader
+	../makesdna
+	../makesrna
+	../imbuf
+	../windowmanager
+	../editors/include
+	../render/extern/include
+	../render/intern/include
+	${CMAKE_BINARY_DIR}/source/blender/makesrna/intern
+	../../../intern/guardedalloc
+	../../../intern/smoke/extern
+)
+
+set(SRC
+	CGR_config.h
+
+	# Common stuff
+	common/blender_includes.h
+	utils/CGR_rna.h
+	utils/CGR_rna.cpp
+	utils/CGR_data.h
+	utils/CGR_data.c
+	utils/CGR_string.h
+	utils/CGR_string.c
+
+	# vrscene export
+	vrscene_exporter/vrscene.h
+	vrscene_exporter/node.c
+	vrscene_exporter/geom.c
+	vrscene_exporter/hair.c
+	vrscene_exporter/smoke.cpp
+
+	python/vray_python_ext.cpp
+
+	# C API
+	CGR_vray_for_blender.h
+)
+
+blender_add_lib(vray_for_blender "${SRC}" "${INC}" "${INC_SYS}")
diff --git a/blender/source/blender/vray_for_blender/SConscript b/blender/source/blender/vray_for_blender/SConscript
new file mode 100644
index 0000000..3307d69
--- /dev/null
+++ b/blender/source/blender/vray_for_blender/SConscript
@@ -0,0 +1,50 @@
+#!/usr/bin/python
+
+Import('env')
+
+sources = [
+    './python/vray_python_ext.cpp',
+    './utils/CGR_data.c',
+    './utils/CGR_rna.cpp',
+    './utils/CGR_string.c',
+    './vrscene_exporter/geom.c',
+    './vrscene_exporter/hair.c',
+    './vrscene_exporter/node.c',
+    './vrscene_exporter/smoke.cpp',
+]
+
+includes = [
+    '../../../intern/guardedalloc',
+    '../../../intern/smoke/extern',
+    '../../../intern/smoke/extern',
+    '../blenkernel',
+    '../blenlib',
+    '../blenloader',
+    '../makesdna',
+    '../makesrna',
+    '../render/extern/include',
+    '../render/intern/include',
+    '../windowmanager',
+    '../python',
+    '../python/intern',
+    './common',
+    './python',
+    './utils',
+    './vrscene_exporter',
+    './',
+]
+
+includes.extend(env['BF_PYTHON_INC'].split())
+includes.append(env['BF_BOOST_INC'])
+
+if env['OURPLATFORM'] in ('win32-vc', 'win32-mingw', 'linuxcross', 'win64-vc'):
+    includes.append(env['BF_PTHREADS_INC'])
+
+env.BlenderLib(
+    libname  = 'vray_for_blender',
+    sources  = sources,
+    includes = includes,
+    defines  = [],
+    libtype  = ['core'],
+    priority = [600]
+)
diff --git a/blender/source/blender/vray_for_blender/common/blender_includes.h b/blender/source/blender/vray_for_blender/common/blender_includes.h
new file mode 100644
index 0000000..4dab252
--- /dev/null
+++ b/blender/source/blender/vray_for_blender/common/blender_includes.h
@@ -0,0 +1,124 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2010 Blender Foundation.
+ * All rights reserved.
+ *
+ * Contributor(s): Andrei Izrantcev <andrei.izrantcev@chaosgroup.com>
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#ifndef BLENDER_INCLUDES_H
+#define BLENDER_INCLUDES_H
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include <pthread.h>
+#include <time.h>
+#include <ctype.h>
+
+#include "BLI_linklist.h"
+#include "BLI_listbase.h"
+#include "BLI_math.h"
+#include "BLI_path_util.h"
+#include "BLI_string.h"
+#include "BLI_threads.h"
+#include "BLI_voxel.h"
+#include "BLI_utildefines.h"
+#include "BLI_math_matrix.h"
+#include "BLI_math_vector.h"
+#include "BLI_math_rotation.h"
+#include "BLI_fileops.h"
+
+#include "BKE_main.h"
+#include "BKE_scene.h"
+#include "BKE_context.h"
+#include "BKE_utildefines.h"
+#include "BKE_library.h"
+#include "BKE_DerivedMesh.h"
+#include "BKE_fcurve.h"
+#include "BKE_anim.h"
+#include "BKE_animsys.h"
+#include "BKE_particle.h"
+#include "BKE_pointcache.h"
+#include "BKE_global.h"
+#include "BKE_report.h"
+#include "BKE_object.h"
+#include "BKE_mesh.h"
+#include "BKE_curve.h"
+#include "BKE_bvhutils.h"
+#include "BKE_customdata.h"
+#include "BKE_anim.h"
+#include "BKE_depsgraph.h"
+#include "BKE_displist.h"
+#include "BKE_font.h"
+#include "BKE_mball.h"
+#include "BKE_modifier.h"
+#include "BKE_material.h"
+#include "BKE_texture.h"
+
+#include "DNA_scene_types.h"
+#include "DNA_object_types.h"
+#include "DNA_group_types.h"
+#include "DNA_meshdata_types.h"
+#include "DNA_mesh_types.h"
+#include "DNA_meta_types.h"
+#include "DNA_image_types.h"
+#include "DNA_material_types.h"
+#include "DNA_texture_types.h"
+#include "DNA_camera_types.h"
+#include "DNA_lamp_types.h"
+#include "DNA_anim_types.h"
+#include "DNA_action_types.h"
+#include "DNA_curve_types.h"
+#include "DNA_armature_types.h"
+#include "DNA_modifier_types.h"
+#include "DNA_windowmanager_types.h"
+#include "DNA_particle_types.h"
+#include "DNA_smoke_types.h"
+#include "DNA_listBase.h"
+
+#include "render_types.h"
+#include "RE_engine.h"
+
+#include "PIL_time.h"
+
+#include "RNA_access.h"
+#include "RNA_define.h"
+
+#ifdef WIN32
+#  ifdef htonl
+#    undef htonl
+#    undef htons
+#    undef ntohl
+#    undef ntohs
+#    define correctByteOrder(x) htonl(x)
+#  endif
+#  include <winsock.h>
+#else
+#  include <netinet/in.h>
+#endif
+
+#include "WM_api.h"
+#include "WM_types.h"
+
+#include "MEM_guardedalloc.h"
+
+#endif // BLENDER_INCLUDES_H
diff --git a/blender/source/blender/vray_for_blender/python/vray_python_ext.cpp b/blender/source/blender/vray_for_blender/python/vray_python_ext.cpp
new file mode 100644
index 0000000..3473b5d
--- /dev/null
+++ b/blender/source/blender/vray_for_blender/python/vray_python_ext.cpp
@@ -0,0 +1,193 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2010 Blender Foundation.
+ * All rights reserved.
+ *
+ * Contributor(s): Andrei Izrantcev <andrei.izrantcev@chaosgroup.com>
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#include "CGR_config.h"
+
+extern "C" {
+#include "blender_includes.h"
+}
+
+#include "vrscene_exporter/vrscene.h"
+#include "CGR_vray_for_blender.h"
+
+#include <Python.h>
+
+
+static PyObject* mExportSmokeDomain(PyObject *self, PyObject *args)
+{
+	int         contextPtr;
+	int         objectPtr;
+	int         smdPtr;
+	const char *pluginName;
+	const char *lights;
+	PyObject   *fileObject;
+
+	if(NOT(PyArg_ParseTuple(args, "iiissO", &contextPtr, &objectPtr, &smdPtr, &pluginName, &lights, &fileObject))) {
+		return NULL;
+	}
+
+	bContext          *C   = (bContext*)(intptr_t)contextPtr;
+	Object            *ob  = (Object*)(intptr_t)objectPtr;
+	SmokeModifierData *smd = (SmokeModifierData*)(intptr_t)smdPtr;
+
+	Scene *sce = CTX_data_scene(C);
+
+	write_SmokeDomain(fileObject, sce, ob, smd, pluginName, lights);
+
+	Py_RETURN_NONE;
+}
+
+
+static PyObject* mExportSmoke(PyObject *self, PyObject *args)
+{
+	int         contextPtr;
+	int         objectPtr;
+	int         smdPtr;
+	const char *pluginName;
+	PyObject   *fileObject;
+	
+	int         p_interpolation;
+
+	if(NOT(PyArg_ParseTuple(args, "iiiisO", &contextPtr, &objectPtr, &smdPtr, &p_interpolation, &pluginName, &fileObject))) {
+		return NULL;
+	}
+
+	bContext          *C   = (bContext*)(intptr_t)contextPtr;
+	Object            *ob  = (Object*)(intptr_t)objectPtr;
+	SmokeModifierData *smd = (SmokeModifierData*)(intptr_t)smdPtr;
+
+	Scene *sce = CTX_data_scene(C);
+
+	write_TexVoxelData(fileObject, sce, ob, smd, pluginName, p_interpolation);
+
+	Py_RETURN_NONE;
+}
+
+
+static PyObject* mExportHair(PyObject *self, PyObject *args)
+{
+	int         contextPtr;
+	int         objectPtr;
+	int         psysPtr;
+	const char *pluginName;
+	PyObject   *fileObject;
+
+	if(NOT(PyArg_ParseTuple(args, "iiisO", &contextPtr, &objectPtr, &psysPtr, &pluginName, &fileObject))) {
+		return NULL;
+	}
+
+	bContext       *C    = (bContext*)(intptr_t)contextPtr;
+	Object         *ob   = (Object*)(intptr_t)objectPtr;
+	ParticleSystem *psys = (ParticleSystem*)(intptr_t)psysPtr;
+
+	Scene *sce  = CTX_data_scene(C);
+	Main  *main = CTX_data_main(C);
+
+	if(write_GeomMayaHair(fileObject, sce, main, ob, psys, pluginName)) {
+		return NULL;
+	}
+
+	Py_RETURN_NONE;
+}
+
+
+static PyObject* mExportMesh(PyObject *self, PyObject *args)
+{
+	int         contextPtr;
+	int         objectPtr;
+	const char *pluginName;
+	PyObject   *propGroup;
+	PyObject   *fileObject;
+
+	if(NOT(PyArg_ParseTuple(args, "iisOO", &contextPtr, &objectPtr, &pluginName, &propGroup, &fileObject))) {
+		return NULL;
+	}
+
+	bContext *C = (bContext*)(intptr_t)contextPtr;
+	Object   *ob = (Object*)(intptr_t)objectPtr;
+
+	Scene *sce  = CTX_data_scene(C);
+	Main  *main = CTX_data_main(C);
+
+	write_Mesh(fileObject, sce, ob, main, pluginName, propGroup);
+
+	Py_RETURN_NONE;
+}
+
+
+static PyObject* mExportNode(PyObject *self, PyObject *args)
+{
+	Py_RETURN_NONE;
+}
+
+
+static PyObject* mExportDupli(PyObject *self, PyObject *args)
+{
+	int       contextPtr;
+	int       objectPtr;
+	PyObject *nodeFile;
+	PyObject *geomFile;
+
+	if(NOT(PyArg_ParseTuple(args, "iiOO", &contextPtr, &objectPtr, &nodeFile, &geomFile))) {
+		return NULL;
+	}
+
+	bContext *C = (bContext*)(intptr_t)contextPtr;
+	Object *ob  = (Object*)(intptr_t)objectPtr;
+
+	Scene *sce  = CTX_data_scene(C);
+	Main  *main = CTX_data_main(C);
+	
+	write_Dupli(nodeFile, geomFile, sce, main, ob);
+	
+	Py_RETURN_NONE;
+}
+
+
+static PyMethodDef methods[] = {
+	{"exportDupli",       mExportDupli,       METH_VARARGS, "Export dupli / particles"},
+	{"exportMesh",        mExportMesh,        METH_VARARGS, "Export mesh"},
+	{"exportSmoke",       mExportSmoke,       METH_VARARGS, "Export voxel data"},
+	{"exportSmokeDomain", mExportSmokeDomain, METH_VARARGS, "Export domain data"},
+	{"exportHair",        mExportHair,        METH_VARARGS, "Export hair"},
+	{"exportNode",        mExportNode,        METH_VARARGS, "Export Node description"},
+	{NULL, NULL, 0, NULL},
+};
+
+
+static struct PyModuleDef module = {
+	PyModuleDef_HEAD_INIT,
+	"_vray_for_blender",
+	"V-Ray For Blender export helper module",
+	-1,
+	methods,
+	NULL, NULL, NULL, NULL
+};
+
+
+void* VRayForBlender_initPython()
+{
+	return (void*)PyModule_Create(&module);
+}
diff --git a/blender/source/blender/vray_for_blender/utils/CGR_data.c b/blender/source/blender/vray_for_blender/utils/CGR_data.c
new file mode 100644
index 0000000..d39ffd4
--- /dev/null
+++ b/blender/source/blender/vray_for_blender/utils/CGR_data.c
@@ -0,0 +1,116 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2010 Blender Foundation.
+ * All rights reserved.
+ *
+ * Contributor(s): Andrei Izrantcev <andrei.izrantcev@chaosgroup.com>
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#include "CGR_data.h"
+
+
+Mesh* GetRenderMesh(Scene *sce, Main *bmain, Object *ob)
+{
+    Mesh *tmpmesh;
+    Curve *tmpcu = NULL, *copycu;
+    Object *tmpobj = NULL;
+    Object *basis_ob = NULL;
+    ListBase disp = {NULL, NULL};
+
+    /* Make a dummy mesh, saves copying */
+    DerivedMesh *dm;
+
+    CustomDataMask mask = CD_MASK_MESH;
+
+    /* perform the mesh extraction based on type */
+    switch (ob->type) {
+    case OB_FONT:
+    case OB_CURVE:
+    case OB_SURF:
+        /* copies object and modifiers (but not the data) */
+        tmpobj = BKE_object_copy(ob);
+        tmpcu = (Curve*)tmpobj->data;
+        tmpcu->id.us--;
+
+        /* copies the data */
+        tmpobj->data = BKE_curve_copy((Curve*)ob->data);
+        copycu = (Curve*)tmpobj->data;
+
+        /* temporarily set edit so we get updates from edit mode, but
+         * also because for text datablocks copying it while in edit
+         * mode gives invalid data structures */
+        copycu->editfont = tmpcu->editfont;
+        copycu->editnurb = tmpcu->editnurb;
+
+        /* get updated display list, and convert to a mesh */
+        BKE_displist_make_curveTypes( sce, tmpobj, 0 );
+
+        copycu->editfont = NULL;
+        copycu->editnurb = NULL;
+
+        BKE_mesh_from_nurbs( tmpobj );
+
+        /* nurbs_to_mesh changes the type to a mesh, check it worked */
+        if (tmpobj->type != OB_MESH) {
+            BKE_libblock_free_us( &(G.main->object), tmpobj );
+            return NULL;
+        }
+        tmpmesh = (Mesh*)tmpobj->data;
+        BKE_libblock_free_us( &G.main->object, tmpobj );
+
+        break;
+
+    case OB_MBALL:
+        /* metaballs don't have modifiers, so just convert to mesh */
+        basis_ob = BKE_mball_basis_find(sce, ob);
+
+        if (ob != basis_ob)
+            return NULL; /* only do basis metaball */
+
+        tmpmesh = BKE_mesh_add(bmain, "Mesh");
+
+        BKE_displist_make_mball_forRender(sce, ob, &disp);
+        BKE_mesh_from_metaball(&disp, tmpmesh);
+        BKE_displist_free(&disp);
+
+        break;
+
+    case OB_MESH:
+        /* Write the render mesh into the dummy mesh */
+        dm = mesh_create_derived_render(sce, ob, mask);
+
+        tmpmesh = BKE_mesh_add(bmain, "Mesh");
+        DM_to_mesh(dm, tmpmesh, ob, mask);
+        dm->release(dm);
+
+        break;
+
+    default:
+        return NULL;
+    }
+
+    /* cycles and exporters rely on this still */
+    BKE_mesh_tessface_ensure(tmpmesh);
+
+    /* we don't assign it to anything */
+    tmpmesh->id.us--;
+
+    return tmpmesh;
+}
diff --git a/blender/source/blender/vray_for_blender/utils/CGR_data.h b/blender/source/blender/vray_for_blender/utils/CGR_data.h
new file mode 100644
index 0000000..57533df
--- /dev/null
+++ b/blender/source/blender/vray_for_blender/utils/CGR_data.h
@@ -0,0 +1,42 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2010 Blender Foundation.
+ * All rights reserved.
+ *
+ * Contributor(s): Andrei Izrantcev <andrei.izrantcev@chaosgroup.com>
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#ifndef CGR_BLENDER_UTILS_H
+#define CGR_BLENDER_UTILS_H
+
+#include "blender_includes.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+Mesh* GetRenderMesh(Scene *sce, Main *bmain, Object *ob);
+bool  IsGeometryType(Object *ob);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif // CGR_BLENDER_UTILS_H
diff --git a/blender/source/blender/vray_for_blender/utils/CGR_rna.cpp b/blender/source/blender/vray_for_blender/utils/CGR_rna.cpp
new file mode 100644
index 0000000..4b4a88c
--- /dev/null
+++ b/blender/source/blender/vray_for_blender/utils/CGR_rna.cpp
@@ -0,0 +1,158 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2010 Blender Foundation.
+ * All rights reserved.
+ *
+ * Contributor(s): Andrei Izrantcev <andrei.izrantcev@chaosgroup.com>
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#include "CGR_config.h"
+#include "CGR_rna.h"
+
+#include <stdio.h>
+
+#include <string>
+#include <vector>
+
+#include <boost/algorithm/string.hpp>
+#include <boost/algorithm/string/classification.hpp>
+
+
+using namespace RnaAccess;
+
+
+typedef std::vector<std::string> PathRNA;
+
+
+RnaValue::RnaValue(ID *id, const char *rnaPointerPath)
+{
+    m_path = rnaPointerPath;
+
+    PathRNA rnaPath;
+    boost::split(rnaPath, m_path, boost::is_any_of("."));
+
+    DEBUG_PRINT(0, "Initing RnaValue for path = %s", rnaPointerPath);
+
+    RNA_id_pointer_create(id, &m_pointer);
+
+    size_t nTokens = rnaPath.size();
+    for(size_t t = 0; t < nTokens; ++t) {
+        if(NOT(RNA_struct_find_property(&m_pointer, rnaPath[t].c_str()))) {
+            m_pointer = PointerRNA_NULL;
+            break;
+        }
+        m_pointer = RNA_pointer_get(&m_pointer, rnaPath[t].c_str());
+    }
+}
+
+
+int RnaValue::CheckProperty(const char *propName)
+{
+    if(m_pointer.data == NULL) {
+        PRINT_ERROR("Property pointer not found!");
+        return 1;
+    }
+
+    if(NOT(RNA_struct_find_property(&m_pointer, propName))) {
+        PRINT_ERROR("Property "COLOR_YELLOW"%s"COLOR_DEFAULT" not found!", propName);
+        return 2;
+    }
+
+    return 0;
+}
+
+
+int RnaValue::GetValue(const char *propName, int &value)
+{
+    if(CheckProperty(propName)) {
+        return 1;
+    }
+
+    value = RNA_int_get(&m_pointer, propName);
+
+    DEBUG_PRINT(0,
+                COLOR_BLUE"%s"COLOR_DEFAULT"."COLOR_GREEN"%s"COLOR_DEFAULT" = "COLOR_YELLOW"%i"COLOR_DEFAULT,
+                m_path.c_str(), propName, value);
+
+    return 0;
+}
+
+
+int RnaValue::GetValue(const char *propName, bool &value)
+{
+    if(CheckProperty(propName)) {
+        return 1;
+    }
+
+    value = RNA_boolean_get(&m_pointer, propName);
+
+    DEBUG_PRINT(0,
+                COLOR_BLUE"%s"COLOR_DEFAULT"."COLOR_GREEN"%s"COLOR_DEFAULT" = "COLOR_YELLOW"%s"COLOR_DEFAULT,
+                m_path.c_str(), propName, value ? "True" : "False");
+
+    return 0;
+}
+
+
+int RnaValue::GetValue(const char *propName, float &value)
+{
+    if(CheckProperty(propName)) {
+        return 1;
+    }
+
+    value = RNA_float_get(&m_pointer, propName);
+
+    DEBUG_PRINT(0,
+                COLOR_BLUE"%s"COLOR_DEFAULT"."COLOR_GREEN"%s"COLOR_DEFAULT" = "COLOR_YELLOW"%.3f"COLOR_DEFAULT,
+                m_path.c_str(), propName, value);
+
+    return 0;
+}
+
+
+// Usage:
+//   char value[MAX_ID_NAME - 2];
+//
+int RnaValue::GetValue(const char *propName, char *value)
+{
+    if(CheckProperty(propName)) {
+        return 1;
+    }
+
+    RNA_string_get(&m_pointer, propName, value);
+
+    DEBUG_PRINT(0,
+                COLOR_BLUE"%s"COLOR_DEFAULT"."COLOR_GREEN"%s"COLOR_DEFAULT" = "COLOR_YELLOW"%s"COLOR_DEFAULT,
+                m_path.c_str(), propName, value);
+
+    return 0;
+}
+
+
+int RnaValue::GetValue(const char *propName, float value[])
+{
+    if(CheckProperty(propName)) {
+        return 1;
+    }
+
+    RNA_float_get_array(&m_pointer, propName, value);
+
+    return 0;
+}
diff --git a/blender/source/blender/vray_for_blender/utils/CGR_rna.h b/blender/source/blender/vray_for_blender/utils/CGR_rna.h
new file mode 100644
index 0000000..39bffca
--- /dev/null
+++ b/blender/source/blender/vray_for_blender/utils/CGR_rna.h
@@ -0,0 +1,58 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2010 Blender Foundation.
+ * All rights reserved.
+ *
+ * Contributor(s): Andrei Izrantcev <andrei.izrantcev@chaosgroup.com>
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#ifndef CGR_UTILS_RNA_H
+#define CGR_UTILS_RNA_H
+
+extern "C" {
+#include "RNA_access.h"
+}
+
+#include <string>
+
+
+namespace RnaAccess {
+
+class RnaValue {
+public:
+    RnaValue(ID *id, const char *rnaPointerPath);
+
+    int          GetValue(const char *propName, int   &value);
+    int          GetValue(const char *propName, bool  &value);
+    int          GetValue(const char *propName, float &value);
+    int          GetValue(const char *propName, char  *value);
+    int          GetValue(const char *propName, float  value[3]);
+
+private:
+    int          CheckProperty(const char *propName);
+
+    std::string  m_path;
+    PointerRNA   m_pointer;
+
+};
+
+}
+
+#endif // CGR_UTILS_RNA_H
diff --git a/blender/source/blender/vray_for_blender/utils/CGR_string.c b/blender/source/blender/vray_for_blender/utils/CGR_string.c
new file mode 100644
index 0000000..d1bb803
--- /dev/null
+++ b/blender/source/blender/vray_for_blender/utils/CGR_string.c
@@ -0,0 +1,45 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2010 Blender Foundation.
+ * All rights reserved.
+ *
+ * Contributor(s): Andrei Izrantcev <andrei.izrantcev@chaosgroup.com>
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#include "CGR_string.h"
+#include <string.h>
+
+
+void StripString(char *str)
+{
+	int nChars = strlen(str);
+	int i      = 0;
+
+	for(i = 0; i < nChars; i++) {
+		if(str[i]) {
+			if(str[i] == '+')
+				str[i] = 'p';
+			else if(str[i] == '-')
+				str[i] = 'm';
+			else if(!((str[i] >= 'A' && str[i] <= 'Z') || (str[i] >= 'a' && str[i] <= 'z') || (str[i] >= '0' && str[i] <= '9')))
+				str[i] = '_';
+		}
+	}
+}
diff --git a/blender/source/blender/vray_for_blender/utils/CGR_string.h b/blender/source/blender/vray_for_blender/utils/CGR_string.h
new file mode 100644
index 0000000..39fd5db
--- /dev/null
+++ b/blender/source/blender/vray_for_blender/utils/CGR_string.h
@@ -0,0 +1,31 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2010 Blender Foundation.
+ * All rights reserved.
+ *
+ * Contributor(s): Andrei Izrantcev <andrei.izrantcev@chaosgroup.com>
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#ifndef CGR_STRING_H
+#define CGR_STRING_H
+
+void StripString(char *str);
+
+#endif // CGR_STRING_H
diff --git a/blender/source/blender/vray_for_blender/vrscene_exporter/geom.c b/blender/source/blender/vray_for_blender/vrscene_exporter/geom.c
new file mode 100644
index 0000000..c494035
--- /dev/null
+++ b/blender/source/blender/vray_for_blender/vrscene_exporter/geom.c
@@ -0,0 +1,357 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2010 Blender Foundation.
+ * All rights reserved.
+ *
+ * Contributor(s): Andrei Izrantcev <andrei.izrantcev@chaosgroup.com>
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#include "utils/CGR_data.h"
+
+#include "vrscene.h"
+
+
+static void WritePythonAttribute(PyObject *outputFile, PyObject *propGroup, const char *attrName)
+{
+	static char buf[MAX_PLUGIN_NAME];
+
+	PyObject *attr      = NULL;
+	PyObject *attrValue = NULL;
+
+	if(propGroup == Py_None)
+		return;
+
+	attr      = PyObject_GetAttrString(propGroup, attrName);
+	attrValue = PyNumber_Long(attr);
+
+	if(attrValue) {
+		WRITE_PYOBJECT(outputFile, "\n\t%s=%li;", attrName, PyLong_AsLong(attrValue));
+	}
+}
+
+
+static int write_edge_visibility(PyObject *outputFile, int k, unsigned long int *ev)
+{
+	static char buf[MAX_PLUGIN_NAME];
+
+	if(k == 9) {
+		WRITE_PYOBJECT_HEX_VALUE(outputFile, *ev);
+		*ev= 0;
+		return 0;
+	}
+
+	return k + 1;
+}
+
+
+void write_GeomStaticMesh(PyObject *outputFile, Scene *sce, Object *ob, Mesh *mesh, const char *pluginName, PyObject *propGroup)
+{
+	static char buf[MAX_PLUGIN_NAME];
+
+	Mesh   *data = ob->data;
+	MFace  *face;
+	MTFace *mtface;
+	MCol   *mcol;
+	MVert  *vert;
+	MEdge  *edge;
+
+	CustomData *fdata;
+
+	int    verts;
+	int    fve[4];
+	float *ve[4];
+	float  no[3];
+	float  col[3];
+
+	float  fno[3];
+	float  n0[3], n1[3], n2[3], n3[3];
+
+	int    matid       = 0;
+	int    uv_count    = 0;
+	int    uv_layer_id = 1;
+
+	PointerRNA   rna_me;
+	PointerRNA   VRayMesh;
+	PointerRNA   GeomStaticMesh;
+
+	int          dynamic_geometry= 0;
+
+	const int ft[6]= {0,1,2,2,3,0};
+
+	unsigned long int ev= 0;
+
+	int i, j, f, k, l;
+	int u;
+
+	if(!(mesh->totface)) {
+		PRINT_ERROR( "No faces in mesh \"%s\"", data->id.name);
+		return;
+	}
+	
+	WRITE_PYOBJECT(outputFile, "\nGeomStaticMesh %s {", pluginName);
+
+	WRITE_PYOBJECT(outputFile, "\n\tvertices=interpolate((%d,ListVectorHex(\"", sce->r.cfra);
+	vert = mesh->mvert;
+	for(f = 0; f < mesh->totvert; ++vert, ++f) {
+		WRITE_PYOBJECT_HEX_VECTOR(outputFile, vert->co);
+	}
+	WRITE_PYOBJECT(outputFile, "\")));");
+
+	// TODO: velocities (?)
+
+	WRITE_PYOBJECT(outputFile, "\n\tfaces=interpolate((%d,ListIntHex(\"", sce->r.cfra);
+	face = mesh->mface;
+	for(f = 0; f < mesh->totface; ++face, ++f) {
+		if(face->v4) {
+			WRITE_PYOBJECT_HEX_QUADFACE(outputFile, face);
+		}
+		else {
+			WRITE_PYOBJECT_HEX_TRIFACE(outputFile, face);
+		}
+	}
+	WRITE_PYOBJECT(outputFile, "\")));");
+
+	WRITE_PYOBJECT(outputFile, "\n\tnormals=interpolate((%d,ListVectorHex(\"", sce->r.cfra);
+	face = mesh->mface;
+	for(f = 0; f < mesh->totface; ++face, ++f) {
+		if(face->flag & ME_SMOOTH) {
+			normal_short_to_float_v3(n0, mesh->mvert[face->v1].no);
+			normal_short_to_float_v3(n1, mesh->mvert[face->v2].no);
+			normal_short_to_float_v3(n2, mesh->mvert[face->v3].no);
+
+			if(face->v4)
+				normal_short_to_float_v3(n3, mesh->mvert[face->v4].no);
+		}
+		else {
+			if(face->v4)
+				normal_quad_v3(fno, mesh->mvert[face->v1].co, mesh->mvert[face->v2].co, mesh->mvert[face->v3].co, mesh->mvert[face->v4].co);
+			else
+				normal_tri_v3(fno,  mesh->mvert[face->v1].co, mesh->mvert[face->v2].co, mesh->mvert[face->v3].co);
+
+			copy_v3_v3(n0, fno);
+			copy_v3_v3(n1, fno);
+			copy_v3_v3(n2, fno);
+
+			if(face->v4)
+				copy_v3_v3(n3, fno);
+		}
+
+		if(face->v4) {
+			WRITE_PYOBJECT_HEX_VECTOR(outputFile, n0);
+			WRITE_PYOBJECT_HEX_VECTOR(outputFile, n1);
+			WRITE_PYOBJECT_HEX_VECTOR(outputFile, n2);
+			WRITE_PYOBJECT_HEX_VECTOR(outputFile, n2);
+			WRITE_PYOBJECT_HEX_VECTOR(outputFile, n3);
+			WRITE_PYOBJECT_HEX_VECTOR(outputFile, n0);
+		} else {
+			WRITE_PYOBJECT_HEX_VECTOR(outputFile, n0);
+			WRITE_PYOBJECT_HEX_VECTOR(outputFile, n1);
+			WRITE_PYOBJECT_HEX_VECTOR(outputFile, n2);
+		}
+	}
+	WRITE_PYOBJECT(outputFile, "\")));");
+
+
+	WRITE_PYOBJECT(outputFile, "\n\tfaceNormals=interpolate((%d,ListIntHex(\"", sce->r.cfra);
+	face= mesh->mface;
+	k= 0;
+	for(f= 0; f < mesh->totface; ++face, ++f) {
+		if(mesh->mface[f].v4)
+			verts= 6;
+		else
+			verts= 3;
+
+		for(i= 0; i < verts; i++) {
+			WRITE_PYOBJECT(outputFile, "%08X", HEX(k));
+			k++;
+		}
+	}
+	WRITE_PYOBJECT(outputFile, "\")));");
+
+
+	WRITE_PYOBJECT(outputFile, "\n\tface_mtlIDs=ListIntHex(\"");
+	face= mesh->mface;
+	for(f= 0; f < mesh->totface; ++face, ++f) {
+		matid= face->mat_nr + 1;
+		if(face->v4) {
+			WRITE_PYOBJECT(outputFile, "%08X%08X", HEX(matid), HEX(matid));
+		}
+		else {
+			WRITE_PYOBJECT(outputFile, "%08X", HEX(matid));
+		}
+	}
+	WRITE_PYOBJECT(outputFile, "\");");
+
+//	WRITE_PYOBJECT(outputFile, "\n\tedge_creases_vertices=ListIntHex(\"");
+//	WRITE_PYOBJECT(outputFile, "\");");
+
+//	WRITE_PYOBJECT(outputFile, "\n\tedge_creases_sharpness=ListFloatHex(\"");
+//	WRITE_PYOBJECT(outputFile, "\");");
+
+	WRITE_PYOBJECT(outputFile, "\n\tedge_visibility=ListIntHex(\"");
+	ev= 0;
+	if(mesh->totface <= 5) {
+		face= mesh->mface;
+		for(f= 0; f < mesh->totface; ++face, ++f) {
+			if(face->v4) {
+				ev= (ev << 6) | 27;
+			} else {
+				ev= (ev << 3) | 8;
+			}
+		}
+		WRITE_PYOBJECT(outputFile, "%08X", HEX(ev));
+	} else {
+		k= 0;
+		face= mesh->mface;
+		for(f= 0; f < mesh->totface; ++face, ++f) {
+			if(face->v4) {
+				ev= (ev << 3) | 3;
+				k= write_edge_visibility(outputFile, k, &ev);
+				ev= (ev << 3) | 3;
+				k= write_edge_visibility(outputFile, k, &ev);
+			} else {
+				ev= (ev << 3) | 8;
+				k= write_edge_visibility(outputFile, k, &ev);
+			}
+		}
+
+		if(k) {
+			WRITE_PYOBJECT(outputFile, "%08X", HEX(ev));
+		}
+	}
+	WRITE_PYOBJECT(outputFile, "\");");
+
+
+	fdata = &mesh->fdata;
+
+	uv_count  = CustomData_number_of_layers(fdata, CD_MTFACE);
+	uv_count += CustomData_number_of_layers(fdata, CD_MCOL);
+
+	if(uv_count) {
+		WRITE_PYOBJECT(outputFile, "\n\tmap_channels_names=List(");
+		for(l = 0; l < fdata->totlayer; ++l) {
+			if(fdata->layers[l].type == CD_MTFACE || fdata->layers[l].type == CD_MCOL) {
+				WRITE_PYOBJECT(outputFile, "\"%s\"", fdata->layers[l].name);
+
+				if(l < uv_count) {
+					WRITE_PYOBJECT(outputFile, ",");
+				}
+			}
+		}
+		WRITE_PYOBJECT(outputFile, ");");
+
+		WRITE_PYOBJECT(outputFile, "\n\tmap_channels=interpolate((%d, List(", sce->r.cfra);
+		uv_layer_id = 0;
+		for(l = 0; l < fdata->totlayer; ++l) {
+			if(fdata->layers[l].type == CD_MTFACE || fdata->layers[l].type == CD_MCOL) {
+				WRITE_PYOBJECT(outputFile, "\n\t\t// Name: %s", fdata->layers[l].name);
+				WRITE_PYOBJECT(outputFile, "\n\t\tList(%i,ListVectorHex(\"", uv_layer_id++);
+
+				if(fdata->layers[l].type == CD_MTFACE) {
+					face   = mesh->mface;
+					mtface = (MTFace*)fdata->layers[l].data;
+					for(f = 0; f < mesh->totface; ++face, ++f) {
+						if(face->v4)
+							verts = 4;
+						else
+							verts = 3;
+						for(i = 0; i < verts; i++) {
+							WRITE_PYOBJECT(outputFile, "%08X%08X00000000", HEX(mtface[f].uv[i][0]), HEX(mtface[f].uv[i][1]));
+						}
+					}
+				}
+				else {
+					face = mesh->mface;
+					mcol = (MCol*)fdata->layers[l].data;
+					for(f = 0; f < mesh->totface; ++face, ++f) {
+						if(face->v4)
+							verts = 4;
+						else
+							verts = 3;
+						for(i = 0; i < verts; i++) {
+							col[0] = (float)mcol[f * 4 + i].b / 255.0;
+							col[1] = (float)mcol[f * 4 + i].g / 255.0;
+							col[2] = (float)mcol[f * 4 + i].r / 255.0;
+
+							WRITE_PYOBJECT_HEX_VECTOR(outputFile, col);
+						}
+					}
+				}
+
+				WRITE_PYOBJECT(outputFile, "\"),");
+
+				WRITE_PYOBJECT(outputFile, "ListIntHex(\"");
+				u = 0;
+				face = mesh->mface;
+				for(f = 0; f < mesh->totface; ++face, ++f) {
+					if(face->v4) {
+						WRITE_PYOBJECT(outputFile, "%08X", HEX(u));
+						k = u+1;
+						WRITE_PYOBJECT(outputFile, "%08X", HEX(k));
+						k = u+2;
+						WRITE_PYOBJECT(outputFile, "%08X", HEX(k));
+						WRITE_PYOBJECT(outputFile, "%08X", HEX(k));
+						k = u+3;
+						WRITE_PYOBJECT(outputFile, "%08X", HEX(k));
+						WRITE_PYOBJECT(outputFile, "%08X", HEX(u));
+						u += 4;
+					} else {
+						WRITE_PYOBJECT(outputFile, "%08X", HEX(u));
+						k = u+1;
+						WRITE_PYOBJECT(outputFile, "%08X", HEX(k));
+						k = u+2;
+						WRITE_PYOBJECT(outputFile, "%08X", HEX(k));
+						u += 3;
+					}
+				}
+				WRITE_PYOBJECT(outputFile, "\"))");
+
+				if(l < uv_count) {
+					WRITE_PYOBJECT(outputFile, ",");
+				}
+			}
+		}
+		WRITE_PYOBJECT(outputFile, "\n\t)));");
+	}
+
+	if(propGroup) {
+		WritePythonAttribute(outputFile, propGroup, "dynamic_geometry");
+		WritePythonAttribute(outputFile, propGroup, "osd_subdiv_level");
+	}
+
+	WRITE_PYOBJECT(outputFile, "\n}\n");
+}
+
+
+void  write_Mesh(PyObject *outputFile, Scene *sce, Object *ob, Main *main, const char *pluginName, PyObject *propGroup)
+{
+	Mesh *mesh = GetRenderMesh(sce, main, ob);
+	if(NOT(mesh)) {
+		PRINT_ERROR("Can't get render mesh!");
+		return;
+	}
+
+	write_GeomStaticMesh(outputFile, sce, ob, mesh, pluginName, propGroup);
+
+	/* remove the temporary mesh */
+	BKE_mesh_free(mesh, TRUE);
+	BLI_remlink(&main->mesh, mesh);
+	MEM_freeN(mesh);
+}
diff --git a/blender/source/blender/vray_for_blender/vrscene_exporter/hair.c b/blender/source/blender/vray_for_blender/vrscene_exporter/hair.c
new file mode 100644
index 0000000..eddf62f
--- /dev/null
+++ b/blender/source/blender/vray_for_blender/vrscene_exporter/hair.c
@@ -0,0 +1,714 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2010 Blender Foundation.
+ * All rights reserved.
+ *
+ * Contributor(s): Andrei Izrantcev <andrei.izrantcev@chaosgroup.com>
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#include "vrscene.h"
+
+
+typedef struct ParticleStrandData {
+	float *uvco;
+	int    totuv;
+} ParticleStrandData;
+
+
+// TODO: Remove! V-Ray could do it itself!
+//
+// Spline Interpolation
+//
+//  Code from: http://www.mech.uq.edu.au/staff/jacobs/nm_lib/doc/spline.html
+//
+
+// c_spline_init()
+//
+//   Evaluate the coefficients b[i], c[i], d[i], i = 0, 1, .. n-1 for
+//   a cubic interpolating spline
+//
+//   S(xx) = Y[i] + b[i] * w + c[i] * w**2 + d[i] * w**3
+//   where w = xx - x[i]
+//   and   x[i] <= xx <= x[i+1]
+//
+//   The n supplied data points are x[i], y[i], i = 0 ... n-1.
+//
+//   Input :
+//   -------
+//   n       : The number of data points or knots (n >= 2)
+//   end1,
+//   end2    : = 1 to specify the slopes at the end points
+//             = 0 to obtain the default conditions
+//   slope1,
+//   slope2  : the slopes at the end points x[0] and x[n-1]
+//             respectively
+//   x[]     : the abscissas of the knots in strictly
+//             increasing order
+//   y[]     : the ordinates of the knots
+//
+//   Output :
+//   --------
+//   b, c, d : arrays of spline coefficients as defined above
+//             (See note 2 for a definition.)
+//   iflag   : status flag
+//            = 0 normal return
+//            = 1 less than two data points; cannot interpolate
+//            = 2 x[] are not in ascending order
+//
+//   This C code written by ...  Peter & Nigel,
+//   ----------------------      Design Software,
+//                               42 Gubberley St,
+//                               Kenmore, 4069,
+//                               Australia.
+//
+//   Version ... 1.1, 30 September 1987
+//   -------     2.0, 6 April 1989    (start with zero subscript)
+//                                     remove ndim from parameter list
+//               2.1, 28 April 1989   (check on x[])
+//               2.2, 10 Oct   1989   change number order of matrix
+//
+//   Notes ...
+//   -----
+//   (1) The accompanying function seval() may be used to evaluate the
+//       spline while deriv will provide the first derivative.
+//   (2) Using p to denote differentiation
+//       y[i] = S(X[i])
+//       b[i] = Sp(X[i])
+//       c[i] = Spp(X[i])/2
+//       d[i] = Sppp(X[i])/6  ( Derivative from the right )
+//   (3) Since the zero elements of the arrays ARE NOW used here,
+//       all arrays to be passed from the main program should be
+//       dimensioned at least [n].  These routines will use elements
+//       [0 .. n-1].
+//   (4) Adapted from the text
+//       Forsythe, G.E., Malcolm, M.A. and Moler, C.B. (1977)
+//       "Computer Methods for Mathematical Computations"
+//       Prentice Hall
+//   (5) Note that although there are only n-1 polynomial segments,
+//       n elements are requird in b, c, d.  The elements b[n-1],
+//       c[n-1] and d[n-1] are set to continue the last segment
+//       past x[n-1].
+//
+static int c_spline_init(const int n, const int end1, const int end2, const float slope1, const float slope2,
+						 const float x[], const float y[],
+						 float b[], float c[], float d[], int *iflag)
+{
+	int     nm1, ib, i;
+	float  t;
+	int     ascend;
+
+	nm1    = n - 1;
+	*iflag = 0;
+
+	/* no possible interpolation */
+	if(n < 2) {
+		*iflag = 1;
+		goto LeaveSpline;
+	}
+
+	ascend = 1;
+	for(i = 1; i < n; ++i)
+		if (x[i] <= x[i-1]) ascend = 0;
+
+	if(!ascend) {
+		*iflag = 2;
+		goto LeaveSpline;
+	}
+
+	if(n >= 3)
+	{
+		/* At least quadratic */
+
+		/* Set up the symmetric tri-diagonal system
+		   b = diagonal
+		   d = offdiagonal
+		   c = right-hand-side  */
+		d[0] = x[1] - x[0];
+		c[1] = (y[1] - y[0]) / d[0];
+		for (i = 1; i < nm1; ++i)
+		{
+			d[i]   = x[i+1] - x[i];
+			b[i]   = 2.0 * (d[i-1] + d[i]);
+			c[i+1] = (y[i+1] - y[i]) / d[i];
+			c[i]   = c[i+1] - c[i];
+		}
+
+		/* Default End conditions
+		   Third derivatives at x[0] and x[n-1] obtained
+		   from divided differences  */
+		b[0]   = -d[0];
+		b[nm1] = -d[n-2];
+		c[0]   = 0.0;
+		c[nm1] = 0.0;
+		if(n != 3) {
+			c[0]   = c[2] / (x[3] - x[1]) - c[1] / (x[2] - x[0]);
+			c[nm1] = c[n-2] / (x[nm1] - x[n-3]) - c[n-3] / (x[n-2] - x[n-4]);
+			c[0]   = c[0] * d[0] * d[0] / (x[3] - x[0]);
+			c[nm1] = -c[nm1] * d[n-2] * d[n-2] / (x[nm1] - x[n-4]);
+		}
+
+		/* Alternative end conditions -- known slopes */
+		if(end1 == 1) {
+			b[0] = 2.0 * (x[1] - x[0]);
+			c[0] = (y[1] - y[0]) / (x[1] - x[0]) - slope1;
+		}
+		if(end2 == 1) {
+			b[nm1] = 2.0 * (x[nm1] - x[n-2]);
+			c[nm1] = slope2 - (y[nm1] - y[n-2]) / (x[nm1] - x[n-2]);
+		}
+
+		/* Forward elimination */
+		for(i = 1; i < n; ++i) {
+			t    = d[i-1] / b[i-1];
+			b[i] = b[i] - t * d[i-1];
+			c[i] = c[i] - t * c[i-1];
+		}
+
+		/* Back substitution */
+		c[nm1] = c[nm1] / b[nm1];
+		for(ib = 0; ib < nm1; ++ib)
+		{
+			i    = n - ib - 2;
+			c[i] = (c[i] - d[i] * c[i+1]) / b[i];
+		}
+
+		/* c[i] is now the sigma[i] of the text */
+
+		/* Compute the polynomial coefficients */
+		b[nm1] = (y[nm1] - y[n-2]) / d[n-2] + d[n-2] * (c[n-2] + 2.0 * c[nm1]);
+		for(i = 0; i < nm1; ++i)
+		{
+			b[i] = (y[i+1] - y[i]) / d[i] - d[i] * (c[i+1] + 2.0 * c[i]);
+			d[i] = (c[i+1] - c[i]) / d[i];
+			c[i] = 3.0 * c[i];
+		}
+		c[nm1] = 3.0 * c[nm1];
+		d[nm1] = d[n-2];
+
+	}
+	else
+	{
+		/* linear segment only  */
+		b[0] = (y[1] - y[0]) / (x[1] - x[0]);
+		c[0] = 0.0;
+		d[0] = 0.0;
+		b[1] = b[0];
+		c[1] = 0.0;
+		d[1] = 0.0;
+	}
+
+LeaveSpline:
+	return 0;
+}
+
+
+// c_spline_eval()
+//
+//  Evaluate the cubic spline function
+//
+//  S(xx) = y[i] + b[i] * w + c[i] * w**2 + d[i] * w**3
+//  where w = u - x[i]
+//  and   x[i] <= u <= x[i+1]
+//  Note that Horner's rule is used.
+//  If u < x[0]   then i = 0 is used.
+//  If u > x[n-1] then i = n-1 is used.
+//
+//  Input :
+//  -------
+//  n       : The number of data points or knots (n >= 2)
+//  u       : the abscissa at which the spline is to be evaluated
+//  Last    : the segment that was last used to evaluate U
+//  x[]     : the abscissas of the knots in strictly increasing order
+//  y[]     : the ordinates of the knots
+//  b, c, d : arrays of spline coefficients computed by spline().
+//
+//  Output :
+//  --------
+//  seval   : the value of the spline function at u
+//  Last    : the segment in which u lies
+//
+//  Notes ...
+//  -----
+//  (1) If u is not in the same interval as the previous call then a
+//      binary search is performed to determine the proper interval.
+//
+static float c_spline_eval(int n, float u, float x[], float y[],
+						   float b[], float c[], float d[], int *last)
+{
+	int    i, j, k;
+	float w;
+
+	i = *last;
+
+	if(i >= n-1) i = 0;
+	if(i < 0)  i = 0;
+
+	/* perform a binary search */
+	if((x[i] > u) || (x[i+1] < u))
+	{
+		i = 0;
+		j = n;
+		do
+		{
+			k = (i + j) / 2;         /* split the domain to search */
+			if (u < x[k])  j = k;    /* move the upper bound */
+			if (u >= x[k]) i = k;    /* move the lower bound */
+		}                            /* there are no more segments to search */
+		while (j > i+1);
+	}
+	*last = i;
+
+	/* Evaluate the spline */
+	w = u - x[i];
+	w = y[i] + w * (b[i] + w * (c[i] + w * d[i]));
+
+	return w;
+}
+
+
+// Taken from "source/blender/render/intern/source/convertblender.c"
+// and slightly modified
+//
+static void get_particle_uvco_mcol(short from, DerivedMesh *dm, float *fuv, int num, ParticleStrandData *sd)
+{
+	int i;
+
+	/* get uvco */
+	if (sd->uvco && ELEM(from, PART_FROM_FACE, PART_FROM_VOLUME)) {
+		for (i=0; i<sd->totuv; i++) {
+			if (num != DMCACHE_NOTFOUND) {
+				MFace  *mface  = dm->getTessFaceData(dm, num, CD_MFACE);
+				MTFace *mtface = (MTFace*)CustomData_get_layer_n(&dm->faceData, CD_MTFACE, i);
+				mtface += num;
+
+				psys_interpolate_uvs(mtface, mface->v4, fuv, sd->uvco + 2 * i);
+			}
+			else {
+				sd->uvco[2*i] = 0.0f;
+				sd->uvco[2*i + 1] = 0.0f;
+			}
+		}
+	}
+}
+
+
+int write_GeomMayaHair(PyObject *outputFile, Scene *sce, Main *bmain, Object *ob, ParticleSystem *psys, const char *pluginName)
+{
+	static char buf[MAX_PLUGIN_NAME];
+
+	int    i, c, p, s;
+	float  f;
+	float  t;
+
+	ParticleSettings           *pset = NULL;
+	ParticleSystemModifierData *psmd = NULL;
+
+	ParticleData       *pa   = NULL;
+	HairKey            *hkey = NULL;
+	ParticleStrandData  sd;
+
+	ParticleCacheKey **child_cache = NULL;
+	ParticleCacheKey  *child_key   = NULL;
+	ChildParticle     *cpa         = NULL;
+	int                child_total = 0;
+	int                child_steps = 0;
+	float              child_key_co[3];
+
+	float     hairmat[4][4];
+	float     segment[3];
+	float     color[3] = {0.5f,0.5f,0.5f};
+	float     width = 0.001f;
+	float     cone_width = 0.001f;
+	int       num = -1;
+
+	int       spline_init_flag;
+	int       interp_points_count;
+	float     interp_points_step;
+	int       data_points_count;
+	float     data_points_step;
+	float     data_points_ordinates[3][64];
+	float     data_points_abscissas[64];
+
+	float     s_b[3][16];
+	float     s_c[3][16];
+	float     s_d[3][16];
+
+	int       spline_last[3];
+
+	short     use_cone    = false;
+	short     use_child   = 0;
+	short     free_edit   = 0;
+	short     need_recalc = 0;
+
+	PointerRNA  rna_pset;
+	PointerRNA  VRayParticleSettings;
+	PointerRNA  VRayFur;
+
+	int  display_percentage;
+	int  display_percentage_child;
+
+	int  debug = false;
+
+	need_recalc = 0;
+
+	pset = psys->part;
+
+	if(pset->type != PART_HAIR) {
+		return 1;
+	}
+
+	if(psys->part->ren_as != PART_DRAW_PATH) {
+		return 1;
+	}
+
+	psmd = psys_get_modifier(ob, psys);
+	if(!psmd) {
+		return 1;
+	}
+	if(!(psmd->modifier.mode & eModifierMode_Render)) {
+		return 1;
+	}
+
+	RNA_id_pointer_create(&pset->id, &rna_pset);
+
+	if(RNA_struct_find_property(&rna_pset, "vray")) {
+		VRayParticleSettings= RNA_pointer_get(&rna_pset, "vray");
+
+		if(RNA_struct_find_property(&VRayParticleSettings, "VRayFur")) {
+			VRayFur = RNA_pointer_get(&VRayParticleSettings, "VRayFur");
+
+			// Get hair width
+			width = RNA_float_get(&VRayFur, "width");
+		}
+	}
+
+	child_cache = psys->childcache;
+	child_total = psys->totchildcache;
+	use_child   = (pset->childtype && child_cache);
+
+	// Store "Display percentage" setting
+	display_percentage       = pset->disp;
+	display_percentage_child = pset->child_nbr;
+
+	// Check if particles are edited
+	free_edit = psys_check_edited(psys);
+
+	// Recalc parent hair only if they are not
+	// manually edited
+	if(!free_edit) {
+		need_recalc = 1;
+		pset->disp = 100;
+		psys->recalc |= PSYS_RECALC;
+	}
+
+	if(use_child) {
+		need_recalc = 1;
+		pset->child_nbr = pset->ren_child_nbr;
+		psys->recalc |= PSYS_RECALC_CHILD;
+	}
+
+	if(psys->flag & PSYS_HAIR_DYNAMICS)
+		need_recalc = 0;
+
+	// Recalc hair with render settings
+	if(need_recalc) {
+		ob->recalc |= OB_RECALC_ALL;
+		BKE_scene_update_tagged(bmain, sce);
+	}
+
+	// Get new child data pointers
+	if(use_child) {
+		child_cache = psys->childcache;
+		child_total = psys->totchildcache;
+
+		DEBUG_PRINT(debug, "child_total = %i", child_total);
+	}
+
+	// Spline interpolation
+	interp_points_count = (int)pow(2.0, pset->ren_step);
+	interp_points_step = 1.0 / (interp_points_count - 1);
+
+	DEBUG_PRINT(debug, "interp_points_count = %i", interp_points_count);
+
+	WRITE_PYOBJECT(outputFile, "GeomMayaHair %s {", pluginName);
+	WRITE_PYOBJECT(outputFile, "\n\tnum_hair_vertices=interpolate((%d,ListIntHex(\"", sce->r.cfra);
+	if(use_child) {
+		for(p = 0; p < child_total; ++p) {
+			WRITE_PYOBJECT_HEX_VALUE(outputFile, interp_points_count);
+		}
+	}
+	else {
+		LOOP_PARTICLES {
+			WRITE_PYOBJECT_HEX_VALUE(outputFile, interp_points_count);
+		}
+	}
+	WRITE_PYOBJECT(outputFile, "\")));");
+
+	WRITE_PYOBJECT(outputFile, "\n\thair_vertices=interpolate((%d,ListVectorHex(\"", sce->r.cfra);
+	if(use_child) {
+		for(p = 0; p < child_total; ++p) {
+			child_key   = child_cache[p];
+			child_steps = child_key->steps;
+
+			// Spline interpolation
+			data_points_count = child_steps;
+			data_points_step  = 1.0f / (child_steps - 1);
+
+			// Store control points
+			for(s = 0, f = 0.0f; s < child_steps; ++s, ++child_key, f += data_points_step) {
+				data_points_abscissas[s] = f;
+
+				// Child particles are stored in world space,
+				// but we need them in object space
+				copy_v3_v3(child_key_co, child_key->co);
+
+				// Remove transform by applying inverse matrix
+				mul_m4_v3(ob->imat, child_key_co);
+
+				for(c = 0; c < 3; ++c) {
+					data_points_ordinates[c][s] = child_key_co[c];
+				}
+			}
+
+			// Init spline coefficients
+			for(c = 0; c < 3; ++c) {
+				c_spline_init(data_points_count, 0, 0, 0.0f, 0.0f,
+							  data_points_abscissas, data_points_ordinates[c],
+							  s_b[c], s_c[c], s_d[c], &spline_init_flag);
+			}
+
+			// Write interpolated child points
+			for(c = 0; c < 3; ++c)
+				spline_last[c] = 0;
+
+			for(t = 0.0f; t <= 1.0; t += interp_points_step) {
+				// Calculate interpolated coordinate
+				for(c = 0; c < 3; ++c) {
+					segment[c] = c_spline_eval(data_points_count, t, data_points_abscissas, data_points_ordinates[c],
+											   s_b[c], s_c[c], s_d[c], &spline_last[c]);
+				}
+
+				WRITE_PYOBJECT_HEX_VECTOR(outputFile, segment);
+			}
+		}
+	}
+	else {
+		LOOP_PARTICLES {
+			DEBUG_PRINT(debug, "\033[0;32mV-Ray/Blender:\033[0m Particle system: %s => Hair: %i\n", psys->name, p + 1);
+
+			psys_mat_hair_to_object(NULL, psmd->dm, psmd->psys->part->from, pa, hairmat);
+
+			// Spline interpolation
+			data_points_count = pa->totkey;
+			data_points_step  = 1.0f / (data_points_count - 1);
+
+			DEBUG_PRINT(debug, "data_points_count = %i", data_points_count);
+			DEBUG_PRINT(debug, "data_points_step = %.3f", data_points_step);
+
+			for(i = 0, f = 0.0f; i < data_points_count; ++i, f += data_points_step) {
+				data_points_abscissas[i] = f;
+			}
+
+			// Store control points
+			for(s = 0, hkey = pa->hair; s < pa->totkey; ++s, ++hkey) {
+				copy_v3_v3(segment, hkey->co);
+				mul_m4_v3(hairmat, segment);
+
+				for(c = 0; c < 3; ++c) {
+					data_points_ordinates[c][s] = segment[c];
+				}
+			}
+
+			// Init spline coefficients
+			for(c = 0; c < 3; ++c) {
+				c_spline_init(data_points_count, 0, 0, 0.0f, 0.0f,
+							  data_points_abscissas, data_points_ordinates[c],
+							  s_b[c], s_c[c], s_d[c], &spline_init_flag);
+			}
+
+			// Write interpolated points
+			for(c = 0; c < 3; ++c)
+				spline_last[c] = 0;
+			for(t = 0.0f; t <= 1.0; t += interp_points_step) {
+				// Calculate interpolated coordinates
+				for(c = 0; c < 3; ++c) {
+					segment[c] = c_spline_eval(data_points_count, t, data_points_abscissas, data_points_ordinates[c],
+											   s_b[c], s_c[c], s_d[c], &spline_last[c]);
+				}
+				WRITE_PYOBJECT_HEX_VECTOR(outputFile, segment);
+			}
+		}
+	}
+	WRITE_PYOBJECT(outputFile, "\")));");
+
+	memset(&sd, 0, sizeof(ParticleStrandData));
+
+	// DEBUG_PRINT(TRUE, "psmd->dm = 0x%X", psmd->dm);
+
+	if(psmd->dm) {
+		if(use_child) {
+			sd.totuv = CustomData_number_of_layers(&psmd->dm->faceData, CD_MTFACE);
+
+			if(sd.totuv) {
+				sd.uvco = MEM_callocN(sd.totuv * 2 * sizeof(float), "particle_uvs");
+			}
+			else {
+				sd.uvco = NULL;
+			}
+
+			if(sd.uvco) {
+				WRITE_PYOBJECT(outputFile, "\n\tstrand_uvw=interpolate((%d,ListVectorHex(\"", sce->r.cfra);
+
+				for(p = 0; p < child_total; ++p) {
+					cpa = psys->child + p;
+
+					/* get uvco & mcol */
+					if(pset->childtype==PART_CHILD_FACES) {
+						get_particle_uvco_mcol(PART_FROM_FACE, psmd->dm, cpa->fuv, cpa->num, &sd);
+					}
+					else {
+						ParticleData *parent = psys->particles + cpa->parent;
+						num = parent->num_dmcache;
+
+						if (num == DMCACHE_NOTFOUND)
+							if (parent->num < psmd->dm->getNumTessFaces(psmd->dm))
+								num = parent->num;
+
+						get_particle_uvco_mcol(pset->from, psmd->dm, parent->fuv, num, &sd);
+					}
+
+					segment[0] = sd.uvco[0];
+					segment[1] = sd.uvco[1];
+					segment[2] = 0.0f;
+
+					WRITE_PYOBJECT_HEX_VECTOR(outputFile, segment);
+				}
+				WRITE_PYOBJECT(outputFile, "\")));");
+
+				MEM_freeN(sd.uvco);
+			}
+		}
+		else {
+			sd.totuv = CustomData_number_of_layers(&psmd->dm->faceData, CD_MTFACE);
+
+			if(sd.totuv) {
+				sd.uvco = MEM_callocN(sd.totuv * 2 * sizeof(float), "particle_uvs");
+			}
+			else {
+				sd.uvco = NULL;
+			}
+
+			if(sd.uvco) {
+				WRITE_PYOBJECT(outputFile, "\n\tstrand_uvw=interpolate((%d,ListVectorHex(\"", sce->r.cfra);
+				LOOP_PARTICLES {
+					/* get uvco & mcol */
+					num = pa->num_dmcache;
+
+					if(num == DMCACHE_NOTFOUND) {
+						if(pa->num < psmd->dm->getNumTessFaces(psmd->dm)) {
+							num = pa->num;
+						}
+					}
+
+					get_particle_uvco_mcol(pset->from, psmd->dm, pa->fuv, num, &sd);
+
+					// DEBUG_PRINT(TRUE, "Pa.uv = %.3f, %.3f", sd.uvco[0], sd.uvco[1]);
+
+					segment[0] = sd.uvco[0];
+					segment[1] = sd.uvco[1];
+					segment[2] = 0.0f;
+
+					WRITE_PYOBJECT_HEX_VECTOR(outputFile, segment);
+				}
+				WRITE_PYOBJECT(outputFile, "\")));");
+
+				MEM_freeN(sd.uvco);
+			}
+		}
+	}
+
+	WRITE_PYOBJECT(outputFile, "\n\twidths=interpolate((%d,ListFloatHex(\"", sce->r.cfra);
+	if(use_child) {
+		for(p = 0; p < child_total; ++p) {
+			cone_width = width;
+			for(s = 0; s < interp_points_count; ++s) {
+				if(use_cone && s > 0) {
+					cone_width = width / s;
+				}
+				WRITE_PYOBJECT_HEX_VALUE(outputFile, cone_width);
+			}
+		}
+	}
+	else {
+		for(p = 0; p < psys->totpart; ++p) {
+			for(s = 0; s < interp_points_count; ++s) {
+				cone_width = width;
+				if(use_cone && s > 0) {
+					cone_width = width / s;
+				}
+				WRITE_PYOBJECT_HEX_VALUE(outputFile, cone_width);
+			}
+		}
+	}
+	WRITE_PYOBJECT(outputFile, "\")));");
+
+	WRITE_PYOBJECT(outputFile, "\n\tcolors=interpolate((%d,ListColorHex(\"", sce->r.cfra);
+	if(use_child) {
+		for(p = 0; p < child_total; ++p) {
+			for(s = 0; s < interp_points_count; ++s) {
+				WRITE_PYOBJECT_HEX_VECTOR(outputFile, color);
+			}
+		}
+	}
+	else {
+		for(p = 0; p < psys->totpart; ++p) {
+			for(s = 0; s < interp_points_count; ++s) {
+				WRITE_PYOBJECT_HEX_VECTOR(outputFile, color);
+			}
+		}
+	}
+	WRITE_PYOBJECT(outputFile, "\")));");
+
+	WRITE_PYOBJECT(outputFile, "\n\topacity=1.0;");
+	if(psys->part->flag & PART_HAIR_BSPLINE) {
+		WRITE_PYOBJECT(outputFile, "\n\tgeom_splines=1;");
+		WRITE_PYOBJECT(outputFile, "\n\tgeom_tesselation_mult=1.0;");
+	}
+	WRITE_PYOBJECT(outputFile, "\n}\n\n");
+
+	// Restore "Display percentage" setting
+	pset->disp      = display_percentage;
+	pset->child_nbr = display_percentage_child;
+
+	if(!free_edit) {
+		psys->recalc |= PSYS_RECALC;
+	}
+	if(use_child) {
+		psys->recalc |= PSYS_RECALC_CHILD;
+	}
+
+	// Recalc hair back with viewport settings
+	if(need_recalc) {
+		ob->recalc |= OB_RECALC_ALL;
+		BKE_scene_update_tagged(bmain, sce);
+	}
+
+	return 0;
+}
diff --git a/blender/source/blender/vray_for_blender/vrscene_exporter/node.c b/blender/source/blender/vray_for_blender/vrscene_exporter/node.c
new file mode 100644
index 0000000..be7926d
--- /dev/null
+++ b/blender/source/blender/vray_for_blender/vrscene_exporter/node.c
@@ -0,0 +1,119 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2010 Blender Foundation.
+ * All rights reserved.
+ *
+ * Contributor(s): Andrei Izrantcev <andrei.izrantcev@chaosgroup.com>
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#include "utils/CGR_string.h"
+
+#include "vrscene.h"
+
+
+static void  write_ObjectNode(PyObject   *nodeFile,
+							  PyObject   *geomFile,
+							  Scene      *sce,
+							  Main       *main,
+							  Object     *ob,
+							  float       tm[4][4],
+							  const char *pluginName)
+{
+	static char buf[MAX_PLUGIN_NAME];
+
+	char material[MAX_PLUGIN_NAME];
+	char geometry[MAX_PLUGIN_NAME];
+	
+	// TODO:
+	//   [ ] Add type checking and sync with Python naming
+	//
+	sprintf(material, "RS%s", ob->id.name);
+	sprintf(geometry, "%s", ((Mesh*)ob->data)->id.name);
+	
+	StripString(material);
+	StripString(geometry);
+
+	write_Mesh(geomFile, sce, ob, main, geometry, NULL);
+	
+	WRITE_PYOBJECT(nodeFile, "\nNode %s {", pluginName);
+	WRITE_PYOBJECT(nodeFile, "\n\tobjectID=%i;", ob->index);
+	WRITE_PYOBJECT(nodeFile, "\n\tmaterial=RS%s;", material);
+	WRITE_PYOBJECT(nodeFile, "\n\tgeometry=%s;", geometry);
+	WRITE_PYOBJECT(nodeFile, "\n\ttransform=interpolate((%d,", sce->r.cfra);
+	WRITE_PYOBJECT_TRANSFORM(nodeFile, tm);
+	WRITE_PYOBJECT(nodeFile, "));");
+	WRITE_PYOBJECT(nodeFile, "\n}\n");
+}
+
+
+void  write_Node(PyObject   *outputFile,
+				 Scene      *sce,
+				 Object     *ob,
+				 const char *pluginName,
+				 const char *transform,
+				 const char *geometry,
+				 const char *material,
+				 const char *volume,
+				 const int   nsamples,
+				 const char *lights,
+				 const char *user_attributes,
+				 const int   visible,
+				 const int   objectID,
+				 const int   primary_visibility)
+{
+}
+
+
+static void free_duplilist(Object *ob)
+{
+	if(ob->duplilist) {
+		free_object_duplilist(ob->duplilist);
+		ob->duplilist = NULL;
+	}
+}
+
+
+void write_Dupli(PyObject   *nodeFile,
+				 PyObject   *geomFile,
+				 Scene      *sce,
+				 Main       *main,
+				 Object     *ob)
+{
+	DupliObject *dob;
+
+	char pluginName[MAX_PLUGIN_NAME];
+	
+	// Free duplilist if a user forgets to
+	free_duplilist(ob);
+
+	ob->duplilist = object_duplilist(sce, ob, TRUE);
+
+	for(dob = ob->duplilist->first; dob; dob = dob->next) {
+		sprintf(pluginName, "%s%.5i", dob->ob->id.name, dob->persistent_id[0]);
+		StripString(pluginName);
+
+		PRINT_INFO("Processing dupli %s", dob->ob->id.name);
+		
+		write_ObjectNode(nodeFile, geomFile, sce, main, dob->ob, dob->mat, pluginName);
+	}
+
+	// Free our duplilist
+	free_duplilist(ob);
+}
diff --git a/blender/source/blender/vray_for_blender/vrscene_exporter/smoke.cpp b/blender/source/blender/vray_for_blender/vrscene_exporter/smoke.cpp
new file mode 100644
index 0000000..68550e2
--- /dev/null
+++ b/blender/source/blender/vray_for_blender/vrscene_exporter/smoke.cpp
@@ -0,0 +1,308 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2010 Blender Foundation.
+ * All rights reserved.
+ *
+ * Contributor(s): Andrei Izrantcev <andrei.izrantcev@chaosgroup.com>
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#include "vrscene.h"
+
+#include "smoke_API.h"
+
+#define USE_HEAT           0
+#define USE_LOCAL_DOMAIN   1
+
+#define DEBUG_GIZMO_SHAPE  0
+
+
+static void GetDomainBounds(SmokeDomainSettings *sds, float p0[3], float p1[3])
+{
+	if(sds->flags & MOD_SMOKE_ADAPTIVE_DOMAIN) {
+		p0[0] = sds->p0[0] + sds->cell_size[0] * sds->res_min[0];
+		p0[1] = sds->p0[1] + sds->cell_size[1] * sds->res_min[1];
+		p0[2] = sds->p0[2] + sds->cell_size[2] * sds->res_min[2];
+		p1[0] = sds->p0[0] + sds->cell_size[0] * sds->res_max[0];
+		p1[1] = sds->p0[1] + sds->cell_size[1] * sds->res_max[1];
+		p1[2] = sds->p0[2] + sds->cell_size[2] * sds->res_max[2];
+	}
+	else {
+		p0[0] = -1.0f;
+		p0[1] = -1.0f;
+		p0[2] = -1.0f;
+		p1[0] =  1.0f;
+		p1[1] =  1.0f;
+		p1[2] =  1.0f;
+	}
+	
+	// PRINT_INFO("sds->res_min = %i %i %i", sds->res_min[0], sds->res_min[1], sds->res_min[2]);
+	// PRINT_INFO("sds->res_max = %i %i %i", sds->res_max[0], sds->res_max[1], sds->res_max[2]);
+	// PRINT_INFO("sds->cell_size = %.3f %.3f %.3f", sds->cell_size[0], sds->cell_size[1], sds->cell_size[2]);
+	// PRINT_INFO("sds->p0 = %.3f %.3f %.3f", sds->p0[0], sds->p0[1], sds->p0[2]);
+	// PRINT_INFO("sds->p1 = %.3f %.3f %.3f", sds->p1[0], sds->p1[1], sds->p1[2]);		
+	// PRINT_INFO("p0 = %.3f %.3f %.3f", p0[0], p0[1], p0[2]);
+	// PRINT_INFO("p1 = %.3f %.3f %.3f", p1[0], p1[1], p1[2]);
+}
+
+
+// Represents transformation of base domain to adaptive domain
+//
+static void GetBaseToAdaptiveTransform(SmokeDomainSettings *sds, float tm[4][4])
+{
+	float p0[3];
+	float p1[3];
+	
+	GetDomainBounds(sds, p0, p1);
+	
+	unit_m4(tm);
+
+	tm[0][0] = fabs(p1[0] - p0[0]) / 2.0f;
+	tm[1][1] = fabs(p1[1] - p0[1]) / 2.0f;
+	tm[2][2] = fabs(p1[2] - p0[2]) / 2.0f;
+	
+	tm[3][0] = (p0[0] + p1[0]) / 2.0f;
+	tm[3][1] = (p0[1] + p1[1]) / 2.0f;
+	tm[3][2] = (p0[2] + p1[2]) / 2.0f;
+	
+	// PRINT_TM4("adaptive", tm);
+}
+
+
+static void GetDomainTransform(Object *ob, SmokeDomainSettings *sds, float tm[4][4])
+{
+	unit_m4(tm);
+	
+	float domainToAdaptiveTM[4][4];
+	GetBaseToAdaptiveTransform(sds, domainToAdaptiveTM);
+	
+	mul_m4_m4m4(tm, ob->obmat, domainToAdaptiveTM);
+	
+	// PRINT_TM4("object", ob->obmat);
+	// PRINT_TM4("domain", tm);
+}
+
+
+static void write_SmokeGizmo(PyObject          *outputFile,
+							 Scene             *sce,
+							 Object            *ob,
+							 SmokeModifierData *smd,
+							 const char        *pluginName,
+							 const char        *geometryName,
+							 const char        *lights)
+{
+	static char buf[MAX_PLUGIN_NAME];
+	
+	SmokeDomainSettings *sds = smd->domain;
+	
+	float domainTM[4][4];
+	GetDomainTransform(ob, sds, domainTM);
+	
+	WRITE_PYOBJECT(outputFile, "\nEnvFogMeshGizmo %s {", pluginName);	
+	WRITE_PYOBJECT(outputFile, "\n\tgeometry=%s;", geometryName);
+	if(strlen(lights)) {
+		WRITE_PYOBJECT(outputFile, "\n\tlights=%s;", lights);
+	}
+	WRITE_PYOBJECT(outputFile, "\n\ttransform=interpolate((%d,", sce->r.cfra);
+	WRITE_PYOBJECT_TRANSFORM(outputFile, domainTM);
+	WRITE_PYOBJECT(outputFile, "));");	
+	WRITE_PYOBJECT(outputFile, "\n}\n");
+	
+#if DEBUG_GIZMO_SHAPE
+	WRITE_PYOBJECT(outputFile, "\nNode Node%s {", geometryName);
+	WRITE_PYOBJECT(outputFile, "\n\tgeometry=%s;", geometryName);
+	WRITE_PYOBJECT(outputFile, "\n\tmaterial=MANOMATERIALISSET;");
+	WRITE_PYOBJECT(outputFile, "\n\ttransform=interpolate((%d,", sce->r.cfra);
+	WRITE_PYOBJECT_TRANSFORM(outputFile, domainTM);
+	WRITE_PYOBJECT(outputFile, "));");	
+	WRITE_PYOBJECT(outputFile, "\n}\n");
+#endif
+}
+
+
+void write_SmokeDomain(PyObject          *outputFile,
+					   Scene             *sce,
+					   Object            *ob,
+					   SmokeModifierData *smd,
+					   const char        *pluginName,
+					   const char        *lights)
+{
+	static char buf[MAX_PLUGIN_NAME];
+	
+	char geomteryPluginName[MAX_PLUGIN_NAME];
+	sprintf(geomteryPluginName, "Geom%s", pluginName);
+		
+	// Topology is always the same:
+	//   2.0 x 2.0 x 2.0 box
+	//     pmin = -1.0, -1.0, 1.0
+	//     pmax =  1.0,  1.0, 1.0
+	//
+	WRITE_PYOBJECT(outputFile, "\nGeomStaticMesh %s {", geomteryPluginName);
+	WRITE_PYOBJECT(outputFile,
+				   "\n\tvertices=ListVectorHex(\""
+				   "000080BF000080BF000080BF000080BF000080BF0000803F000080BF0000803F0000803F000080BF0000803F000080BF"
+				   "0000803F000080BF000080BF0000803F000080BF0000803F0000803F0000803F0000803F0000803F0000803F000080BF\");");
+	WRITE_PYOBJECT(outputFile,
+				   "\n\tfaces=ListIntHex(\""
+				   "000000000100000002000000020000000300000000000000020000000100000005000000050000000600000002000000"
+				   "070000000600000005000000050000000400000007000000000000000300000007000000070000000400000000000000"
+				   "030000000200000006000000060000000700000003000000010000000000000004000000040000000500000001000000\");");
+	WRITE_PYOBJECT(outputFile, "\n}\n");
+	
+	write_SmokeGizmo(outputFile, sce, ob, smd, pluginName, geomteryPluginName, lights);
+}
+
+
+// Blender smoke uses 2.0 x 2.0 x 2.0 mesh domain and then uses object transform to form the final
+// smoke domain, there also could be an adaptive domain, so we need to transform UVWs
+//
+static void write_SmokeUVWGen(PyObject          *outputFile,
+							  Scene             *sce,
+							  Object            *ob,
+							  SmokeModifierData *smd,
+							  const char        *pluginName)
+{
+	static char buf[MAX_PLUGIN_NAME];
+	
+	SmokeDomainSettings *sds = smd->domain;	
+
+	float domainTm[4][4];
+	GetDomainTransform(ob, sds, domainTm);
+	invert_m4(domainTm);
+	
+	// Remaps [-1.0, 1.0] to [0.0, 1.0]
+	float uvwTm[4][4];
+	scale_m4_fl(uvwTm, 0.5f);
+	copy_v3_fl(uvwTm[3], 0.5f);
+		
+	float uvw_transform[4][4];
+	mul_m4_m4m4(uvw_transform, uvwTm, domainTm);
+	
+	WRITE_PYOBJECT(outputFile, "\nUVWGenPlanarWorld %s {", pluginName);
+	WRITE_PYOBJECT(outputFile, "\n\tuvw_transform=interpolate((%d,", sce->r.cfra);
+	WRITE_PYOBJECT_TRANSFORM(outputFile, uvw_transform);
+	WRITE_PYOBJECT(outputFile, "));");
+	WRITE_PYOBJECT(outputFile, "\n}\n");
+}
+
+
+void write_TexVoxelData(PyObject          *outputFile,
+						Scene             *sce,
+						Object            *ob,
+						SmokeModifierData *smd,
+						const char        *pluginName, 
+						short              interpolation)
+{
+	static char buf[MAX_PLUGIN_NAME];
+
+	SmokeDomainSettings *sds = smd->domain;
+	
+	char uvwPluginName[MAX_PLUGIN_NAME];
+	sprintf(uvwPluginName, "UVW%s", pluginName);
+	
+	size_t i;
+	size_t tot_res_high;
+	size_t tot_res_low;
+	
+	int    res_high[3];
+	int    res_low[3];
+	
+	float  ob_imat[4][4];
+		
+	if(NOT(sds && sds->fluid)) {
+		PRINT_ERROR("Domain and / or fluid data not found!");
+		return;
+	}
+
+	// Store object invert matrix
+	invert_m4_m4(ob_imat, ob->obmat);
+
+	// flame: Use flame temperature as texture data
+	// dens: Use smoke density and color as texture data
+	// heat: Use smoke heat as texture data. Values from -2.0 to 2.0 are used
+	float dt, dx, *dens, *react, *fuel, *flame, *heat, *heatold, *vx, *vy, *vz, *r, *g, *b;
+	float _d, _fu, _fl;
+	unsigned char *obstacles;
+	float *tcu, *tcv, *tcw;
+	
+	if(sds->flags & MOD_SMOKE_HIGHRES) {
+		COPY_VECTOR_3_3(res_high, sds->res_wt);
+		COPY_VECTOR_3_3(res_low,  sds->res);
+		
+		smoke_turbulence_export(sds->wt, &dens, &react, &flame, &fuel, &r, &g, &b, &tcu, &tcv, &tcw);
+	}
+	else {
+		COPY_VECTOR_3_3(res_high, sds->res);
+		COPY_VECTOR_3_3(res_low,  sds->res);
+		
+		smoke_export(sds->fluid, &dt, &dx, &dens, &react, &flame, &fuel, &heat, &heatold, &vx, &vy, &vz, &r, &g, &b, &obstacles);
+	}
+	
+	// PRINT_INFO("sds->res      = %i %i %i", sds->res[0],    sds->res[1],    sds->res[2]);
+	// PRINT_INFO("sds->res_wt   = %i %i %i", sds->res_wt[0], sds->res_wt[1], sds->res_wt[2]);
+	// PRINT_INFO("sds->base_res = %i %i %i", sds->base_res[0], sds->base_res[1], sds->base_res[2]);
+	
+	tot_res_high = (size_t)res_high[0] * (size_t)res_high[1] * (size_t)res_high[2];
+	tot_res_low  = (size_t)res_low[0]  * (size_t)res_low[1]  * (size_t)res_low[2];	
+	
+	write_SmokeUVWGen(outputFile, sce, ob, smd, uvwPluginName);
+	
+	WRITE_PYOBJECT(outputFile, "\nTexVoxelData %s {", pluginName);
+	WRITE_PYOBJECT(outputFile, "\n\tuvwgen=%s;", uvwPluginName);
+	WRITE_PYOBJECT(outputFile, "\n\tinterpolation=%i;", interpolation);
+	WRITE_PYOBJECT(outputFile, "\n\tresolution=Vector(%i,%i,%i);", res_high[0], res_high[1], res_high[2]);
+#if USE_HEAT
+	WRITE_PYOBJECT(outputFile, "\n\tresolution_low=Vector(%i,%i,%i);", res_low[0], res_low[1], res_low[2]);
+#endif
+
+	WRITE_PYOBJECT(outputFile, "\n\tdensity=interpolate((%d, ListFloatHex(\"", sce->r.cfra);
+	for(i = 0; i < tot_res_high; ++i) {
+		_d = dens ? dens[i] : 0.0f;
+		WRITE_PYOBJECT_HEX_VALUE(outputFile, _d);
+	}
+	WRITE_PYOBJECT(outputFile, "\")));");
+
+	WRITE_PYOBJECT(outputFile, "\n\tflame=interpolate((%d, ListFloatHex(\"", sce->r.cfra);
+	for(i = 0; i < tot_res_high; ++i) {
+		_fl = flame ? flame[i] : 0.0f;
+		WRITE_PYOBJECT_HEX_VALUE(outputFile, _fl);
+	}
+	WRITE_PYOBJECT(outputFile, "\")));");
+	
+	WRITE_PYOBJECT(outputFile, "\n\tfuel=interpolate((%d, ListFloatHex(\"", sce->r.cfra);
+	for(i = 0; i < tot_res_high; ++i) {
+		_fu = fuel ? fuel[i] : 0.0f;
+		WRITE_PYOBJECT_HEX_VALUE(outputFile, _fu);
+	}
+	WRITE_PYOBJECT(outputFile, "\")));");
+	
+#if USE_HEAT
+	if(NOT(sds->flags & MOD_SMOKE_HIGHRES)) {
+		WRITE_PYOBJECT(outputFile, "\n\theat=interpolate((%d, ListFloatHex(\"", sce->r.cfra);
+		// Heat is somehow always low res
+		for(i = 0; i < tot_res_low; ++i) {
+			_h = heat ? heat[i] : 0.0f;
+			WRITE_PYOBJECT_HEX_VALUE(outputFile, _h);
+		}
+		WRITE_PYOBJECT(outputFile, "\")));");
+	}
+#endif
+	
+	WRITE_PYOBJECT(outputFile, "\n}\n");
+}
diff --git a/blender/source/blender/vray_for_blender/vrscene_exporter/vrscene.h b/blender/source/blender/vray_for_blender/vrscene_exporter/vrscene.h
new file mode 100644
index 0000000..9fac96f
--- /dev/null
+++ b/blender/source/blender/vray_for_blender/vrscene_exporter/vrscene.h
@@ -0,0 +1,121 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2010 Blender Foundation.
+ * All rights reserved.
+ *
+ * Contributor(s): Andrei Izrantcev <andrei.izrantcev@chaosgroup.com>
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#ifndef VRSCENE_H
+#define VRSCENE_H
+
+#include "CGR_config.h"
+
+#include <Python.h>
+
+#include "blender_includes.h"
+
+#define MAX_PLUGIN_NAME  1024
+
+#define COPY_VECTOR_3_3(a, b) \
+	a[0] = b[0];\
+	a[1] = b[1];\
+	a[2] = b[2];
+
+#define HEX(x) htonl(*(int*)&(x))
+#define WRITE_HEX_VALUE(f, v) fprintf(f, "%08X", HEX(v));
+#define WRITE_HEX_VECTOR(f, v) fprintf(f, "%08X%08X%08X", HEX(v[0]), HEX(v[1]), HEX(v[2]))
+
+#define WRITE_TRANSFORM(f, m) fprintf(f, "Transform(Matrix(Vector(%f, %f, %f),Vector(%f, %f, %f),Vector(%f, %f, %f)),Vector(%f, %f, %f))", \
+	m[0][0], m[0][1], m[0][2],\
+	m[1][0], m[1][1], m[1][2],\
+	m[2][0], m[2][1], m[2][2],\
+	m[3][0], m[3][1], m[3][2]);
+
+#define WRITE_TRANSFORM_HEX(f, m) fprintf(f, "TransformHex(\"%08X%08X%08X%08X%08X%08X%08X%08X%08X%08X%08X%08X\")", \
+	HEX(m[0][0]), HEX(m[0][1]), HEX(m[0][2]),\
+	HEX(m[1][0]), HEX(m[1][1]), HEX(m[1][2]),\
+	HEX(m[2][0]), HEX(m[2][1]), HEX(m[2][2]),\
+	HEX(m[3][0]), HEX(m[3][1]), HEX(m[3][2]))
+
+#define WRITE_HEX_QUADFACE(f, face) fprintf(gfile, "%08X%08X%08X%08X%08X%08X", HEX(face->v1), HEX(face->v2), HEX(face->v3), HEX(face->v3), HEX(face->v4), HEX(face->v1))
+#define WRITE_HEX_TRIFACE(f, face)  fprintf(gfile, "%08X%08X%08X", HEX(face->v1), HEX(face->v2), HEX(face->v3))
+
+#define WRITE_PYOBJECT_BUF(pyObject) \
+	PyObject_CallMethod(pyObject, (char*)"write", (char*)"s", buf);
+
+#define WRITE_PYOBJECT(pyObject, ...) \
+	sprintf(buf, __VA_ARGS__); \
+	WRITE_PYOBJECT_BUF(pyObject);
+
+#define WRITE_PYOBJECT_HEX_VALUE(pyObject, v) \
+	sprintf(buf, "%08X", HEX(v)); \
+	WRITE_PYOBJECT_BUF(pyObject);
+
+#define WRITE_PYOBJECT_HEX_VECTOR(pyObject, v) \
+	sprintf(buf, "%08X%08X%08X", HEX(v[0]), HEX(v[1]), HEX(v[2])); \
+	WRITE_PYOBJECT_BUF(pyObject);
+
+#define WRITE_PYOBJECT_HEX_QUADFACE(pyObject, face) \
+	sprintf(buf, "%08X%08X%08X%08X%08X%08X", HEX(face->v1), HEX(face->v2), HEX(face->v3), HEX(face->v3), HEX(face->v4), HEX(face->v1));\
+	WRITE_PYOBJECT_BUF(pyObject);
+
+#define WRITE_PYOBJECT_HEX_TRIFACE(pyObject, face) \
+	sprintf(buf, "%08X%08X%08X", HEX(face->v1), HEX(face->v2), HEX(face->v3)); \
+	WRITE_PYOBJECT_BUF(pyObject);
+
+#define WRITE_PYOBJECT_TRANSFORM(pyObject, m) \
+	sprintf(buf, "Transform(Matrix(Vector(%f, %f, %f),Vector(%f, %f, %f),Vector(%f, %f, %f)),Vector(%f, %f, %f))", \
+	   m[0][0], m[0][1], m[0][2],\
+	   m[1][0], m[1][1], m[1][2],\
+	   m[2][0], m[2][1], m[2][2],\
+	   m[3][0], m[3][1], m[3][2]); \
+	WRITE_PYOBJECT_BUF(pyObject);
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int   write_GeomMayaHair(PyObject *outputFile, Scene *sce, Main *main, Object *ob, ParticleSystem *psys, const char *pluginName);
+
+void  write_Mesh(PyObject *outputFile, Scene *sce, Object *ob, Main *main, const char *pluginName, PyObject *propGroup);
+void  write_GeomStaticMesh(PyObject *outputFile, Scene *sce, Object *ob, Mesh *mesh, const char *pluginName, PyObject *propGroup);
+
+void  write_SmokeDomain(PyObject *outputFile, Scene *sce, Object *ob, SmokeModifierData *smd, const char *pluginName, const char *lights);
+void  write_TexVoxelData(PyObject *outputFile, Scene *sce, Object *ob, SmokeModifierData *smd, const char *pluginName, short interp_type);
+
+void  write_Dupli(PyObject *nodeFile, PyObject *geomFile, Scene *sce, Main *main, Object *ob);
+void  write_Node(PyObject *outputFile, Scene *sce, Object *ob, const char *pluginName,
+				 const char *transform,
+				 const char *geometry,
+				 const char *material,
+				 const char *volume,
+				 const int   nsamples,
+				 const char *lights,
+				 const char *user_attributes,
+				 const int   visible,
+				 const int   objectID,
+				 const int   primary_visibility);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // VRSCENE_H
diff --git a/blender/source/creator/CMakeLists.txt b/blender/source/creator/CMakeLists.txt
index 33d5c7d..61900c7 100644
--- a/blender/source/creator/CMakeLists.txt
+++ b/blender/source/creator/CMakeLists.txt
@@ -1031,6 +1031,10 @@ endif()
 		list_insert_after(BLENDER_SORTED_LIBS "ge_logic_ngnetwork" "extern_bullet")
 	endif()
 
+	if(WITH_VRAY_FOR_BLENDER)
+		list_insert_after(BLENDER_SORTED_LIBS "bf_python_bmesh" "vray_for_blender")
+	endif()
+
 	foreach(SORTLIB ${BLENDER_SORTED_LIBS})
 		set(REMLIB ${SORTLIB})
 		foreach(SEARCHLIB ${BLENDER_LINK_LIBS})
